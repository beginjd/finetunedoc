{"instruction": "What is that the container is owned by the activity that the program has acquired by in COBOL?", "input": "", "output": "that the container is owned by the activity that the program has acquired by is of an\nACQUIRE ACTIVITYID command"}
{"instruction": "Summarize this COBOL documentation section", "input": "Example 3\nIf argument-1 is a UTF-8 encoded item and the UTF-8 argument contains composed characters, the\ncombining characters are counted individually. For example, when encoded in UTF-8, the Unicode\ncharacter ä can be x'C3A4' or x'61CC88'. With either of the UTF-8 characters in argument-1, the returned\nvalues of the UPOS function are different. See the following table for details.\nTable 71. Returned values of the UPOS function\nargument-\n1\nUnicode encoding\nUTF-8 encoding\nReturned values of the\nUPOS function\nC = äK\nU+00E4 + U+004B\n(precomposed form, \nlatin small letter a with diaeresis + latin capital letter K)\nx'C3A44B' (äK)\nUPOS(C 1) returns 1\nUPOS(C 2) returns 3\nUPOS(C 3) returns 0\nU+0061 + U+0308 + U+004B\n(canonical decomposition, \nlatin small letter a + combining diaeresis + latin capital letter K)\nx'61CC884B' (äK)\nUPOS(C 1) returns 1\nUPOS(C 2) returns 2\nUPOS(C 3) returns 4\n672  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "Example 3\nIf argument-1 is a UTF-8 encoded item and the UTF-8 argument contains composed characters, the\ncombining characters are counted individually. For example, when encoded in UTF-8, the Unicode\ncharacter ä can be x'C3A4' or x'61CC88'. With either of the UTF-8 characters in argument-1, the returned\nvalues of the UPOS function are different. See the following table for details.\nTable 71. Returned values of the UPOS function\nargument-\n1\nUnicode encoding\nUTF-8 encoding\nReturned values of the\nUPOS function\nC = äK\nU+00E4 + U+004B\n(precomposed form, \nlatin small letter a with diaeresis + latin capital letter K)\nx'C3A44B' (äK)\nUPOS(C 1) returns 1\nUPOS(C 2) returns 3\nUPOS(C 3) returns 0\nU+0061 + U+0308 + U+004B\n(canonical decomposition, \nlatin small letter a + combining diaeresis + latin capital letter K)\nx'61CC884B' (äK)\nUPOS(C 1) returns 1\nUPOS(C 2) returns 2\nUPOS(C 3) returns 4\n672  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "Explain this COBOL concept", "input": "A level-66 entry cannot rename another level-66 entry, nor can it rename a level-01, level-77, or level-88\nentry.\nAll level-66 entries associated with one record must immediately follow the last data description entry in\nthat record.\nSee “RENAMES clause” on page 232 for further details.\nFormat 3\nFormat 3 describes condition-names.\nFormat 3: condition-name\n88\ncondition-name-1\nvalue-clause.\ncondition-name-1\nA user-specified name that associates a value, a set of values, or a range of values with a conditional\nvariable.\nLevel-88 entries must immediately follow the data description entry for the conditional variable with\nwhich the condition-names are associated.\nFormat 3 can be used to describe elementary items, national group items, or alphanumeric group items.\nAdditional information about condition-name entries can be found under “VALUE clause” on page 251\nand “Condition-name condition” on page 277.\nFormat 4\nFormat 4 describes type declarations.\nFormat 4: type declarations\n01\ntype-name-1\ntypedef-clause.\nblank-when-zero-clause\ndynamic-length-clause\nglobal-clause\nglobal-usage-clause\njustified-clause\noccurs-clause\npicture-clause\nsign-clause\nsynchronized-clause\nusage-clause\nvalue-clause\ntype-clause\nThe clauses can be written in any order.\ntype-name-1 explicitly identifies a type declaration and is a COBOL user-defined word. See “User-defined\nwords” on page 12.\nThe level-number in format 4 always 01.\nA space, a comma, or a semicolon must separate clauses.\n198  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "A level-66 entry cannot rename another level-66 entry, nor can it rename a level-01, level-77, or level-88\nentry.\nAll level-66 entries associated with one record must immediately follow the last data description entry in\nthat record.\nSee “RENAMES clause” on page 232 for further details.\nFormat 3\nFormat 3 describes condition-names.\nFormat 3: condition-name\n88\ncondition-name-1\nvalue-clause.\ncondition-name-1\nA user-specified name that associates a value, a set of values, or a range of values with a conditional\nvariable.\nLevel-88 entries must immediately follow the data description entry for the conditional variable with\nwhich the condition-names are associated.\nFormat 3 can be used to describe elementary items, national group items, or alphanumeric group items.\nAdditional information about condition-name entries can be found under “VALUE clause” on page 251\nand “Condition-name condition” on page 277.\nFormat 4\nFormat 4 describes type declarations.\nFormat 4: type declarations\n01\ntype-name-1\ntypedef-clause.\nblank-when-zero-clause\ndynamic-length-clause\nglobal-clause\nglobal-usage-clause\njustified-clause\noccurs-clause\npicture-clause\nsign-clause\nsynchronized-clause\nusage-clause\nvalue-clause\ntype-clause\nThe clauses can be written in any order.\ntype-name-1 explicitly identifies a type declaration and is a COBOL user-defined word. See “User-defined\nwords” on page 12.\nThe level-number in format 4 always 01.\nA space, a comma, or a semicolon must separate clauses.\n198  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "Explain this COBOL concept", "input": "ISSUE ERROR (APPC)\nISSUE ERROR\nCONVID(  name )\nSTATE(  cvda)\nConditions: INVREQ, NOTALLOC, SIGNAL, TERMERR\n \nDescription\nISSUE ERROR allows an application program to inform a process in a connected APPC system that\nsome program-detected error has occurred. For example, a remote CICS application is notified by having\nEIBERR set, with EIBERRCD=X'0889'. The actions required to recover from the error are the responsibility\nof logic contained in both application programs. The application program can use this command to\nrespond negatively when the CONFIRM option has been specified on a SEND command executed by a\nprocess in a connected APPC system.\nOptions\nCONVID(name)\nidentifies the conversation to which the command relates. The 4-character name identifies either the\ntoken returned by a previously executed ALLOCATE command in EIBRSRCE in the EIB, or the token\nrepresenting the principal facility (returned by a previously executed ASSIGN command).\nFor compatibility with earlier releases, SESSION is accepted as a synonym for CONVID. New programs\nshould use CONVID.\nIf both CONVID and SESSION are omitted, the principal facility is assumed.\nSTATE(cvda)\ngets the state of the current conversation. The cvda values returned by CICS are:\n• ALLOCATED \n• CONFFREE \n• CONFRECEIVE \n• CONFSEND \n• FREE \n• PENDFREE \n• PENDRECEIVE \n• RECEIVE \n• ROLLBACK \n• SEND \n• SYNCFREE \n• SYNCRECEIVE \n• SYNCSEND \nConditions\n16 INVREQ\nRESP2 values:\n200\nA distributed program link server application specified the function-shipping session on the\nCONVID option.\n284  CICS TS for z/OS: API Reference", "output": "ISSUE ERROR (APPC)\nISSUE ERROR\nCONVID(  name )\nSTATE(  cvda)\nConditions: INVREQ, NOTALLOC, SIGNAL, TERMERR\n \nDescription\nISSUE ERROR allows an application program to inform a process in a connected APPC system that\nsome program-detected error has occurred. For example, a remote CICS application is notified by having\nEIBERR set, with EIBERRCD=X'0889'. The actions required to recover from the error are the responsibility\nof logic contained in both application programs. The application program can use this command to\nrespond negatively when the CONFIRM option has been specified on a SEND command executed by a\nprocess in a connected APPC system.\nOptions\nCONVID(name)\nidentifies the conversation to which the command relates. The 4-character name identifies either the\ntoken returned by a previously executed ALLOCATE command in EIBRSRCE in the EIB, or the token\nrepresenting the principal facility (returned by a previously executed ASSIGN command).\nFor compatibility with earlier releases, SESSION is accepted as a synonym for CONVID. New programs\nshould use CONVID.\nIf both CONVID and SESSION are omitted, the principal facility is assumed.\nSTATE(cvda)\ngets the state of the current conversation. The cvda values returned by CICS are:\n• ALLOCATED \n• CONFFREE \n• CONFRECEIVE \n• CONFSEND \n• FREE \n• PENDFREE \n• PENDRECEIVE \n• RECEIVE \n• ROLLBACK \n• SEND \n• SYNCFREE \n• SYNCRECEIVE \n• SYNCSEND \nConditions\n16 INVREQ\nRESP2 values:\n200\nA distributed program link server application specified the function-shipping session on the\nCONVID option.\n284  CICS TS for z/OS: API Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "CVDA\nValue\nSYSTEMOFF\n320\nSYSTEMON\n319\nTABLE\n847\nTABLEMGR\n1163\nTAKEOVER\n111\nTAPE1\n250\nTAPE2\n251\nTASK\n", "output": "CVDA\nValue\nSYSTEMOFF\n320\nSYSTEMON\n319\nTABLE\n847\nTABLEMGR\n1163\nTAKEOVER\n111\nTAPE1\n250\nTAPE2\n251\nTASK\n233\nTASKSUBPOOL\n1164\nTASKSTART\n611\nTCAM\n64\nTCAMSNA\n65\nTCEXITALL\n366\nTCEXITALLOFF\n369\nTCEXITNONE\n368\nTCEXITSYSTEM\n367\nTCLASS\n239\nTCPIP\n802\nTCPIPSERVICE\n1166\nTDQ\n767\nTDQUEUE\n767\nTEMPLATENAME\n1168\nTEMPORARY\n483\nTERM\n234\nTERMINAL\n213\nTERMINATE\n1077\nTEXTKYBD\n436\nTEXTPRINT\n438\nTHIRDINIT\n627\nTHREADSAFE\n1051\nTIME\n240\nTIMEOUT\n511\nTIMER\n1004\nTOEPR\n851\nTPOOL\n932\n732  CICS TS for z/OS: API Reference"}
{"instruction": "What are the compiler rules or directives for this?", "input": ">>DEFINE VAR AS 12\n. . .\n>>DEFINE VAR OFF\n. . .\n>>IF VAR IS DEFINED\n     compute x = x + 1 *> this code should NOT be included\n>>ELSE\n     compute x = x - 1 *> this code should be included\n>>END-IF\n. ", "output": ">>DEFINE VAR AS 12\n. . .\n>>DEFINE VAR OFF\n. . .\n>>IF VAR IS DEFINED\n     compute x = x + 1 *> this code should NOT be included\n>>ELSE\n     compute x = x - 1 *> this code should be included\n>>END-IF\n. . .\n>>DEFINE VAR AS 16\n. . .\n>>DEFINE VAR AS VAR - 2 OVERRIDE\n. . .\n>>IF VAR IS EQUAL TO 16\n     compute x = x + 1 *> this code should NOT be included\n>>ELSE\n     compute x = x - 1 *> this code should be included\n>>END-IF"}
{"instruction": "Explain this COBOL concept", "input": "RULES\nYou can use the RULES option to request information about your program from the compiler to improve\nthe program by flagging certain types of source code at compile time.\nRULES option syntax\nNORULES\nRULES\n(\n,\nENDPERIOD\nNOENDPERIOD\nEVENPACK\nNOEVENPACK\nLAXPERF\nNOLAXPERF\nSLACKBYTES\nNOSLACKBYTES\nOMITODOMIN\nNOOMITODOMIN\nUNREF\nNOUNREFALL\nNOUNREFSOURCE\nLAXREDEF\nNOLAXREDEF\n)\nDefault is: NORULES\nAbbreviations are:\n• ENDP = ENDPERIOD\n• EVENP = EVENPACK\n• LXPRF = LAXPERF\n• SLCKB = SLACKBYTES\n• OOM = OMITODOMIN\n• NOUNRA = NOUNREFALL\n• NOUNRS = NOUNREFSOURCE\n• LXRDF=LAXREDEF\nYou can specify the following suboptions for RULES:\nENDPERIOD | NOENDPERIOD\nThe default is ENDPERIOD. Specifying NOENDPERIOD causes the compiler to issue warning messages\nwhen the scope of a conditional statement is terminated by a period instead of an explicit scope\nterminator END-*.\nEVENPACK | NOEVENPACK\nThe default is EVENPACK. Specifying NOEVENPACK causes the compiler to issue warning messages for\nany USAGE PACKED-DECIMAL (COMP-3) data items that have an even number of digits because those\ndata items whose unused bits are not zero can lead to an unexpected program behavior.\nNotes:\nChapter 20. COBOL compiler and runtime options  419", "output": "RULES\nYou can use the RULES option to request information about your program from the compiler to improve\nthe program by flagging certain types of source code at compile time.\nRULES option syntax\nNORULES\nRULES\n(\n,\nENDPERIOD\nNOENDPERIOD\nEVENPACK\nNOEVENPACK\nLAXPERF\nNOLAXPERF\nSLACKBYTES\nNOSLACKBYTES\nOMITODOMIN\nNOOMITODOMIN\nUNREF\nNOUNREFALL\nNOUNREFSOURCE\nLAXREDEF\nNOLAXREDEF\n)\nDefault is: NORULES\nAbbreviations are:\n• ENDP = ENDPERIOD\n• EVENP = EVENPACK\n• LXPRF = LAXPERF\n• SLCKB = SLACKBYTES\n• OOM = OMITODOMIN\n• NOUNRA = NOUNREFALL\n• NOUNRS = NOUNREFSOURCE\n• LXRDF=LAXREDEF\nYou can specify the following suboptions for RULES:\nENDPERIOD | NOENDPERIOD\nThe default is ENDPERIOD. Specifying NOENDPERIOD causes the compiler to issue warning messages\nwhen the scope of a conditional statement is terminated by a period instead of an explicit scope\nterminator END-*.\nEVENPACK | NOEVENPACK\nThe default is EVENPACK. Specifying NOEVENPACK causes the compiler to issue warning messages for\nany USAGE PACKED-DECIMAL (COMP-3) data items that have an even number of digits because those\ndata items whose unused bits are not zero can lead to an unexpected program behavior.\nNotes:\nChapter 20. COBOL compiler and runtime options  419"}
{"instruction": "Explain this COBOL concept", "input": "1\nNAMELENGTH or VALUELENGTH is less than or equal to zero.\n4\nThe keyword parameter name has been truncated during a browse operation because the\nreceiving buffer is too small.\n5\nThe keyword parameter value has been truncated because the receiving buffer is too small.\nWEB RECEIVE (Server)\nReceive an HTTP request, or a non-HTTP message.\nWEB RECEIVE (CICS as an HTTP server using buffers)\nWEB\nRECEIVE\nINTO( data-area )\nSET( ptr-ref )\nLENGTH( data-area )\nMAXLENGTH(  data-value )\nNOTRUNCATE\nTYPE( cvda)\nSRVCONVERT\nNOSRVCONVERT\nSERVERCONV(  cvda)\nCHARACTERSET(  data-value )\nHOSTCODEPAGE(  data-value )\nBODYCHARSET(  data-area )\nMEDIATYPE(  data-value )\nWEB RECEIVE (CICS as an HTTP server using containers)\nWEB\nRECEIVE\nTOCONTAINER(  data-value )\nTOCHANNEL(  data-value )\nTYPE( cvda)\nCHARACTERSET(  data-value )\nBODYCHARSET(  data-area )\nMEDIATYPE(  data-value )\nConditions: CHANNELERR, CONTAINERERR, INVREQ, LENGERR, NOTFND\nThis command is threadsafe.\nDescription\nWEB RECEIVE receives the body of an HTTP request, or all the data for a non-HTTP message, into\nan application-supplied buffer, or set buffer. Alternatively, an HTTP request can be stored in a named\ncontainer. The headers for an HTTP request can be examined separately using the WEB HTTPHEADER\ncommands. The item received by the WEB RECEIVE command can be:\n• The body of an HTTP request that a Web client has made to CICS as an HTTP server. For guidance on\nthe correct use of the WEB RECEIVE command for this purpose, see Receiving the entity body of an\nHTTP request .\nChapter 2. CICS command summary  631", "output": "1\nNAMELENGTH or VALUELENGTH is less than or equal to zero.\n4\nThe keyword parameter name has been truncated during a browse operation because the\nreceiving buffer is too small.\n5\nThe keyword parameter value has been truncated because the receiving buffer is too small.\nWEB RECEIVE (Server)\nReceive an HTTP request, or a non-HTTP message.\nWEB RECEIVE (CICS as an HTTP server using buffers)\nWEB\nRECEIVE\nINTO( data-area )\nSET( ptr-ref )\nLENGTH( data-area )\nMAXLENGTH(  data-value )\nNOTRUNCATE\nTYPE( cvda)\nSRVCONVERT\nNOSRVCONVERT\nSERVERCONV(  cvda)\nCHARACTERSET(  data-value )\nHOSTCODEPAGE(  data-value )\nBODYCHARSET(  data-area )\nMEDIATYPE(  data-value )\nWEB RECEIVE (CICS as an HTTP server using containers)\nWEB\nRECEIVE\nTOCONTAINER(  data-value )\nTOCHANNEL(  data-value )\nTYPE( cvda)\nCHARACTERSET(  data-value )\nBODYCHARSET(  data-area )\nMEDIATYPE(  data-value )\nConditions: CHANNELERR, CONTAINERERR, INVREQ, LENGERR, NOTFND\nThis command is threadsafe.\nDescription\nWEB RECEIVE receives the body of an HTTP request, or all the data for a non-HTTP message, into\nan application-supplied buffer, or set buffer. Alternatively, an HTTP request can be stored in a named\ncontainer. The headers for an HTTP request can be examined separately using the WEB HTTPHEADER\ncommands. The item received by the WEB RECEIVE command can be:\n• The body of an HTTP request that a Web client has made to CICS as an HTTP server. For guidance on\nthe correct use of the WEB RECEIVE command for this purpose, see Receiving the entity body of an\nHTTP request .\nChapter 2. CICS command summary  631"}
{"instruction": "What is TEXT special register\nThe returned value in COBOL?", "input": "", "output": "TEXT special register\nThe returned value is nine-digit integer determined as follows:\n• The returned value is an integer that is the length of argument-1 in number of bytes.\n• If argument-1 is an alphanumeric, national or UTF-8 group item, the value returned is equal to the\nlength of argument-1 in bytes"}
{"instruction": "Summarize this COBOL documentation section", "input": "SIGN IS SEPARATE is not specified, the sign is one hexadecimal digit that overlays the first 4 bits of\nthe sign position (leading or trailing).\n#\n85 COBOL Standard\nThe COBOL language defined by the following standards:\n• ANSI INCITS 23-1985, Programming languages - COBOL, as amended by ANSI INCITS 23a-1989,\nProgramming Languages - COBOL - Intrinsic Function Module for COBOL and ANSI INCITS 23b-1993,\nProgramming Languages - Correction Amendment for COBOL\n• ISO 1989:1985, Programming languages - COBOL, as amended by ISO/IEC 1989/AMD1:1992,\nProgramming languages - COBOL: Intrinsic function module and ISO/IEC 1989/AMD2:1994,\nProgramming languages - Correction and clarification amendment for COBOL\n2002 COBOL Standard\nThe COBOL language defined by the following standard:\n• INCITS/ISO/IEC 1989-2002, Information technology - Programming languages - COBOL\n2014 COBOL Standard\nThe COBOL language defined by the following standard:\n• INCITS/ISO/IEC 1989:2014, Information technology - Programming languages, their environments\nand system software interfaces - Programming language COBOL\n856  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "SIGN IS SEPARATE is not specified, the sign is one hexadecimal digit that overlays the first 4 bits of\nthe sign position (leading or trailing).\n#\n85 COBOL Standard\nThe COBOL language defined by the following standards:\n• ANSI INCITS 23-1985, Programming languages - COBOL, as amended by ANSI INCITS 23a-1989,\nProgramming Languages - COBOL - Intrinsic Function Module for COBOL and ANSI INCITS 23b-1993,\nProgramming Languages - Correction Amendment for COBOL\n• ISO 1989:1985, Programming languages - COBOL, as amended by ISO/IEC 1989/AMD1:1992,\nProgramming languages - COBOL: Intrinsic function module and ISO/IEC 1989/AMD2:1994,\nProgramming languages - Correction and clarification amendment for COBOL\n2002 COBOL Standard\nThe COBOL language defined by the following standard:\n• INCITS/ISO/IEC 1989-2002, Information technology - Programming languages - COBOL\n2014 COBOL Standard\nThe COBOL language defined by the following standard:\n• INCITS/ISO/IEC 1989:2014, Information technology - Programming languages, their environments\nand system software interfaces - Programming language COBOL\n856  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What is It in COBOL?", "input": "", "output": "It is alternative to the existing NATLANGINUSE option"}
{"instruction": "What are the compiler rules or directives for this?", "input": "can only be specified for the first program in a sequence of programs\n(batch compilation). If you specify SQLIMS in a CBL or PROCESS statement for a program other than the", "output": "can only be specified for the first program in a sequence of programs\n(batch compilation). If you specify SQLIMS in a CBL or PROCESS statement for a program other than the"}
{"instruction": "What is length item with a length that in COBOL?", "input": "", "output": "length item with a length that is same as the current length of the dynamic-length\nelementary item"}
{"instruction": "Explain this COBOL concept", "input": "CVDA\nValue\nCORBA\n1101\nCORBASERVER\n1141\nCPLUSPLUS\n148\nCREATE\n67\nCREATESPI\n844\nCRITICAL\n11\nCSDAPI\n840\nCSDBATCH\n841\nCSIGN\n905\nCTERM\n906\nCTLGALL\n632\nCTLGMODIFY\n633\nCTLGNONE\n634\nCTRLABLE\n56\nCTX\n907\nCURRENT\n260\nCURRENTPGM\n870\nCUSERID\n909\nCUSTOM\n579\nDAEOPT\n684\nDATA\n508\nDATASET\n756\nDATASETFULL\n793\nDATASTREAM\n543\nDB2CONN\n1142\nDB2ENTRY\n1143\nDB2TRAN\n1184\nDEADLOCK\n794\nDEBUG\n1082\nDEC\n46\nDEFAULT\n198\nDEFAULTUSER\n1070\nDEFINITION\n990\nDEFRESP1\n497\nDEFRESP1OR2\n528\n712  CICS TS for z/OS: API Reference", "output": "CVDA\nValue\nCORBA\n1101\nCORBASERVER\n1141\nCPLUSPLUS\n148\nCREATE\n67\nCREATESPI\n844\nCRITICAL\n11\nCSDAPI\n840\nCSDBATCH\n841\nCSIGN\n905\nCTERM\n906\nCTLGALL\n632\nCTLGMODIFY\n633\nCTLGNONE\n634\nCTRLABLE\n56\nCTX\n907\nCURRENT\n260\nCURRENTPGM\n870\nCUSERID\n909\nCUSTOM\n579\nDAEOPT\n684\nDATA\n508\nDATASET\n756\nDATASETFULL\n793\nDATASTREAM\n543\nDB2CONN\n1142\nDB2ENTRY\n1143\nDB2TRAN\n1184\nDEADLOCK\n794\nDEBUG\n1082\nDEC\n46\nDEFAULT\n198\nDEFAULTUSER\n1070\nDEFINITION\n990\nDEFRESP1\n497\nDEFRESP1OR2\n528\n712  CICS TS for z/OS: API Reference"}
{"instruction": "What is it in COBOL?", "input": "", "output": "it is location to which the control is passed when the load\nmodule is invoked"}
{"instruction": "What are the compiler rules or directives for this?", "input": "recommendations are based on expected values for binary data", "output": "recommendations are based on expected values for binary data"}
{"instruction": "Summarize this COBOL documentation section", "input": "Chapter 5. Sections and paragraphs\nSections and paragraphs define a program. Sections and paragraphs are subdivided into sentences,\nstatements, and entries.\nSentences are subdivided into statements, and statements are subdivided into phrases. Entries are\nsubdivided into clauses.\nFor details, see:\n• “Sentences, statements, and entries” on page 53\n• “Statements” on page 54\n• “Phrases” on page 54\n• “Clauses” on page 54\nFor more information about sections, paragraphs, and statements, see “Procedures” on page 271.\nSentences, statements, and entries\nUnless the associated rules explicitly state otherwise, each required clause or statement must be written\nin the sequence shown in its format. If optional clauses or statements are used, they must be written in\nthe sequence shown in their formats. These rules are true even for clauses and statements treated as\ncomments.\nThe syntactical hierarchy follows this form:\n• IDENTIFICATION DIVISION\n– Paragraphs\n- Entries\n• Clauses\n• ENVIRONMENT DIVISION\n– Sections\n- Paragraphs\n• Entries\n– Clauses\n- Phrases\n• DATA DIVISION\n– Sections\n- Entries\n• Clauses\n– Phrases\n• PROCEDURE DIVISION\n– Sections\n- Paragraphs\n• Sentences\n– Statements\n- Phrases\n© Copyright IBM Corp. 1991, 2025\n53", "output": "Chapter 5. Sections and paragraphs\nSections and paragraphs define a program. Sections and paragraphs are subdivided into sentences,\nstatements, and entries.\nSentences are subdivided into statements, and statements are subdivided into phrases. Entries are\nsubdivided into clauses.\nFor details, see:\n• “Sentences, statements, and entries” on page 53\n• “Statements” on page 54\n• “Phrases” on page 54\n• “Clauses” on page 54\nFor more information about sections, paragraphs, and statements, see “Procedures” on page 271.\nSentences, statements, and entries\nUnless the associated rules explicitly state otherwise, each required clause or statement must be written\nin the sequence shown in its format. If optional clauses or statements are used, they must be written in\nthe sequence shown in their formats. These rules are true even for clauses and statements treated as\ncomments.\nThe syntactical hierarchy follows this form:\n• IDENTIFICATION DIVISION\n– Paragraphs\n- Entries\n• Clauses\n• ENVIRONMENT DIVISION\n– Sections\n- Paragraphs\n• Entries\n– Clauses\n- Phrases\n• DATA DIVISION\n– Sections\n- Entries\n• Clauses\n– Phrases\n• PROCEDURE DIVISION\n– Sections\n- Paragraphs\n• Sentences\n– Statements\n- Phrases\n© Copyright IBM Corp. 1991, 2025\n53"}
{"instruction": "What is 47 SELNERR\noccurs if there in COBOL?", "input": "", "output": "47 SELNERR\noccurs if there is error during destination selection"}
{"instruction": "What are the compiler rules or directives for this?", "input": "that influences the location of storage for WORKING-STORAGE data, I-O buffers, and", "output": "that influences the location of storage for WORKING-STORAGE data, I-O buffers, and"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Value CVDA\n553 TPS55M3\n554 TPS55M4\n555 TPS55M5\n556 NOCONV\n557 PENDSTSN\n558 PENDBEGIN\n559 APPLICATION", "output": "Value CVDA\n553 TPS55M3\n554 TPS55M4\n555 TPS55M5\n556 NOCONV\n557 PENDSTSN\n558 PENDBEGIN\n559 APPLICATION\n560 PENDDATA\n561 PENDSTART\n562 PENDRELEASE\n563 RELEASE\n564 PENDUNSOL\n565 PENDPASS\n566 SUMMUNLIKE\n570 ASYNCHRONOUS\n571 SYNCHRONOUS\n572 NONTRANS\n573 TRANS\n574 CONTEXT\n575 REGION\n576 ATTACH\n577 LINK\n578 WMQ\n579 CUSTOM\n580 TRANSTART\n581 CBER\n582 CBE\n583 CCE\n584 CFE\n585 WBE\n600 CONVERSE\n601 NOCONVERSE\n602 SYNCPOINT\n603 NOSYNCPOINT\n604 GMT\nChapter 4. CICS-value data areas used by all commands  753"}
{"instruction": "Explain this COBOL concept", "input": "• RECEIVE (APPC)\n• SEND (APPC)\n• WAIT CONVID (APPC)\nAsynchronous Services\n• FETCH ANY\n• FETCH CHILD\n• FREE CHILD\n• RUN TRANSID\nAuthentication\n• CHANGE PASSWORD\n• “CHANGE PHRASE” on page 66\n• SIGNOFF\n• SIGNON\n• SIGNON TOKEN\n• VERIFY PASSWORD\n• VERIFY PHRASE\n• VERIFY TOKEN\nBatch data interchange\n• ISSUE ABORT\n• ISSUE ADD\n• ISSUE END\n• ISSUE ERASE\n• ISSUE NOTE\n• ISSUE QUERY\n• ISSUE RECEIVE\n• ISSUE REPLACE\n• ISSUE SEND\n• ISSUE WAIT\nBMS\n• PURGE MESSAGE\n• RECEIVE MAP\n• RECEIVE MAP MAPPINGDEV\n• RECEIVE PARTN\n• ROUTE\n• SEND CONTROL\n16  CICS TS for z/OS: API Reference", "output": "• RECEIVE (APPC)\n• SEND (APPC)\n• WAIT CONVID (APPC)\nAsynchronous Services\n• FETCH ANY\n• FETCH CHILD\n• FREE CHILD\n• RUN TRANSID\nAuthentication\n• CHANGE PASSWORD\n• “CHANGE PHRASE” on page 66\n• SIGNOFF\n• SIGNON\n• SIGNON TOKEN\n• VERIFY PASSWORD\n• VERIFY PHRASE\n• VERIFY TOKEN\nBatch data interchange\n• ISSUE ABORT\n• ISSUE ADD\n• ISSUE END\n• ISSUE ERASE\n• ISSUE NOTE\n• ISSUE QUERY\n• ISSUE RECEIVE\n• ISSUE REPLACE\n• ISSUE SEND\n• ISSUE WAIT\nBMS\n• PURGE MESSAGE\n• RECEIVE MAP\n• RECEIVE MAP MAPPINGDEV\n• RECEIVE PARTN\n• ROUTE\n• SEND CONTROL\n16  CICS TS for z/OS: API Reference"}
{"instruction": "Summarize this COBOL documentation section", "input": "RETRIEVE SUBEVENT\nRetrieve the name of the next sub-event in a BTS composite event's sub-event queue.\nRETRIEVE SUBEVENT\nRETRIEVE\nSUBEVENT(  data-area )\nEVENT( data-value )\nEVENTTYPE(  cvda)\nConditions: END, EVENTERR, INVREQ\nDescription\nRETRIEVE SUBEVENT:\n• Retrieves the name of the next sub-event in a BTS composite event's sub-event queue.\n• Resets the retrieved sub-event's fire status to NOTFIRED.\n• Causes the composite event's fire status to be re-evaluated.\nThe firing of a composite event results from the firing of a set of one or more sub-events. The names of\nsub-events that have fired are placed on the composite event's sub-event queue, from which they can be\nretrieved, in sequence, by issuing successive RETRIEVE SUBEVENT commands.\nYou can use this command to discover which sub-event or sub-events caused a composite event to fire.\nNote:\n1. The presence of events on the sub-event queue does not imply that the composite event has fired.\n(Some sub-events in the set required to fire the composite event may still be in NOTFIRED state,\nand not yet on the sub-event queue.) To discover whether a composite event has fired, use the TEST\nEVENT command.\n2. Retrieval is destructive; when the name of a fired sub-event is retrieved, that sub-event cannot be\nretrieved again.\n3. Because it resets the fire status of the sub-event, RETRIEVE SUBEVENT causes the fire status of the\ncomposite event to be re-evaluated.\nOptions\nEVENT(data-value)\nspecifies the name (1–16 characters) of the composite event.\nEVENTTYPE(cvda)\nreturns the type of the sub-event. CVDA values are:\nACTIVITY\nActivity completion.\nINPUT\nInput\nTIMER\nTimer.\nSUBEVENT(data-area)\nreturns the 16-character name of the sub-event at the head of the sub-event queue.\nConditions\n83 END\nRESP2 values:\nChapter 2. CICS command summary  425", "output": "RETRIEVE SUBEVENT\nRetrieve the name of the next sub-event in a BTS composite event's sub-event queue.\nRETRIEVE SUBEVENT\nRETRIEVE\nSUBEVENT(  data-area )\nEVENT( data-value )\nEVENTTYPE(  cvda)\nConditions: END, EVENTERR, INVREQ\nDescription\nRETRIEVE SUBEVENT:\n• Retrieves the name of the next sub-event in a BTS composite event's sub-event queue.\n• Resets the retrieved sub-event's fire status to NOTFIRED.\n• Causes the composite event's fire status to be re-evaluated.\nThe firing of a composite event results from the firing of a set of one or more sub-events. The names of\nsub-events that have fired are placed on the composite event's sub-event queue, from which they can be\nretrieved, in sequence, by issuing successive RETRIEVE SUBEVENT commands.\nYou can use this command to discover which sub-event or sub-events caused a composite event to fire.\nNote:\n1. The presence of events on the sub-event queue does not imply that the composite event has fired.\n(Some sub-events in the set required to fire the composite event may still be in NOTFIRED state,\nand not yet on the sub-event queue.) To discover whether a composite event has fired, use the TEST\nEVENT command.\n2. Retrieval is destructive; when the name of a fired sub-event is retrieved, that sub-event cannot be\nretrieved again.\n3. Because it resets the fire status of the sub-event, RETRIEVE SUBEVENT causes the fire status of the\ncomposite event to be re-evaluated.\nOptions\nEVENT(data-value)\nspecifies the name (1–16 characters) of the composite event.\nEVENTTYPE(cvda)\nreturns the type of the sub-event. CVDA values are:\nACTIVITY\nActivity completion.\nINPUT\nInput\nTIMER\nTimer.\nSUBEVENT(data-area)\nreturns the 16-character name of the sub-event at the head of the sub-event queue.\nConditions\n83 END\nRESP2 values:\nChapter 2. CICS command summary  425"}
{"instruction": "Explain this COBOL concept", "input": "Example\nThe following example shows how to get a 1048576 byte area from CICS-key storage above the bar\n(regardless of the TASKDATAKEY option specified on the transaction resource definition):\nEXEC CICS GETMAIN64 SET(5)\n          FLENGTH(1048576)\n          CICSDATAKEY\nGETNEXT ACTIVITY\nBrowse the child activities of a BTS activity, or the descendant activities of a BTS process.\nGETNEXT ACTIVITY\nGETNEXT\nACTIVITY(  data-area )\nBROWSETOKEN(  data-value )\nACTIVITYID(  data-area )\nLEVEL( data-area )\nConditions: ACTIVITYERR, END, ILLOGIC, IOERR, TOKENERR\nDescription\nGETNEXT ACTIVITY returns either:\n• The name and identifier of the next child activity of a BTS activity (if the PROCESS and PROCESSTYPE\noptions were omitted from the STARTBROWSE ACTIVITY command)\n• The name and identifier of the next descendant activity of a BTS process (if the PROCESS and\nPROCESSTYPE options were specified on the STARTBROWSE ACTIVITY command).\nYou can use the INQUIRE ACTIVITYID command to query the identified activity.\nOptions\nACTIVITYID(data-area)\nreturns the 52-character identifier of the next activity.\nACTIVITY(data-area)\nreturns the 16-character name of the next activity.\nBROWSETOKEN(data-value)\nspecifies, as a fullword binary value, a browse token returned on a previous STARTBROWSE ACTIVITY\ncommand.\nLEVEL(data-area)\nreturns a fullword value indicating the depth in the activity-tree at which the next activity lies.\nOn a browse of the descendant activities of a process, a value of '0' indicates the root activity, '1' a\nchild of the root activity, '2' a grandchild of the root activity, and so on.\nOn a browse of the child activities of an activity, the value returned is always 0.\nConditions\n109 ACTIVITYERR\nRESP2 values:\n19\nThe request timed out. It may be that another task using this activity-record has been prevented\nfrom ending.\nChapter 2. CICS command summary  235", "output": "Example\nThe following example shows how to get a 1048576 byte area from CICS-key storage above the bar\n(regardless of the TASKDATAKEY option specified on the transaction resource definition):\nEXEC CICS GETMAIN64 SET(5)\n          FLENGTH(1048576)\n          CICSDATAKEY\nGETNEXT ACTIVITY\nBrowse the child activities of a BTS activity, or the descendant activities of a BTS process.\nGETNEXT ACTIVITY\nGETNEXT\nACTIVITY(  data-area )\nBROWSETOKEN(  data-value )\nACTIVITYID(  data-area )\nLEVEL( data-area )\nConditions: ACTIVITYERR, END, ILLOGIC, IOERR, TOKENERR\nDescription\nGETNEXT ACTIVITY returns either:\n• The name and identifier of the next child activity of a BTS activity (if the PROCESS and PROCESSTYPE\noptions were omitted from the STARTBROWSE ACTIVITY command)\n• The name and identifier of the next descendant activity of a BTS process (if the PROCESS and\nPROCESSTYPE options were specified on the STARTBROWSE ACTIVITY command).\nYou can use the INQUIRE ACTIVITYID command to query the identified activity.\nOptions\nACTIVITYID(data-area)\nreturns the 52-character identifier of the next activity.\nACTIVITY(data-area)\nreturns the 16-character name of the next activity.\nBROWSETOKEN(data-value)\nspecifies, as a fullword binary value, a browse token returned on a previous STARTBROWSE ACTIVITY\ncommand.\nLEVEL(data-area)\nreturns a fullword value indicating the depth in the activity-tree at which the next activity lies.\nOn a browse of the descendant activities of a process, a value of '0' indicates the root activity, '1' a\nchild of the root activity, '2' a grandchild of the root activity, and so on.\nOn a browse of the child activities of an activity, the value returned is always 0.\nConditions\n109 ACTIVITYERR\nRESP2 values:\n19\nThe request timed out. It may be that another task using this activity-record has been prevented\nfrom ending.\nChapter 2. CICS command summary  235"}
{"instruction": "Explain this COBOL concept", "input": "Chapter 45. DATE-TO-YYYYMMDD\nThe DATE-TO-YYYYMMDD function converts argument-1 from a date with a two-digit year (YYnnnn) to a\ndate with a four-digit year (YYYYnnnn). argument-2, when added to the year at the time of execution,\ndefines the ending year of a 100-year interval, or sliding century window, into which the year of\nargument-1 falls.\nThe function type is integer.\nFormat\nFUNCTION DATE-TO-YYYYMMDD\n(\nargument-1\nargument-2\n)\nargument-1\nMust be zero or a positive integer less than 991232.\nNote: The COBOL run time does not verify that the value is a valid date.\nargument-2\nMust be an integer. If argument-2 is omitted, the function is evaluated assuming the value 50 was\nspecified.\nThe sum of the year at the time of execution and the value of argument-2 must be less than 10,000 and\ngreater than 1,699.\nSee the following examples with returned values from the DATE-TO-YYYYMMDD function:\nCurrent year\nargument-1 value\nargument-2 value\nReturned value\n2002\n851003\n120\n20851003\n2002\n851003\n-20\n18851003\n2002\n851003\n 10\n19851003\n1994\n981002\n-10\n18981002\n© Copyright IBM Corp. 1991, 2025\n555", "output": "Chapter 45. DATE-TO-YYYYMMDD\nThe DATE-TO-YYYYMMDD function converts argument-1 from a date with a two-digit year (YYnnnn) to a\ndate with a four-digit year (YYYYnnnn). argument-2, when added to the year at the time of execution,\ndefines the ending year of a 100-year interval, or sliding century window, into which the year of\nargument-1 falls.\nThe function type is integer.\nFormat\nFUNCTION DATE-TO-YYYYMMDD\n(\nargument-1\nargument-2\n)\nargument-1\nMust be zero or a positive integer less than 991232.\nNote: The COBOL run time does not verify that the value is a valid date.\nargument-2\nMust be an integer. If argument-2 is omitted, the function is evaluated assuming the value 50 was\nspecified.\nThe sum of the year at the time of execution and the value of argument-2 must be less than 10,000 and\ngreater than 1,699.\nSee the following examples with returned values from the DATE-TO-YYYYMMDD function:\nCurrent year\nargument-1 value\nargument-2 value\nReturned value\n2002\n851003\n120\n20851003\n2002\n851003\n-20\n18851003\n2002\n851003\n 10\n19851003\n1994\n981002\n-10\n18981002\n© Copyright IBM Corp. 1991, 2025\n555"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 86. Reserved words (continued)\nWord\nReserved\nStandard only\nPotential\nreserved words\nENTER\nX\n \n", "output": "Table 86. Reserved words (continued)\nWord\nReserved\nStandard only\nPotential\nreserved words\nENTER\nX\n \n \nENTRY\nX\n \n \nENVIRONMENT\nX\n \n \nEO\n \n \nX\nEOP\nX\n \n \nEQUAL\nX\n \n \nERROR\nX\n \n \nESI\n \nX\n \nEVALUATE\nX\n \n \nEVERY\nX\n \n \nEXCEPTION\nX\n \n \nEXCEPTION-OBJECT\n \n \nX\nEXEC\nX\n \n \nEXECUTE\nX\n \n \nEXIT\nX\n \n \nEXTEND\nX\n \n \nEXTERNAL\nX\n \n \nFACTORY\nX\n \n \nFALSE\nX\n \n \nFD\nX\n \n \nFILE\nX\n \n \nFILE-CONTROL\nX\n \n \nFILLER\nX\n \n \nFINAL\n \nX\n \nFIRST\nX\n \n \nFLOAT-EXTENDED\n \n \nX\nFLOAT-LONG\n \n \nX\nFLOAT-SHORT\n \n \nX\nFOOTING\nX\n \n \nFOR\nX\n \n \nFORMAT\n \n \nX\nFREE\nX \n \nFROM\nX\n \n \nFUNCTION\nX\n \n \nAppendix E. Reserved words  777"}
{"instruction": "Summarize this COBOL documentation section", "input": "Data sets used by the compiler under z/OS\nThe following table lists the function, device requirements, and allowable device classes for each data set\nthat the compiler uses.\nTable 36. Compiler data sets\nType\nddname\nFunction\nRequired?\nDevice\nrequirement\ns\nAllowable\ndevice\nclasses\nCan be in\nz/OS\nUNIX file\nsystem?\nInput\nSYSIN1\nReading source\nprogram\nYes\nCard reader;\nintermediate\nstorage\nAny\nYes\nSYSOPTF\nReading compiler\noptions\nIf OPTFILE is in effect\nCard reader;\nintermediate\nstorage;\ndirect\naccess\nAny\nYes\nSYSLIB or\nother copy\nlibraries1\nReading user source\nlibraries (PDSs or\nPDSEs)\nIf program has COPY or\nBASIS statements\nDirect\naccess\nSYSDA\nNo\nUtility2\nSYSUT1,\nSYSUT2,\nSYSUT3,\nSYSUT4,\nSYSUT6\nWork data set used\nby compiler during\ncompilation\nYes\nDirect\naccess\nSYSALLDA\nNo\nSYSUT5\nWork data set used\nby compiler during\ncompilation\nIf program has COPY,\nREPLACE, or BASIS\nstatements\nDirect\naccess\nSYSALLDA\nNo\nSYSUT7\nWork data set used\nby compiler to\ncreate listing\nYes\nDirect\naccess\nSYSALLDA\nNo\nSYSUT8,\nSYSUT9,\nSYSUT10,\nSYSUT11,\nSYSUT12,\nSYSUT13,\nSYSUT14,\nSYSUT15\nWork data set used\nby compiler during\ncompilation\nYes\nDirect\naccess\nSYSALLDA\nNo\nChapter 15. Compiling under z/OS  281", "output": "Data sets used by the compiler under z/OS\nThe following table lists the function, device requirements, and allowable device classes for each data set\nthat the compiler uses.\nTable 36. Compiler data sets\nType\nddname\nFunction\nRequired?\nDevice\nrequirement\ns\nAllowable\ndevice\nclasses\nCan be in\nz/OS\nUNIX file\nsystem?\nInput\nSYSIN1\nReading source\nprogram\nYes\nCard reader;\nintermediate\nstorage\nAny\nYes\nSYSOPTF\nReading compiler\noptions\nIf OPTFILE is in effect\nCard reader;\nintermediate\nstorage;\ndirect\naccess\nAny\nYes\nSYSLIB or\nother copy\nlibraries1\nReading user source\nlibraries (PDSs or\nPDSEs)\nIf program has COPY or\nBASIS statements\nDirect\naccess\nSYSDA\nNo\nUtility2\nSYSUT1,\nSYSUT2,\nSYSUT3,\nSYSUT4,\nSYSUT6\nWork data set used\nby compiler during\ncompilation\nYes\nDirect\naccess\nSYSALLDA\nNo\nSYSUT5\nWork data set used\nby compiler during\ncompilation\nIf program has COPY,\nREPLACE, or BASIS\nstatements\nDirect\naccess\nSYSALLDA\nNo\nSYSUT7\nWork data set used\nby compiler to\ncreate listing\nYes\nDirect\naccess\nSYSALLDA\nNo\nSYSUT8,\nSYSUT9,\nSYSUT10,\nSYSUT11,\nSYSUT12,\nSYSUT13,\nSYSUT14,\nSYSUT15\nWork data set used\nby compiler during\ncompilation\nYes\nDirect\naccess\nSYSALLDA\nNo\nChapter 15. Compiling under z/OS  281"}
{"instruction": "What is the real number in COBOL?", "input": "", "output": "the real number is product of the fixed-point part\n(the first numeral) and a value obtained by raising the implicit floating-point base to a power denoted\nby the exponent (the second numeral)"}
{"instruction": "What is 3 in COBOL?", "input": "", "output": "3 is object reference, certain rules apply"}
{"instruction": "What is The returned value in COBOL?", "input": "", "output": "The returned value is character string consisting of bytes that correspond to the bit pattern indicated by\nthe sequence of \"0\" and \"1\" characters in argument-1"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Chapter 104. UPPER-CASE\nThe UPPER-CASE function returns a character string that contains the charact", "output": "Chapter 104. UPPER-CASE\nThe UPPER-CASE function returns a character string that contains the characters in the argument with\neach lowercase letter replaced by the corresponding uppercase letter.\nThe function type depends on the type of the argument, as follows:\nArgument type\nFunction type\nAlphabetic\nAlphanumeric\nAlphanumeric\nAlphanumeric\nNational\nNational\nUTF-8\nUTF-8\nFormat\nFUNCTION UPPER-CASE\n(\nargument-1\n)\nargument-1\nMust be of class alphabetic, alphanumeric, national, or UTF-8 and must be at least one character\nposition in length.\nNote: If argument-1 is of the alphanumeric class, it must not contain UTF-8 encoded data.\nThe same character string as argument-1 is returned, except that each lowercase letter is replaced by the\ncorresponding uppercase letter.\nIf argument-1 is alphabetic or alphanumeric, the lowercase letters 'a' through 'z' are replaced by the\ncorresponding uppercase letters 'A' through 'Z', where the range of 'a' through 'z' and the range of 'A'\nthrough 'Z' are as shown in “EBCDIC collating sequence” on page 761, regardless of the code page in\neffect.\nIf argument-1 is national or UTF-8, each lowercase letter is replaced by its corresponding uppercase\nletter based on the specification given in the Unicode database UnicodeData.txt, available from the\nUnicode Consortium at www.unicode.org/.\nIf argument-1 is not of class UTF-8, the character string returned has the same length as argument-1.\nFor UTF-8 arguments, the returned string may have a different byte length than the byte length of\nargument-1.\n© Copyright IBM Corp. 1991, 2025\n673"}
{"instruction": "What is unless there in COBOL?", "input": "", "output": "unless there is dependency on programs that must be linked in step 3, in which case linking for these programs\nmust be delayed until step 3 as well"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "SEND PARTNSET\nAssociates the partition set specified by the PARTNSET option with the application pro", "output": "SEND PARTNSET\nAssociates the partition set specified by the PARTNSET option with the application program.\nSEND PARTNSET\nSEND PARTNSET\n(\nname\n)\nConditions: INVPARTNSET, INVREQ\nDescription\nSEND PARTNSET associates the partition set specified by the PARTNSET option with the application\nprogram. If the partition set name is omitted, the terminal is reset to the base (unpartitioned) state.\nThis command is available on standard and full BMS only. For further information about BMS, see Basic\nmapping support.\nNote: A SEND PARTNSET command must not be followed immediately by a RECEIVE command. The two\ncommands must be separated by a SEND MAP, SEND TEXT, or SEND CONTROL command, so that the\npartition set is sent to the terminal.\nConditions\nThe following conditions may occur together. If both occur, only the first one is passed to the application\nprogram.\n64 INVPARTNSET\noccurs if the partition set named in the SEND PARTNSET command is not a valid partition set (for\nexample, it may be a mapset).\nDefault action: terminate the task abnormally.\n16 INVREQ\nRESP2 values:\n200\nCommand not allowed for a distributed program link server program.\nalso occurs (RESP2 not set) in the following situation:\n• A SEND PARTNSET command is issued while a logical message is active.\nDefault action: terminate the task abnormally.\nSEND TEXT\nSend data without mapping. The keywords are separated into those supported by standard and full BMS.\nFor further information about BMS, see Basic mapping support.\nSEND TEXT\nSEND TEXT\nChapter 2. CICS command summary  479"}
{"instruction": "Explain this COBOL concept", "input": "Table 89. 2002/2014 COBOL Standard features implemented in COBOL 3 or later versions that will not affect\nexisting programs (continued)\nFeatures\nNotes\nWITH RESET phrase\nThis was added to the NEXT PAGE phrase of the NEXT\nGROUP clause to reset PAGE-COUNTER back to 1.\nNote: REPORT WRITER features such as CODE\nclause, COLUMN clause, control data name, CONTROL\nHEADING, PAGE FOOTING, PAGE LIMIT, SUM clause,\nand report description entries are supported via the\noptional Report Writer Precompiler.\n806  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "Table 89. 2002/2014 COBOL Standard features implemented in COBOL 3 or later versions that will not affect\nexisting programs (continued)\nFeatures\nNotes\nWITH RESET phrase\nThis was added to the NEXT PAGE phrase of the NEXT\nGROUP clause to reset PAGE-COUNTER back to 1.\nNote: REPORT WRITER features such as CODE\nclause, COLUMN clause, control data name, CONTROL\nHEADING, PAGE FOOTING, PAGE LIMIT, SUM clause,\nand report description entries are supported via the\noptional Report Writer Precompiler.\n806  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What are the compiler rules or directives for this?", "input": "must be of the same category. For this rule, an arithmetic", "output": "must be of the same category. For this rule, an arithmetic"}
{"instruction": "Summarize this COBOL documentation section", "input": "$125.53CR\nClient Information: \n  Name:\n    Smith               \n    John                \n  Address:\n    12345 First Avenue  \n    New York            \n    New York            \n    10203     \nSuccessful JSON Parse\nTransactions:\n  Record 1:\n    TXID:        00107\n    Description: prod a ver 1                                      \n    Item ID:     ab/1424 24\n    Price:        $12.34\n    Comment:     express shipping    \n  Record 2:\n    TXID:        01904\n    Description: prod g ver 2                                      \n    Item ID:     gb/0515 33\n    Price:       $833.22\n    Comment:     digital download        \n   \nRelated references  \nJSON PARSE statement (Enterprise COBOL for z/OS Language Reference)    \nChapter 36. Processing JSON input   643", "output": "$125.53CR\nClient Information: \n  Name:\n    Smith               \n    John                \n  Address:\n    12345 First Avenue  \n    New York            \n    New York            \n    10203     \nSuccessful JSON Parse\nTransactions:\n  Record 1:\n    TXID:        00107\n    Description: prod a ver 1                                      \n    Item ID:     ab/1424 24\n    Price:        $12.34\n    Comment:     express shipping    \n  Record 2:\n    TXID:        01904\n    Description: prod g ver 2                                      \n    Item ID:     gb/0515 33\n    Price:       $833.22\n    Comment:     digital download        \n   \nRelated references  \nJSON PARSE statement (Enterprise COBOL for z/OS Language Reference)    \nChapter 36. Processing JSON input   643"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 82. Compiler limits (continued)\nLanguage element\nCompiler limit\nReserved word table entries\n15", "output": "Table 82. Compiler limits (continued)\nLanguage element\nCompiler limit\nReserved word table entries\n1536\nCOPY REPLACING . . . BY . . . (items per COPY\nstatement)\nNo limit\nNumber of COPY libraries\nNo limit\nBlock size of COPY library\n32,760 bytes\nIDENTIFICATION DIVISION\nENVIRONMENT DIVISION\nConfiguration section\nSpecial-names paragraph\nmnemonic-name IS\n18\nUPSI-n . . . (switches)\n0-7\nalphabet-name IS . . .\nNo limit\nLiteral THRU . . . or ALSO . . .\n256\nInput-Output section\nFile-control paragraph\nSELECT file-name . . .\nA maximum of 65,535 file names can be assigned\nexternal names\nASSIGN system-name . . .\nNo limit\nALTERNATE RECORD KEY data-name . . .\n253\nRECORD KEY length\nNo limit(Note 3)\nRESERVE integer (buffers)\n255(Note 4)\nI-O-control paragraph\nRERUN ON system-name . . .\n32,767\nRERUN integer RECORDS\n16,777,215\nSAME RECORD AREA\n255\nSAME RECORD AREA FOR file-name . . .\n255\nSAME SORT/MERGE AREA\nNo limit(Note 2)\nMULTIPLE FILE file-name . . .\nNo limit(Note 2)\nDATA DIVISION\n77 data item size\nWith LP(32): 999,999,999 bytes\nWith LP(64): 2,147,483,646 bytes\n01-49 data item size\nWith LP(32): 999,999,999 bytes\nWith LP(64): 2,147,483,646 bytes\nTotal 01 + 77 (data items)\nNo limit\n88 condition-names . . .\nNo limit\n88 level VALUE clause . . .\nNo limit\n740  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What is the source code page in COBOL?", "input": "", "output": "the source code page is one that was in effect for the CODEPAGE compiler option when\nthe source code was compiled"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "132\nMETHOD option not allowed for second or subsequent chunks.\n133\nMEDIATYPE option not allowed for ", "output": "132\nMETHOD option not allowed for second or subsequent chunks.\n133\nMEDIATYPE option not allowed for second or subsequent chunks.\n135\nPATH option not allowed for second or subsequent chunks.\n136\nMETHOD option required.\n142\nAUTHENTICATE is invalid. The CVDA is not NONE or BASICAUTH.\n144\nOne or more of the Web command parameters is invalid.\n145\nChannel was not specified, and there is no current channel.\n147\nInternal conversion error.\n150\nConversion requested, but the data to be sent is in a DATATYPE BIT container.\n17 IOERR\nRESP2 values are:\n42\nSocket error.\n22 LENGERR\nRESP2 values are:\n5\nThe PATHLENGTH option value was not greater than zero.\n8\nThe QUERYSTRLEN option value was not greater than zero.\n50\nThe FROMLENGTH option value was not greater than zero.\n139\nUSERNAMELEN is negative or is greater than 256.\n140\nPASSWORDLEN is negative or is greater than 256.\n70 NOTAUTH\nRESP2 values are:\n100\nPath barred by security exit.\n110\nXWBAUTH error. The XWBAUTH global user exit has issued a UERCERR return code because the\nXWBAUTH exit is required but cannot return a valid response.\nThis error code is issued when the following are true: BASICAUTH is specified; USERNAME,\nPASSWORD, or both are omitted; XWBAUTH is inactive or returns a response of UERCERR.\n13 NOTFND\nRESP2 values are:\n61\nThe URIMAP object specified was not found.\n19 NOTOPEN\nRESP2 values are:\nChapter 2. CICS command summary  661"}
{"instruction": "Summarize this COBOL documentation section", "input": "Default action: terminate the task abnormally.\n12 FILENOTFOUND\nRESP2 values:\n1\nA file name referred to in the FILE option is not defined to CICS.\nDefault action: terminate the task abnormally.\n21 ILLOGIC\nRESP2 values: (VSAM)\n110\nA VSAM error occurs that is not in one of the other CICS response categories.\nSee EIBRCODE in the EXEC interface block; for details, see EIB fields.\nDefault action: terminate the task abnormally.\n16 INVREQ\nRESP2 values:\n20\nAdd operations are not allowed according to the resource definition.\n23\nWhen writing records containing embedded keys, the key in the record area (FROM option) and the\nkey in RIDFLD do not match.\n26\nThe KEYLENGTH option is specified, and the specified length does not equal the length defined for\nthe data set that this file refers to.\n38\nA WRITE with the MASSINSERT option is issued against a BDAM file.\n40\nA BDAM key conversion error occurred.\n44\nThe WRITE command does not conform to the format of WRITE for a user-maintained or coupling\nfacility data table (for example, MASSINSERT or RBA is specified).\n51\nA WRITE command specifying the RBA keyword was issued against a KSDS file that is being\naccessed in RLS mode. RLS mode does not support relative byte address access to KSDS files.\n55\nNOSUSPEND is not allowed because the file is not a VSAM file that is accessed in RLS mode.\n56\nAn attempt to update a recoverable coupling facility data table has failed because the current unit\nof work has already updated 1024 recoverable coupling facility data tables. You cannot update\nmore than 1024 recoverable coupling facility data tables within a unit of work\n57\nWRITE operations are not allowed because the associated VSAM data set has an AVAILABILITY\nstate of RREPL, which disallows such operations except those from replication programs.\n59\nXRBA was specified, but the data set is not an extended addressing ESDS.\nDefault action: terminate the task abnormally.\n17 IOERR\nRESP2 values:\n672  CICS TS for z/OS: API Reference", "output": "Default action: terminate the task abnormally.\n12 FILENOTFOUND\nRESP2 values:\n1\nA file name referred to in the FILE option is not defined to CICS.\nDefault action: terminate the task abnormally.\n21 ILLOGIC\nRESP2 values: (VSAM)\n110\nA VSAM error occurs that is not in one of the other CICS response categories.\nSee EIBRCODE in the EXEC interface block; for details, see EIB fields.\nDefault action: terminate the task abnormally.\n16 INVREQ\nRESP2 values:\n20\nAdd operations are not allowed according to the resource definition.\n23\nWhen writing records containing embedded keys, the key in the record area (FROM option) and the\nkey in RIDFLD do not match.\n26\nThe KEYLENGTH option is specified, and the specified length does not equal the length defined for\nthe data set that this file refers to.\n38\nA WRITE with the MASSINSERT option is issued against a BDAM file.\n40\nA BDAM key conversion error occurred.\n44\nThe WRITE command does not conform to the format of WRITE for a user-maintained or coupling\nfacility data table (for example, MASSINSERT or RBA is specified).\n51\nA WRITE command specifying the RBA keyword was issued against a KSDS file that is being\naccessed in RLS mode. RLS mode does not support relative byte address access to KSDS files.\n55\nNOSUSPEND is not allowed because the file is not a VSAM file that is accessed in RLS mode.\n56\nAn attempt to update a recoverable coupling facility data table has failed because the current unit\nof work has already updated 1024 recoverable coupling facility data tables. You cannot update\nmore than 1024 recoverable coupling facility data tables within a unit of work\n57\nWRITE operations are not allowed because the associated VSAM data set has an AVAILABILITY\nstate of RREPL, which disallows such operations except those from replication programs.\n59\nXRBA was specified, but the data set is not an extended addressing ESDS.\nDefault action: terminate the task abnormally.\n17 IOERR\nRESP2 values:\n672  CICS TS for z/OS: API Reference"}
{"instruction": "Explain this COBOL concept", "input": "SET(ptr-ref)\nspecifies the pointer reference that is to be set to the address location of the data read from the data\nset.\nIf you specify the SET option, the parameter must be a data area. On completion of the retrieval\noperation, the data area is set to the length of the data.\nIf DATALOCATION(ANY) is associated with the application program, the address of the data can be\nabove or below the 16MB line.\nIf DATALOCATION(BELOW) is associated with the application program, and the data resides above the\n16MB line, the data is copied below the 16MB line, and the address of this copy is returned.\nIf TASKDATAKEY(USER) is specified for the running task, and storage protection is active, the data\nreturned is in a user-key. If TASKDATAKEY(CICS) is specified and storage protection is active, the data\nreturned is in a CICS-key.\nIf you have specified SET, you must also specify LENGTH.\nConditions\n46 DSSTAT\noccurs when the destination status changes in one of the following ways:\n• The data stream is abended.\n• The data stream is suspended.\nDefault action: terminate the task abnormally.\n06 EOC\noccurs if the request/response unit (RU) is received with the end-of-chain (EOC) indicator set. Field\nEIBEOC also contains this indicator.\nDefault action: ignore the condition.\n05 EODS\noccurs when the end of the data set is encountered.\nDefault action: terminate the task abnormally.\n16 INVREQ\nRESP2 values:\n200\nA distributed program link server application specified the function-shipping session (its principal\nfacility) on the CONVID option.\nDefault action: terminate the task abnormally.\n22 LENGERR\noccurs if the length of the retrieved data is greater than the value specified by the LENGTH option.\nDefault action: terminate the task abnormally.\n49 UNEXPIN\noccurs when some unexpected or unrecognized information is received from the outboard controller.\nDefault action: terminate the task abnormally.\nISSUE REPLACE\nUpdate a record in a data set.\nChapter 2. CICS command summary  293", "output": "SET(ptr-ref)\nspecifies the pointer reference that is to be set to the address location of the data read from the data\nset.\nIf you specify the SET option, the parameter must be a data area. On completion of the retrieval\noperation, the data area is set to the length of the data.\nIf DATALOCATION(ANY) is associated with the application program, the address of the data can be\nabove or below the 16MB line.\nIf DATALOCATION(BELOW) is associated with the application program, and the data resides above the\n16MB line, the data is copied below the 16MB line, and the address of this copy is returned.\nIf TASKDATAKEY(USER) is specified for the running task, and storage protection is active, the data\nreturned is in a user-key. If TASKDATAKEY(CICS) is specified and storage protection is active, the data\nreturned is in a CICS-key.\nIf you have specified SET, you must also specify LENGTH.\nConditions\n46 DSSTAT\noccurs when the destination status changes in one of the following ways:\n• The data stream is abended.\n• The data stream is suspended.\nDefault action: terminate the task abnormally.\n06 EOC\noccurs if the request/response unit (RU) is received with the end-of-chain (EOC) indicator set. Field\nEIBEOC also contains this indicator.\nDefault action: ignore the condition.\n05 EODS\noccurs when the end of the data set is encountered.\nDefault action: terminate the task abnormally.\n16 INVREQ\nRESP2 values:\n200\nA distributed program link server application specified the function-shipping session (its principal\nfacility) on the CONVID option.\nDefault action: terminate the task abnormally.\n22 LENGERR\noccurs if the length of the retrieved data is greater than the value specified by the LENGTH option.\nDefault action: terminate the task abnormally.\n49 UNEXPIN\noccurs when some unexpected or unrecognized information is received from the outboard controller.\nDefault action: terminate the task abnormally.\nISSUE REPLACE\nUpdate a record in a data set.\nChapter 2. CICS command summary  293"}
{"instruction": "Summarize this COBOL documentation section", "input": "• Relate xml-schema-names to ddnames or environment variable names identifying files containing XML\nschemas\nSOURCE-COMPUTER paragraph\nThe SOURCE-COMPUTER paragraph describes the computer on which the source text is to be compiled.\nFormat\nSOURCE-COMPUTER.\ncomputer-name\nWITH\nDEBUGGING MODE\n.\ncomputer-name\nA system-name. For example:\nIBM-system\nWITH DEBUGGING MODE\nActivates a compile-time switch for debugging lines written in the source text.\nA debugging line is a statement that is compiled only when the compile-time switch is activated.\nDebugging lines allow you, for example, to check the value of a data-name at certain points in a\nprocedure.\nTo specify a debugging line in your program, code a D in column 7 (indicator area). You can include\nsuccessive debugging lines, but each must have a D in column 7, and you cannot break character\nstrings across lines.\nAll your debugging lines must be written so that the program is syntactically correct, whether the\ndebugging lines are compiled or treated as comments.\nThe presence or absence of the DEBUGGING MODE clause is logically determined after all COPY and\nREPLACE statements have been processed.\nYou can code debugging lines in the ENVIRONMENT DIVISION (after the OBJECT-COMPUTER\nparagraph), and in the data and procedure divisions.\nIf a debugging line contains only spaces in Area A and in Area B, the debugging line is treated the\nsame as a blank line.\nAll of the SOURCE-COMPUTER paragraph is syntax checked, but only the WITH DEBUGGING MODE clause\nhas an effect on the execution of the program.\nThe SOURCE-COMPUTER paragraph cannot be specified in a function prototype definition.\n124  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "• Relate xml-schema-names to ddnames or environment variable names identifying files containing XML\nschemas\nSOURCE-COMPUTER paragraph\nThe SOURCE-COMPUTER paragraph describes the computer on which the source text is to be compiled.\nFormat\nSOURCE-COMPUTER.\ncomputer-name\nWITH\nDEBUGGING MODE\n.\ncomputer-name\nA system-name. For example:\nIBM-system\nWITH DEBUGGING MODE\nActivates a compile-time switch for debugging lines written in the source text.\nA debugging line is a statement that is compiled only when the compile-time switch is activated.\nDebugging lines allow you, for example, to check the value of a data-name at certain points in a\nprocedure.\nTo specify a debugging line in your program, code a D in column 7 (indicator area). You can include\nsuccessive debugging lines, but each must have a D in column 7, and you cannot break character\nstrings across lines.\nAll your debugging lines must be written so that the program is syntactically correct, whether the\ndebugging lines are compiled or treated as comments.\nThe presence or absence of the DEBUGGING MODE clause is logically determined after all COPY and\nREPLACE statements have been processed.\nYou can code debugging lines in the ENVIRONMENT DIVISION (after the OBJECT-COMPUTER\nparagraph), and in the data and procedure divisions.\nIf a debugging line contains only spaces in Area A and in Area B, the debugging line is treated the\nsame as a blank line.\nAll of the SOURCE-COMPUTER paragraph is syntax checked, but only the WITH DEBUGGING MODE clause\nhas an effect on the execution of the program.\nThe SOURCE-COMPUTER paragraph cannot be specified in a function prototype definition.\n124  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What is The comparison operation that determines whether an item will be suppressed in COBOL?", "input": "", "output": "The comparison operation that determines whether an item will be suppressed is relation condition\nas shown in the table of Comparisons involving figurative constants"}
{"instruction": "Summarize this COBOL documentation section", "input": "also occurs (RESP2 not set) in any of the following situations:\n• The command is not valid for the APPC conversation type in use.\n• The command is issued against a CPI-Communications conversation.\nDefault action: terminate the task abnormally.\n61 NOTALLOC\noccurs if the specified CONVID value does not relate to a conversation owned by the application.\nDefault action: terminate the task abnormally.\n24 SIGNAL\noccurs when an inbound SIGNAL data-flow control command is received from a partner transaction.\nEIBSIG is always set when an inbound signal is received.\nDefault action: ignore the condition.\n81 TERMERR\noccurs for a session-related error. Any action on that conversation other than a FREE command\ncauses an ATCV abend.\nA CANCEL TASK request by a user node error program (NEP) may cause this condition if the task has\nan outstanding terminal control request active when the node abnormal condition program handles\nthe session error.\nDefault action: terminate the task abnormally with abend code ATNI.\nISSUE LOAD\nSpecify the name of a program on 3650 interpreter logical unit.\nISSUE LOAD\nISSUE LOAD\nPROGRAM(  name )\nCONVERSE\nConditions: NONVAL, NOTALLOC, NOSTART, TERMERR\n \nDescription\nISSUE LOAD specifies the name of the 3650 application program that is to be loaded.\nOptions\nCONVERSE\nspecifies that the 3650 application program is able to communicate with the host processor. If this\noption is not specified, the 3650 application program cannot communicate with the host processor.\nPROGRAM(name)\nspecifies the name (1–8 characters) of the 3650 application program that is to be loaded.\nConditions\n09 NONVAL\noccurs if the 3650 application program name is not valid.\nDefault action: terminate the task abnormally.\nChapter 2. CICS command summary  285", "output": "also occurs (RESP2 not set) in any of the following situations:\n• The command is not valid for the APPC conversation type in use.\n• The command is issued against a CPI-Communications conversation.\nDefault action: terminate the task abnormally.\n61 NOTALLOC\noccurs if the specified CONVID value does not relate to a conversation owned by the application.\nDefault action: terminate the task abnormally.\n24 SIGNAL\noccurs when an inbound SIGNAL data-flow control command is received from a partner transaction.\nEIBSIG is always set when an inbound signal is received.\nDefault action: ignore the condition.\n81 TERMERR\noccurs for a session-related error. Any action on that conversation other than a FREE command\ncauses an ATCV abend.\nA CANCEL TASK request by a user node error program (NEP) may cause this condition if the task has\nan outstanding terminal control request active when the node abnormal condition program handles\nthe session error.\nDefault action: terminate the task abnormally with abend code ATNI.\nISSUE LOAD\nSpecify the name of a program on 3650 interpreter logical unit.\nISSUE LOAD\nISSUE LOAD\nPROGRAM(  name )\nCONVERSE\nConditions: NONVAL, NOTALLOC, NOSTART, TERMERR\n \nDescription\nISSUE LOAD specifies the name of the 3650 application program that is to be loaded.\nOptions\nCONVERSE\nspecifies that the 3650 application program is able to communicate with the host processor. If this\noption is not specified, the 3650 application program cannot communicate with the host processor.\nPROGRAM(name)\nspecifies the name (1–8 characters) of the 3650 application program that is to be loaded.\nConditions\n09 NONVAL\noccurs if the 3650 application program name is not valid.\nDefault action: terminate the task abnormally.\nChapter 2. CICS command summary  285"}
{"instruction": "Explain this COBOL concept", "input": "Chapter 41. CONTENT-OF\nThe CONTENT-OF intrinsic function returns the content of the argument.\nThe type of this function depends on the type of argument-1 as follows:\nTable 63. CONTENT-OF function type depending on the argument-1 types\nargument-1 type\nFunction type\nAlphabetic\nAlphanumeric\nAlphanumeric\nAlphanumeric\nNational\nNational\nUTF-8\nUTF-8\nInteger\nInteger\nNumeric\nNumeric\nFormat\nFUNCTION CONTENT-OF\n(\nargument-1\n)\nargument-1\nMust be class alphabetic, alphanumeric, national, UTF-8, integer, or numeric.\nThe returned value is the content of argument-1. The size of the returned value is the size of\nargument-1.\nThe CONTENT-OF intrinsic function is useful when you want to pass an argument to a user-defined\nfunction that is effectively BY CONTENT. To do this, the formal parameter of the user-defined function\nmust be passed BY REFERENCE on the USING phrase in the function definition, and then on the\nfunction invocation, the argument would be specified using the CONTENT-OF intrinsic function as a\nwrapper around the argument. For an example, see Passing arguments BY CONTENT to user-defined\nfunctions in the Enterprise COBOL Programming Guide.\n© Copyright IBM Corp. 1991, 2025\n547", "output": "Chapter 41. CONTENT-OF\nThe CONTENT-OF intrinsic function returns the content of the argument.\nThe type of this function depends on the type of argument-1 as follows:\nTable 63. CONTENT-OF function type depending on the argument-1 types\nargument-1 type\nFunction type\nAlphabetic\nAlphanumeric\nAlphanumeric\nAlphanumeric\nNational\nNational\nUTF-8\nUTF-8\nInteger\nInteger\nNumeric\nNumeric\nFormat\nFUNCTION CONTENT-OF\n(\nargument-1\n)\nargument-1\nMust be class alphabetic, alphanumeric, national, UTF-8, integer, or numeric.\nThe returned value is the content of argument-1. The size of the returned value is the size of\nargument-1.\nThe CONTENT-OF intrinsic function is useful when you want to pass an argument to a user-defined\nfunction that is effectively BY CONTENT. To do this, the formal parameter of the user-defined function\nmust be passed BY REFERENCE on the USING phrase in the function definition, and then on the\nfunction invocation, the argument would be specified using the CONTENT-OF intrinsic function as a\nwrapper around the argument. For an example, see Passing arguments BY CONTENT to user-defined\nfunctions in the Enterprise COBOL Programming Guide.\n© Copyright IBM Corp. 1991, 2025\n547"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 6. Internal representation of numeric items (continued)\nNumeric type\nPICTURE and USAGE and\nopt", "output": "Table 6. Internal representation of numeric items (continued)\nNumeric type\nPICTURE and USAGE and\noptional SIGN clause\nValue\nInternal representation\nInternal\ndecimal\nPIC S9999 PACKED-\nDECIMAL\nPIC S9999 COMP-3 \n+ 1234\n   01 23 4C\n- 1234\n   01 23 4D\nPIC 9999  PACKED-\nDECIMAL\nPIC 9999  COMP-3 \n  1234\n   01 23 4F\nInternal\nfloating point\nCOMP-1\n+ 1234\n43 4D 20 00\n- 1234\nC3 4D 20 00\nCOMP-2\n+ 1234\n43 4D 20 00 00 00 00 00\n- 1234\nC3 4D 20 00 00 00 00 00\nExternal\nfloating point\nPIC +9(2).9(2)E+99\nDISPLAY\n+ 12.34E+02\n4E F1 F2 4B F3 F4 C5 4E F0\nF2\n- 12.34E+02\n60 F1 F2 4B F3 F4 C5 4E F0\nF2\nPIC +9(2).9(2)E+99\nNATIONAL\n+ 12.34E+02\n00 2B 00 31 00 32 00 2E 00 \n33\n00 34 00 45 00 2B 00 30 00 \n32\n- 12.34E+02\n00 2D 00 31 00 32 00 2E 00 \n33\n00 34 00 45 00 2B 00 30 00 \n32\n1. The example demonstrates that COMP-5 data items can contain values of magnitude up to the capacity\nof the native binary representation (2, 4, or 8 bytes), rather than being limited to the value implied by the\nnumber of 9s in the PICTURE clause.\nData format conversions\nWhen the code in your program involves the interaction of items that have different data formats,\nthe compiler converts those items either temporarily, for comparisons and arithmetic operations, or\npermanently, for assignment to the receiver in a MOVE or COMPUTE statement.\nA conversion is actually a move of a value from one data item to another. The compiler performs any\nconversions that are required during the execution of arithmetic or comparisons by using the same rules\nthat are used for MOVE and COMPUTE statements.\nWhen possible, the compiler performs a move to preserve numeric value instead of a direct digit-for-digit\nmove.\nChapter 3. Working with numbers and arithmetic  57"}
{"instruction": "Explain this COBOL concept", "input": "Table 6. Internal representation of numeric items (continued)\nNumeric type\nPICTURE and USAGE and\noptional SIGN clause\nValue\nInternal representation\nInternal\ndecimal\nPIC S9999 PACKED-\nDECIMAL\nPIC S9999 COMP-3 \n+ 1234\n   01 23 4C\n- 1234\n   01 23 4D\nPIC 9999  PACKED-\nDECIMAL\nPIC 9999  COMP-3 \n  1234\n   01 23 4F\nInternal\nfloating point\nCOMP-1\n+ 1234\n43 4D 20 00\n- 1234\nC3 4D 20 00\nCOMP-2\n+ 1234\n43 4D 20 00 00 00 00 00\n- 1234\nC3 4D 20 00 00 00 00 00\nExternal\nfloating point\nPIC +9(2).9(2)E+99\nDISPLAY\n+ 12.34E+02\n4E F1 F2 4B F3 F4 C5 4E F0\nF2\n- 12.34E+02\n60 F1 F2 4B F3 F4 C5 4E F0\nF2\nPIC +9(2).9(2)E+99\nNATIONAL\n+ 12.34E+02\n00 2B 00 31 00 32 00 2E 00 \n33\n00 34 00 45 00 2B 00 30 00 \n32\n- 12.34E+02\n00 2D 00 31 00 32 00 2E 00 \n33\n00 34 00 45 00 2B 00 30 00 \n32\n1. The example demonstrates that COMP-5 data items can contain values of magnitude up to the capacity\nof the native binary representation (2, 4, or 8 bytes), rather than being limited to the value implied by the\nnumber of 9s in the PICTURE clause.\nData format conversions\nWhen the code in your program involves the interaction of items that have different data formats,\nthe compiler converts those items either temporarily, for comparisons and arithmetic operations, or\npermanently, for assignment to the receiver in a MOVE or COMPUTE statement.\nA conversion is actually a move of a value from one data item to another. The compiler performs any\nconversions that are required during the execution of arithmetic or comparisons by using the same rules\nthat are used for MOVE and COMPUTE statements.\nWhen possible, the compiler performs a move to preserve numeric value instead of a direct digit-for-digit\nmove.\nChapter 3. Working with numbers and arithmetic  57", "output": "Table 6. Internal representation of numeric items (continued)\nNumeric type\nPICTURE and USAGE and\noptional SIGN clause\nValue\nInternal representation\nInternal\ndecimal\nPIC S9999 PACKED-\nDECIMAL\nPIC S9999 COMP-3 \n+ 1234\n   01 23 4C\n- 1234\n   01 23 4D\nPIC 9999  PACKED-\nDECIMAL\nPIC 9999  COMP-3 \n  1234\n   01 23 4F\nInternal\nfloating point\nCOMP-1\n+ 1234\n43 4D 20 00\n- 1234\nC3 4D 20 00\nCOMP-2\n+ 1234\n43 4D 20 00 00 00 00 00\n- 1234\nC3 4D 20 00 00 00 00 00\nExternal\nfloating point\nPIC +9(2).9(2)E+99\nDISPLAY\n+ 12.34E+02\n4E F1 F2 4B F3 F4 C5 4E F0\nF2\n- 12.34E+02\n60 F1 F2 4B F3 F4 C5 4E F0\nF2\nPIC +9(2).9(2)E+99\nNATIONAL\n+ 12.34E+02\n00 2B 00 31 00 32 00 2E 00 \n33\n00 34 00 45 00 2B 00 30 00 \n32\n- 12.34E+02\n00 2D 00 31 00 32 00 2E 00 \n33\n00 34 00 45 00 2B 00 30 00 \n32\n1. The example demonstrates that COMP-5 data items can contain values of magnitude up to the capacity\nof the native binary representation (2, 4, or 8 bytes), rather than being limited to the value implied by the\nnumber of 9s in the PICTURE clause.\nData format conversions\nWhen the code in your program involves the interaction of items that have different data formats,\nthe compiler converts those items either temporarily, for comparisons and arithmetic operations, or\npermanently, for assignment to the receiver in a MOVE or COMPUTE statement.\nA conversion is actually a move of a value from one data item to another. The compiler performs any\nconversions that are required during the execution of arithmetic or comparisons by using the same rules\nthat are used for MOVE and COMPUTE statements.\nWhen possible, the compiler performs a move to preserve numeric value instead of a direct digit-for-digit\nmove.\nChapter 3. Working with numbers and arithmetic  57"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "OBJECT-COMPUTER paragraph\nThe OBJECT-COMPUTER paragraph specifies the system for which the object pr", "output": "OBJECT-COMPUTER paragraph\nThe OBJECT-COMPUTER paragraph specifies the system for which the object program is designated.\nFormat\nOBJECT-COMPUTER.\ncomputer-name\nMEMORY\nSIZE\ninteger\nWORDS\nCHARACTERS\nMODULES\nentry 1\n.\nentry 1\nPROGRAM\nCOLLATING\nSEQUENCE\nIS\nalphabet-name\nSEGMENT-LIMIT\nIS\npriority-number\ncomputer-name\nA system-name. For example:\nIBM-system\nMEMORY SIZE integer\ninteger specifies the amount of main storage needed to run the object program, in words, characters\nor modules. The MEMORY SIZE clause is syntax checked but has no effect on the execution of the\nprogram.\nPROGRAM COLLATING SEQUENCE IS alphabet-name\nThe collating sequence used in this program is the collating sequence associated with the specified\nalphabet-name.\nThe collating sequence pertains to this program and to any programs that this program might contain.\nPROGRAM COLLATING SEQUENCE determines the truth value of the following alphanumeric\ncomparisons:\n• Those explicitly specified in relation conditions\n• Those explicitly specified in condition-name conditions\nThe PROGRAM COLLATING SEQUENCE clause also applies to any merge or sort keys described\nwith usage DISPLAY, unless the COLLATING SEQUENCE phrase is specified in the MERGE or SORT\nstatement.\nThe PROGRAM COLLATING SEQUENCE clause does not apply to DBCS data items or data items of\nusage NATIONAL.\nIf the PROGRAM COLLATING SEQUENCE clause is omitted, the EBCDIC collating sequence is used.\n(See Appendix C, “EBCDIC and ASCII collating sequences,” on page 761.)\nChapter 22. Configuration section  125"}
{"instruction": "What is the syntax for this COBOL construct?", "input": "diagram shows the format for a PROCEDURE DIVISION header in a factory", "output": "diagram shows the format for a PROCEDURE DIVISION header in a factory"}
{"instruction": "Explain this COBOL concept", "input": "Alternatively, you can code:\nRELEASE A FROM X.\nThe following table compares the RELEASE and RELEASE FROM statements.\nRELEASE\nRELEASE FROM\nMOVE SORT-EXT-RECORD\n  TO SORT-RECORD\nPERFORM RELEASE-SORT-RECORD\n. . .\nRELEASE-SORT-RECORD.\n  RELEASE SORT-RECORD\nPERFORM RELEASE-SORT-RECORD\n. . .\nRELEASE-SORT-RECORD.\n  RELEASE SORT-RECORD\n    FROM SORT-EXT-RECORD\nRelated references   \n“Restrictions on input and output procedures” on page 241  \nRELEASE statement (Enterprise COBOL for z/OS Language Reference)\nDescribing the output from sorting or merging\nIf the output from sorting or merging is a file, describe the file by following the procedure below.\n1. Write a SELECT clause in the FILE-CONTROL paragraph of the ENVIRONMENT DIVISION to name the\noutput file. For example:\nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.\nFILE-CONTROL.\n    SELECT Output-File ASSIGN TO OutFile.\nOutput-File is the name of the file in your program. Use this name to refer to the file.\n2. Describe the output file (or files when merging) in an FD entry in the FILE SECTION of the DATA\nDIVISION. For example:\nDATA DIVISION.\nFILE SECTION.\nFD  Output-File \n    LABEL RECORDS ARE STANDARD\n    BLOCK CONTAINS 0 CHARACTERS \n    RECORDING MODE IS F \n    RECORD CONTAINS 100 CHARACTERS.\n01  Output-Record   PIC X(100).\nRelated tasks   \n“Coding the output procedure” on page 239  \n“Requesting the sort or merge” on page 242 \nRelated references   \n“FILE SECTION entries” on page 12 \nCoding the output procedure\nTo select, edit, or otherwise change sorted records before writing them from the sort work file into\nanother file, use the OUTPUT PROCEDURE phrase of the format 1 SORT statement.\nEach output procedure must be contained in either a section or a paragraph. An output procedure must\ninclude both of the following elements:\n• At least one RETURN statement or one RETURN statement with the INTO phrase\nChapter 13. Sorting and merging files  239", "output": "Alternatively, you can code:\nRELEASE A FROM X.\nThe following table compares the RELEASE and RELEASE FROM statements.\nRELEASE\nRELEASE FROM\nMOVE SORT-EXT-RECORD\n  TO SORT-RECORD\nPERFORM RELEASE-SORT-RECORD\n. . .\nRELEASE-SORT-RECORD.\n  RELEASE SORT-RECORD\nPERFORM RELEASE-SORT-RECORD\n. . .\nRELEASE-SORT-RECORD.\n  RELEASE SORT-RECORD\n    FROM SORT-EXT-RECORD\nRelated references   \n“Restrictions on input and output procedures” on page 241  \nRELEASE statement (Enterprise COBOL for z/OS Language Reference)\nDescribing the output from sorting or merging\nIf the output from sorting or merging is a file, describe the file by following the procedure below.\n1. Write a SELECT clause in the FILE-CONTROL paragraph of the ENVIRONMENT DIVISION to name the\noutput file. For example:\nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.\nFILE-CONTROL.\n    SELECT Output-File ASSIGN TO OutFile.\nOutput-File is the name of the file in your program. Use this name to refer to the file.\n2. Describe the output file (or files when merging) in an FD entry in the FILE SECTION of the DATA\nDIVISION. For example:\nDATA DIVISION.\nFILE SECTION.\nFD  Output-File \n    LABEL RECORDS ARE STANDARD\n    BLOCK CONTAINS 0 CHARACTERS \n    RECORDING MODE IS F \n    RECORD CONTAINS 100 CHARACTERS.\n01  Output-Record   PIC X(100).\nRelated tasks   \n“Coding the output procedure” on page 239  \n“Requesting the sort or merge” on page 242 \nRelated references   \n“FILE SECTION entries” on page 12 \nCoding the output procedure\nTo select, edit, or otherwise change sorted records before writing them from the sort work file into\nanother file, use the OUTPUT PROCEDURE phrase of the format 1 SORT statement.\nEach output procedure must be contained in either a section or a paragraph. An output procedure must\ninclude both of the following elements:\n• At least one RETURN statement or one RETURN statement with the INTO phrase\nChapter 13. Sorting and merging files  239"}
{"instruction": "Summarize this COBOL documentation section", "input": "Table-handling\n• SEARCH\nDelimited scope statements\nIn general, a DELIMITED SCOPE statement uses an explicit scope terminator to turn a conditional\nstatement into an imperative statement.\nThe resulting imperative statement can then be nested. Explicit scope terminators can also be used to\nterminate the scope of an imperative statement. Explicit scope terminators are provided for all COBOL\nstatements that can have conditional phrases.\nUnless explicitly specified otherwise, a delimited scope statement can be specified wherever an\nimperative statement is allowed by the rules of the language.\nExplicit scope terminators\nAn explicit scope terminator marks the end of certain PROCEDURE DIVISION statements.\nA conditional statement that is delimited by its explicit scope terminator is considered an imperative\nstatement and must follow the rules for imperative statements.\nThese are the explicit scope terminators:\n• END-ADD\n• END-CALL\n• END-COMPUTE\n• END-DELETE\n• END-DIVIDE\n• END-EVALUATE\n• END-IF\n• END-INVOKE\n• END-JSON\n• END-MULTIPLY\n• END-PERFORM\n• END-READ\n• END-RETURN\n• END-REWRITE\n• END-SEARCH\n• END-START\n• END-STRING\n• END-SUBTRACT\n• END-UNSTRING\n• END-WRITE\n• END-XML\nImplicit scope terminators\nAt the end of any sentence, an implicit scope terminator is a separator period that terminates the scope of\nall previous statements not yet terminated.\nAn unterminated conditional statement cannot be contained by another statement.\n300  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "Table-handling\n• SEARCH\nDelimited scope statements\nIn general, a DELIMITED SCOPE statement uses an explicit scope terminator to turn a conditional\nstatement into an imperative statement.\nThe resulting imperative statement can then be nested. Explicit scope terminators can also be used to\nterminate the scope of an imperative statement. Explicit scope terminators are provided for all COBOL\nstatements that can have conditional phrases.\nUnless explicitly specified otherwise, a delimited scope statement can be specified wherever an\nimperative statement is allowed by the rules of the language.\nExplicit scope terminators\nAn explicit scope terminator marks the end of certain PROCEDURE DIVISION statements.\nA conditional statement that is delimited by its explicit scope terminator is considered an imperative\nstatement and must follow the rules for imperative statements.\nThese are the explicit scope terminators:\n• END-ADD\n• END-CALL\n• END-COMPUTE\n• END-DELETE\n• END-DIVIDE\n• END-EVALUATE\n• END-IF\n• END-INVOKE\n• END-JSON\n• END-MULTIPLY\n• END-PERFORM\n• END-READ\n• END-RETURN\n• END-REWRITE\n• END-SEARCH\n• END-START\n• END-STRING\n• END-SUBTRACT\n• END-UNSTRING\n• END-WRITE\n• END-XML\nImplicit scope terminators\nAt the end of any sentence, an implicit scope terminator is a separator period that terminates the scope of\nall previous statements not yet terminated.\nAn unterminated conditional statement cannot be contained by another statement.\n300  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "Summarize this COBOL documentation section", "input": "SEND CONTROL\nSend device controls to a terminal without map or text data. The keywords are separated into those\nsupported by minimum, standard, and full BMS.\nFor further information about BMS, see Basic mapping support.\nSEND CONTROL\nSEND CONTROL\nSEND CONTROL Minimum BMS\nCURSOR\n(\ndata-value\n)\nFORMFEED\nERASE\nDEFAULT\nALTERNATE\nERASEAUP\nPRINT\nFREEKB\nALARM\nFRSET\nSEND CONTROL Standard BMS\nMSR( data-value )\nOUTPARTN(  name )\nACTPARTN(  name )\nLDC( name )\nSEND CONTROL Full BMS\nACCUM\nTERMINAL\nSET( ptr-ref )\nPAGING\nTERMINAL\nWAIT\nLAST\nREQID( name )\nHONEOM\nL40\nL64\nL80\nConditions: IGREQCD, IGREQID, INVLDC, INVPARTN, INVREQ, RETPAGE, TSIOERR, WRBRK\nDescription\nSEND CONTROL sends device controls to a terminal.\nWhen using the SEND CONTROL command with any of the ALARM, FREEKB, FRSET, HONEOM, L40, L64,\nL80, or PRINT options, see DFHMDI options, CTRL for a description of the option priority.\nChapter 2. CICS command summary  463", "output": "SEND CONTROL\nSend device controls to a terminal without map or text data. The keywords are separated into those\nsupported by minimum, standard, and full BMS.\nFor further information about BMS, see Basic mapping support.\nSEND CONTROL\nSEND CONTROL\nSEND CONTROL Minimum BMS\nCURSOR\n(\ndata-value\n)\nFORMFEED\nERASE\nDEFAULT\nALTERNATE\nERASEAUP\nPRINT\nFREEKB\nALARM\nFRSET\nSEND CONTROL Standard BMS\nMSR( data-value )\nOUTPARTN(  name )\nACTPARTN(  name )\nLDC( name )\nSEND CONTROL Full BMS\nACCUM\nTERMINAL\nSET( ptr-ref )\nPAGING\nTERMINAL\nWAIT\nLAST\nREQID( name )\nHONEOM\nL40\nL64\nL80\nConditions: IGREQCD, IGREQID, INVLDC, INVPARTN, INVREQ, RETPAGE, TSIOERR, WRBRK\nDescription\nSEND CONTROL sends device controls to a terminal.\nWhen using the SEND CONTROL command with any of the ALARM, FREEKB, FRSET, HONEOM, L40, L64,\nL80, or PRINT options, see DFHMDI options, CTRL for a description of the option priority.\nChapter 2. CICS command summary  463"}
{"instruction": "Explain this COBOL concept", "input": "SIGN IS SEPARATE is not specified, the sign is one hexadecimal digit that overlays the first 4 bits of\nthe sign position (leading or trailing).\n#\n85 COBOL Standard\nThe COBOL language defined by the following standards:\n• ANSI INCITS 23-1985, Programming languages - COBOL, as amended by ANSI INCITS 23a-1989,\nProgramming Languages - COBOL - Intrinsic Function Module for COBOL and ANSI INCITS 23b-1993,\nProgramming Languages - Correction Amendment for COBOL\n• ISO 1989:1985, Programming languages - COBOL, as amended by ISO/IEC 1989/AMD1:1992,\nProgramming languages - COBOL: Intrinsic function module and ISO/IEC 1989/AMD2:1994,\nProgramming languages - Correction and clarification amendment for COBOL\n2002 COBOL Standard\nThe COBOL language defined by the following standard:\n• INCITS/ISO/IEC 1989-2002, Information technology - Programming languages - COBOL\n2014 COBOL Standard\nThe COBOL language defined by the following standard:\n• INCITS/ISO/IEC 1989:2014, Information technology - Programming languages, their environments\nand system software interfaces - Programming language COBOL\n856  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "SIGN IS SEPARATE is not specified, the sign is one hexadecimal digit that overlays the first 4 bits of\nthe sign position (leading or trailing).\n#\n85 COBOL Standard\nThe COBOL language defined by the following standards:\n• ANSI INCITS 23-1985, Programming languages - COBOL, as amended by ANSI INCITS 23a-1989,\nProgramming Languages - COBOL - Intrinsic Function Module for COBOL and ANSI INCITS 23b-1993,\nProgramming Languages - Correction Amendment for COBOL\n• ISO 1989:1985, Programming languages - COBOL, as amended by ISO/IEC 1989/AMD1:1992,\nProgramming languages - COBOL: Intrinsic function module and ISO/IEC 1989/AMD2:1994,\nProgramming languages - Correction and clarification amendment for COBOL\n2002 COBOL Standard\nThe COBOL language defined by the following standard:\n• INCITS/ISO/IEC 1989-2002, Information technology - Programming languages - COBOL\n2014 COBOL Standard\nThe COBOL language defined by the following standard:\n• INCITS/ISO/IEC 1989:2014, Information technology - Programming languages, their environments\nand system software interfaces - Programming language COBOL\n856  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 137. SYSADATA token record (continued)\nField\nSize\nDescription\n0221\nDEBUG-SUB-2\n0222\nDEBUG-SUB-", "output": "Table 137. SYSADATA token record (continued)\nField\nSize\nDescription\n0221\nDEBUG-SUB-2\n0222\nDEBUG-SUB-3\n0223\nDELIMITED\n0224\nDELIMITER\n0225\nDOWN\n0226\nNUMERIC-EDITED\n0227\nXML-EVENT\n0228\nEND-OF-PAGE\nEOP\n0229\nEQUAL\n0230\nERROR\n0231\nXML-NTEXT\n0232\nEXCEPTION\n0233\nEXTEND\n0234\nFIRST\n0235\nFROM\n0236\nGIVING\n0237\nGREATER\n0238\nI-O\n0239\nIN\n0240\nINITIAL\nAppendix G. COBOL SYSADATA file contents  933"}
{"instruction": "What is Dynamic access in COBOL?", "input": "", "output": "Dynamic access is mixed\nsequential-random access in the same program"}
{"instruction": "Explain this COBOL concept", "input": "Value CVDA\n98 SPECIAL\n100 NOTTABLE\n101 CICSTABLE\n102 USERTABLE\n103 REMTABLE\n110 PRIMARY\n111 TAKEOVER\n121 IRC\n122 INDIRECT\n123 XM\n124 APPC\n125 LU61\n126 PENDING\n127 NOTPENDING\n143 XOK\n144 XNOTDONE\n147 JAVA\n148 CPLUSPLUS\n149 C\n150 ASSEMBLER\n151 COBOL\n152 PLI\n152 PL1\n153 RPG\n154 PROGRAM\n155 MAP\n155 MAPSET\n156 PARTITIONSET\n157 PROFILE\n158 ANY\n158 LOC31\n159 BELOW\n159 LOC24\n160 PURGEABLE\n161 NOTPURGEABLE\n742  CICS TS for z/OS: API Reference", "output": "Value CVDA\n98 SPECIAL\n100 NOTTABLE\n101 CICSTABLE\n102 USERTABLE\n103 REMTABLE\n110 PRIMARY\n111 TAKEOVER\n121 IRC\n122 INDIRECT\n123 XM\n124 APPC\n125 LU61\n126 PENDING\n127 NOTPENDING\n143 XOK\n144 XNOTDONE\n147 JAVA\n148 CPLUSPLUS\n149 C\n150 ASSEMBLER\n151 COBOL\n152 PLI\n152 PL1\n153 RPG\n154 PROGRAM\n155 MAP\n155 MAPSET\n156 PARTITIONSET\n157 PROFILE\n158 ANY\n158 LOC31\n159 BELOW\n159 LOC24\n160 PURGEABLE\n161 NOTPURGEABLE\n742  CICS TS for z/OS: API Reference"}
{"instruction": "What is This error can occur only when the target of the PUT in COBOL?", "input": "", "output": "This error can occur only when the target of the PUT is existing\ncontainer.\n338  CICS TS for z/OS: API Reference\n\n\n5\nThere was an internal error in the code page conversion of a container"}
{"instruction": "What is The only process a program can check in COBOL?", "input": "", "output": "The only process a program can check is one that it acquires in the current unit of work - see Acquiring\nprocesses and activities"}
{"instruction": "Summarize this COBOL documentation section", "input": "REMOVE SUBEVENT\nREMOVE\nSUBEVENT(  data-value )\nEVENT( data-value )\nConditions: EVENTERR, INVREQ\nDescription\nREMOVE SUBEVENT removes a sub-event from a named BTS composite event.\nThis call does not delete the removed event. Nor does it reset the event's fire status. Note that, after\nthis call, the removed event—because it is no longer a sub-event—will cause the current activity to be\nreattached if it fires.\nRemoving a sub-event causes the composite's predicate to be re-evaluated.\nOptions\nEVENT(data-value)\nspecifies the name (1–16 characters) of the composite event.\nSUBEVENT(data-value)\nspecifies the name (1–16 characters) of the event which is to be removed from the named composite\nevent.\nConditions\n111 EVENTERR\nRESP2 values:\n4\nThe event specified on the EVENT option is not recognized by BTS.\n5\nThe sub-event specified on the SUBEVENT option is not recognized by BTS.\n16 INVREQ\nRESP2 values:\n1\nThe command was issued outside the scope of an activity.\n2\nThe event specified on the EVENT option is not a composite event.\n3\nThe event specified on the SUBEVENT option is not a sub-event of the composite event specified\non the EVENT option.\nREQUEST ENCRYPTPTKT\nRequest an external security manager to generate an encrypted PassTicket.\nREQUEST ENCRYPTPTKT\nREQUEST\nENCRYPTPTKT(  ptr_ref )\nFLENGTH(  data-area )\nENCRYPTKEY(  data-area )\nESMAPPNAME(  data-value )\nESMREASON(  data-area )\nESMRESP( data-area )\nConditions: NOTAUTH, INVREQ\nThis command is threadsafe.\n408  CICS TS for z/OS: API Reference", "output": "REMOVE SUBEVENT\nREMOVE\nSUBEVENT(  data-value )\nEVENT( data-value )\nConditions: EVENTERR, INVREQ\nDescription\nREMOVE SUBEVENT removes a sub-event from a named BTS composite event.\nThis call does not delete the removed event. Nor does it reset the event's fire status. Note that, after\nthis call, the removed event—because it is no longer a sub-event—will cause the current activity to be\nreattached if it fires.\nRemoving a sub-event causes the composite's predicate to be re-evaluated.\nOptions\nEVENT(data-value)\nspecifies the name (1–16 characters) of the composite event.\nSUBEVENT(data-value)\nspecifies the name (1–16 characters) of the event which is to be removed from the named composite\nevent.\nConditions\n111 EVENTERR\nRESP2 values:\n4\nThe event specified on the EVENT option is not recognized by BTS.\n5\nThe sub-event specified on the SUBEVENT option is not recognized by BTS.\n16 INVREQ\nRESP2 values:\n1\nThe command was issued outside the scope of an activity.\n2\nThe event specified on the EVENT option is not a composite event.\n3\nThe event specified on the SUBEVENT option is not a sub-event of the composite event specified\non the EVENT option.\nREQUEST ENCRYPTPTKT\nRequest an external security manager to generate an encrypted PassTicket.\nREQUEST ENCRYPTPTKT\nREQUEST\nENCRYPTPTKT(  ptr_ref )\nFLENGTH(  data-area )\nENCRYPTKEY(  data-area )\nESMAPPNAME(  data-value )\nESMREASON(  data-area )\nESMRESP( data-area )\nConditions: NOTAUTH, INVREQ\nThis command is threadsafe.\n408  CICS TS for z/OS: API Reference"}
{"instruction": "Explain this COBOL concept", "input": "RECEIVE (3270 logical)\nRECEIVE\nINTO( data-area )\nSET( ptr-ref )\nLENGTH( data-area )\nFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nASIS\nBUFFER\nNOTRUNCATE\nConditions: INVREQ, LENGERR, TERMERR\nDescription\n  RECEIVE receives data from a terminal.\nIf data is to be received, you must specify either the INTO or the SET option. If a RECEIVE is issued purely\nto detect an attention identifier (AID) (and BUFFER has not been specified), you can omit both the INTO\nand SET options.\nRECEIVE (3600 pipeline)\nReceive initial input data from a 3600 pipeline logical unit. Subsequent RECEIVEs for further input data\nare not allowed. \nRECEIVE (3600 pipeline)\nRECEIVE\nINTO( data-area )\nSET( ptr-ref )\nLENGTH( data-area )\nFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nNOTRUNCATE\nConditions: INVREQ, LENGERR, NOTALLOC\n \nDescription\nIf data is to be received, you must specify either the INTO or the SET option. If a RECEIVE is issued purely\nto detect an attention identifier (AID) you can omit both the INTO and SET options.\nRECEIVE (3600-3601)\nReceive data from a 3600 (3601) logical unit. \n386  CICS TS for z/OS: API Reference", "output": "RECEIVE (3270 logical)\nRECEIVE\nINTO( data-area )\nSET( ptr-ref )\nLENGTH( data-area )\nFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nASIS\nBUFFER\nNOTRUNCATE\nConditions: INVREQ, LENGERR, TERMERR\nDescription\n  RECEIVE receives data from a terminal.\nIf data is to be received, you must specify either the INTO or the SET option. If a RECEIVE is issued purely\nto detect an attention identifier (AID) (and BUFFER has not been specified), you can omit both the INTO\nand SET options.\nRECEIVE (3600 pipeline)\nReceive initial input data from a 3600 pipeline logical unit. Subsequent RECEIVEs for further input data\nare not allowed. \nRECEIVE (3600 pipeline)\nRECEIVE\nINTO( data-area )\nSET( ptr-ref )\nLENGTH( data-area )\nFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nNOTRUNCATE\nConditions: INVREQ, LENGERR, NOTALLOC\n \nDescription\nIf data is to be received, you must specify either the INTO or the SET option. If a RECEIVE is issued purely\nto detect an attention identifier (AID) you can omit both the INTO and SET options.\nRECEIVE (3600-3601)\nReceive data from a 3600 (3601) logical unit. \n386  CICS TS for z/OS: API Reference"}
{"instruction": "Explain this COBOL concept", "input": "Alternative ddname 8-byte entry\nName for which alternative ddname is substituted\n23\nSYSUT9\n24\nSYSUT10\n25\nSYSUT11\n26\nSYSUT12\n27\nSYSUT13\n28\nSYSUT14\n29\nSYSUT15\nVL\nSpecifies that the sign bit is to be set to 1 in the last fullword of the address parameter list.\nWhen the compiler completes processing, it puts a return code in register 15.\nRelated tasks   \n“Defining compiler input and output” on page 280 \nRelated references   \n“Data sets used by the compiler under z/OS” on page 281  \n“Compiler options and compiler output under z/OS” on page 289 \nDefining compiler input and output\nYou need to define several kinds of data sets that the compiler uses to do its work. The compiler takes\ninput data sets and libraries and produces various types of output, including object code, listings, and\nmessages. The compiler also uses utility data sets during compilation.\nRelated tasks   \n“Defining the source code data set (SYSIN)” on page 283  \n“Defining a compiler-option data set (SYSOPTF)” on page 284  \n“Specifying source libraries (SYSLIB)” on page 284  \n“Defining the output data set (SYSPRINT)” on page 285  \n“Directing compiler messages to your terminal (SYSTERM)” on page 285  \n“Creating object code (SYSLIN or SYSPUNCH)” on page 285  \n“Defining an associated-data file (SYSADATA)” on page 286  \n“Defining the Java-source\noutput file (SYSJAVA)” on page 286  \n“Defining the library-processing output file (SYSMDECK)” on page 287 \nRelated references   \n“Data sets used by the compiler under z/OS” on page 281  \n“Compiler options and compiler output under z/OS” on page 289 \n280  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "Alternative ddname 8-byte entry\nName for which alternative ddname is substituted\n23\nSYSUT9\n24\nSYSUT10\n25\nSYSUT11\n26\nSYSUT12\n27\nSYSUT13\n28\nSYSUT14\n29\nSYSUT15\nVL\nSpecifies that the sign bit is to be set to 1 in the last fullword of the address parameter list.\nWhen the compiler completes processing, it puts a return code in register 15.\nRelated tasks   \n“Defining compiler input and output” on page 280 \nRelated references   \n“Data sets used by the compiler under z/OS” on page 281  \n“Compiler options and compiler output under z/OS” on page 289 \nDefining compiler input and output\nYou need to define several kinds of data sets that the compiler uses to do its work. The compiler takes\ninput data sets and libraries and produces various types of output, including object code, listings, and\nmessages. The compiler also uses utility data sets during compilation.\nRelated tasks   \n“Defining the source code data set (SYSIN)” on page 283  \n“Defining a compiler-option data set (SYSOPTF)” on page 284  \n“Specifying source libraries (SYSLIB)” on page 284  \n“Defining the output data set (SYSPRINT)” on page 285  \n“Directing compiler messages to your terminal (SYSTERM)” on page 285  \n“Creating object code (SYSLIN or SYSPUNCH)” on page 285  \n“Defining an associated-data file (SYSADATA)” on page 286  \n“Defining the Java-source\noutput file (SYSJAVA)” on page 286  \n“Defining the library-processing output file (SYSMDECK)” on page 287 \nRelated references   \n“Data sets used by the compiler under z/OS” on page 281  \n“Compiler options and compiler output under z/OS” on page 289 \n280  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 89. 2002/2014 COBOL Standard features implemented in COBOL 3 or later versions that will not a", "output": "Table 89. 2002/2014 COBOL Standard features implemented in COBOL 3 or later versions that will not affect\nexisting programs (continued)\nFeatures\nNotes\nIndex data item\nThe definition of an index data item can include the\nSYNCHRONIZED clause.\nINITIALIZE statement, FILLER phrase\nFILLER data items can be initialized with the\nINITIALIZE statement.\nINITIALIZE statement, VALUE phrase\nA VALUE phrase can be specified in the INITIALIZE\nstatement to cause initialization of elementary data\nitems to the literal specified in the VALUE clause of the\nassociated data description entry.\nIntrinsic function facility\nPreviously, the intrinsic function facility was a\nseparate module and its implementation was optional.\nThe intrinsic function facility is integrated into the\nspecification and it shall be implemented by a\nconforming implementation\nAppendix I. 2002/2014 COBOL Standard features implemented in Enterprise COBOL 3 or later versions  801"}
{"instruction": "Explain this COBOL concept", "input": "Table 131. SYSADATA job identification record (continued)\nField\nSize\nDescription\n1. Where the number of input files would exceed the record size for the associated data file, the record\nis continued on the next record. The current number of input files (for that record) is stored in the\nrecord, and the record is written to the associated data file. The next record contains the rest of the\ninput files. The count of the number of input files is a count for the current record.\nADATA identification record: X'0001'\nThe following table shows the contents of the ADATA identification record.\nTable 132. ADATA identification record\nField\nSize\nDescription\nTime (binary)\nXL8\nUniversal Time (UT) as a binary number of microseconds\nsince midnight Greenwich Mean Time, with the low-order bit\nrepresenting 1 microsecond. This time can be used as a time-zone-\nindependent time stamp.\nCCSID1\nXL2\nCoded Character Set Identifier\nCharacter-set flags\nXL1\nX'80'\nEBCDIC (IBM-037)\nX'40'\nASCII (IBM-1252)\nCode-page name length\nXL2\nLength of the code-page name that follows\nCode-page name\nCL(n)\nName of the code page\n1. The appropriate CCS flag will always be set. If the CCSID is set to nonzero, the code-page name\nlength will be zero. If the CCSID is set to zero, the code-page name length will be nonzero and the\ncode-page name will be present.\nCompilation unit start | end record: X'0002'\nThe following table shows the contents of the compilation unit start|end record.\nTable 133. SYSADATA compilation unit start | end record\nField\nSize\nDescription\nType\nHL2\nCompilation unit type, which is one of the following options:\nX'0000'\nStart compilation unit\nX'0001'\nEnd compilation unit\nReserved\nCL2\nReserved for future use\nReserved\nFL4\nReserved for future use\n884  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "Table 131. SYSADATA job identification record (continued)\nField\nSize\nDescription\n1. Where the number of input files would exceed the record size for the associated data file, the record\nis continued on the next record. The current number of input files (for that record) is stored in the\nrecord, and the record is written to the associated data file. The next record contains the rest of the\ninput files. The count of the number of input files is a count for the current record.\nADATA identification record: X'0001'\nThe following table shows the contents of the ADATA identification record.\nTable 132. ADATA identification record\nField\nSize\nDescription\nTime (binary)\nXL8\nUniversal Time (UT) as a binary number of microseconds\nsince midnight Greenwich Mean Time, with the low-order bit\nrepresenting 1 microsecond. This time can be used as a time-zone-\nindependent time stamp.\nCCSID1\nXL2\nCoded Character Set Identifier\nCharacter-set flags\nXL1\nX'80'\nEBCDIC (IBM-037)\nX'40'\nASCII (IBM-1252)\nCode-page name length\nXL2\nLength of the code-page name that follows\nCode-page name\nCL(n)\nName of the code page\n1. The appropriate CCS flag will always be set. If the CCSID is set to nonzero, the code-page name\nlength will be zero. If the CCSID is set to zero, the code-page name length will be nonzero and the\ncode-page name will be present.\nCompilation unit start | end record: X'0002'\nThe following table shows the contents of the compilation unit start|end record.\nTable 133. SYSADATA compilation unit start | end record\nField\nSize\nDescription\nType\nHL2\nCompilation unit type, which is one of the following options:\nX'0000'\nStart compilation unit\nX'0001'\nEnd compilation unit\nReserved\nCL2\nReserved for future use\nReserved\nFL4\nReserved for future use\n884  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 137. SYSADATA token record (continued)\nField\nSize\nDescription\n5001\nPARSE\n5002\nAUTOMATIC\n5003\nP", "output": "Table 137. SYSADATA token record (continued)\nField\nSize\nDescription\n5001\nPARSE\n5002\nAUTOMATIC\n5003\nPREVIOUS\n5004\nENCODING\n5005\nNAMESPACE\n5006\nNAMESPACE-PREFIX\n5007\nXML-DECLARATION\n5008\nATTRIBUTES\n5009\nVALIDATING\n5010\nUNBOUNDED\n5011\nATTRIBUTE\n5012\nELEMENT\n5013\nNONNUMERIC\n5014\nNAME\n5015\nCYCLE\n5016\nPARAGRAPH\n5017\nLOC\n5018\nINTRINSIC\n5020\nAS\nAppendix G. COBOL SYSADATA file contents  949"}
{"instruction": "Explain this COBOL concept", "input": "Example: subscripting\nThe following example shows valid references to SAMPLE-TABLE-THREE that use literal subscripts. The\nspaces are required in the second example.\nTABLE-COLUMN (2, 2, 1)\nTABLE-COLUMN (2 2 1)\nIn either table reference, the first value (2) refers to the second occurrence within TABLE-DEPTH, the\nsecond value (2) refers to the second occurrence within TABLE-ROW, and the third value (1) refers to the\nfirst occurrence within TABLE-COLUMN.\nThe following reference to SAMPLE-TABLE-TWO uses variable subscripts. The reference is valid if SUB1\nand SUB2 are data-names that contain positive integer values within the range of the table.\nTABLE-COLUMN (SUB1 SUB2)\nRelated tasks   \n“Subscripting” on page 77 \nExample: indexing\nThe following example shows how displacements to elements that are referenced with indexes are\ncalculated.\nConsider the following three-dimensional table, SAMPLE-TABLE-FOUR:\n01  SAMPLE-TABLE-FOUR\n    05 TABLE-DEPTH OCCURS 3 TIMES INDEXED BY INX-A.\n       10 TABLE-ROW OCCURS 4 TIMES INDEXED BY INX-B.\n          15 TABLE-COLUMN OCCURS 8 TIMES INDEXED BY INX-C  PIC X(8).\nSuppose you code the following relative indexing reference to SAMPLE-TABLE-FOUR:\nTABLE-COLUMN (INX-A + 1, INX-B + 2, INX-C - 1)\nThis reference causes the following computation of the displacement to the TABLE-COLUMN element:\n  (contents of INX-A) + (256 * 1)\n+ (contents of INX-B) + (64 * 2)\n+ (contents of INX-C) - (8 * 1)\nThis calculation is based on the following element lengths:\n• Each occurrence of TABLE-DEPTH is 256 bytes in length (4 * 8 * 8).\n• Each occurrence of TABLE-ROW is 64 bytes in length (8 * 8).\n• Each occurrence of TABLE-COLUMN is 8 bytes in length.\nRelated tasks   \n“Indexing” on page 78 \nReferring to an item in a table\nA table element has a collective name, but the individual items within it do not have unique data-names.\nTo refer to an item, you have a choice of three techniques:\n76  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "Example: subscripting\nThe following example shows valid references to SAMPLE-TABLE-THREE that use literal subscripts. The\nspaces are required in the second example.\nTABLE-COLUMN (2, 2, 1)\nTABLE-COLUMN (2 2 1)\nIn either table reference, the first value (2) refers to the second occurrence within TABLE-DEPTH, the\nsecond value (2) refers to the second occurrence within TABLE-ROW, and the third value (1) refers to the\nfirst occurrence within TABLE-COLUMN.\nThe following reference to SAMPLE-TABLE-TWO uses variable subscripts. The reference is valid if SUB1\nand SUB2 are data-names that contain positive integer values within the range of the table.\nTABLE-COLUMN (SUB1 SUB2)\nRelated tasks   \n“Subscripting” on page 77 \nExample: indexing\nThe following example shows how displacements to elements that are referenced with indexes are\ncalculated.\nConsider the following three-dimensional table, SAMPLE-TABLE-FOUR:\n01  SAMPLE-TABLE-FOUR\n    05 TABLE-DEPTH OCCURS 3 TIMES INDEXED BY INX-A.\n       10 TABLE-ROW OCCURS 4 TIMES INDEXED BY INX-B.\n          15 TABLE-COLUMN OCCURS 8 TIMES INDEXED BY INX-C  PIC X(8).\nSuppose you code the following relative indexing reference to SAMPLE-TABLE-FOUR:\nTABLE-COLUMN (INX-A + 1, INX-B + 2, INX-C - 1)\nThis reference causes the following computation of the displacement to the TABLE-COLUMN element:\n  (contents of INX-A) + (256 * 1)\n+ (contents of INX-B) + (64 * 2)\n+ (contents of INX-C) - (8 * 1)\nThis calculation is based on the following element lengths:\n• Each occurrence of TABLE-DEPTH is 256 bytes in length (4 * 8 * 8).\n• Each occurrence of TABLE-ROW is 64 bytes in length (8 * 8).\n• Each occurrence of TABLE-COLUMN is 8 bytes in length.\nRelated tasks   \n“Indexing” on page 78 \nReferring to an item in a table\nA table element has a collective name, but the individual items within it do not have unique data-names.\nTo refer to an item, you have a choice of three techniques:\n76  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "Explain this COBOL concept", "input": "STATE(cvda)\ngets the state of the current conversation. The cvda values returned by CICS are:\n• ALLOCATED \n• CONFFREE \n• CONFRECEIVE \n• CONFSEND \n• FREE \n• PENDFREE \n• PENDRECEIVE \n• RECEIVE \n• ROLLBACK \n• SEND \n• SYNCFREE \n• SYNCRECEIVE \n• SYNCSEND \nConditions\n16 INVREQ\nRESP2 values:\n200\nA distributed program link server application specified the function-shipping session (its principal\nfacility) on the CONVID option.\nalso occurs (RESP2 not set) in any of the following situations:\n• ISSUE ABEND is used on any conversation other than an EXEC CICS APPC mapped conversation.\nDefault action: terminate the task abnormally.\n61 NOTALLOC\noccurs if the specified CONVID value relates to a conversation that is not owned by the application.\nDefault action: terminate the task abnormally.\n81 TERMERR\noccurs for a session-related error. Any action on that conversation other than a FREE command\ncauses an ATCV abend.\nA CANCEL TASK request by a user node error program (NEP) may cause this condition if the task has\nan outstanding terminal control request active when the node abnormal condition program handles\nthe session error.\nDefault action: terminate the task abnormally with abend code ATNI.\nISSUE ABORT\nEnd processing of a data set abnormally.\nChapter 2. CICS command summary  269", "output": "STATE(cvda)\ngets the state of the current conversation. The cvda values returned by CICS are:\n• ALLOCATED \n• CONFFREE \n• CONFRECEIVE \n• CONFSEND \n• FREE \n• PENDFREE \n• PENDRECEIVE \n• RECEIVE \n• ROLLBACK \n• SEND \n• SYNCFREE \n• SYNCRECEIVE \n• SYNCSEND \nConditions\n16 INVREQ\nRESP2 values:\n200\nA distributed program link server application specified the function-shipping session (its principal\nfacility) on the CONVID option.\nalso occurs (RESP2 not set) in any of the following situations:\n• ISSUE ABEND is used on any conversation other than an EXEC CICS APPC mapped conversation.\nDefault action: terminate the task abnormally.\n61 NOTALLOC\noccurs if the specified CONVID value relates to a conversation that is not owned by the application.\nDefault action: terminate the task abnormally.\n81 TERMERR\noccurs for a session-related error. Any action on that conversation other than a FREE command\ncauses an ATCV abend.\nA CANCEL TASK request by a user node error program (NEP) may cause this condition if the task has\nan outstanding terminal control request active when the node abnormal condition program handles\nthe session error.\nDefault action: terminate the task abnormally with abend code ATNI.\nISSUE ABORT\nEnd processing of a data set abnormally.\nChapter 2. CICS command summary  269"}
{"instruction": "Summarize this COBOL documentation section", "input": "cbl dll,thread,pgmname(longmixed),ssrange\n Identification Division.\n Class-id. Echo inherits Base.\n Environment Division.\n Configuration section.\n Repository.\n     Class Base is \"java.lang.Object\"\n     Class stringArray is \"jobjectArray:java.lang.String\"\n     Class jstring is \"java.lang.String\"\n     Class Echo is \"Echo\".\n*\n Identification Division.\n Factory.\n  Procedure division.\n*\n   Identification Division.\n   Method-id. \"main\".\n   Data division.\n   Local-storage section.\n   01 SAlen        pic s9(9) binary.\n   01 I            pic s9(9) binary.\n   01 SAelement    object reference jstring.\n   01 SAelementlen pic s9(9) binary. \n   01 Sbuffer      pic X(65535).\n   01 P            pointer.\n   Linkage section.\n   01 SA           object reference stringArray.\n   Copy \"JNI.cpy\" suppress.\n   Procedure division using by value SA.\n     Set address of JNIEnv to JNIEnvPtr\n     Set address of JNINativeInterface to JNIEnv\n     Call GetArrayLength using by value JNIEnvPtr SA\n       returning SAlen\n     Display \"Input string array length: \" SAlen\n     Display \"Input strings:\"\n     Perform varying I from 0 by 1 until I = SAlen\n       Call GetObjectArrayElement\n         using by value JNIEnvPtr SA I\n         returning SAelement\n       Call \"GetStringPlatformLength\"\n         using by value JNIEnvPtr\n                        SAelement\n                        address of SAelementlen\n                        0\n       Call \"GetStringPlatform\"\n         using by value JNIEnvPtr\n                        SAelement\n                        address of Sbuffer\n                        length of Sbuffer\n                        0\n       Display Sbuffer(1:SAelementlen)\n     End-perform\n     .\n   End method \"main\".\n End factory.\n End class Echo.\nRelated tasks   \nChapter 17, “Compiling, linking, and running OO applications,” on page 305  \n“Defining a factory method” on page 735  \nChapter 41, “Communicating with Java methods,” on page 745\nChapter 40. Writing object-oriented programs  743", "output": "cbl dll,thread,pgmname(longmixed),ssrange\n Identification Division.\n Class-id. Echo inherits Base.\n Environment Division.\n Configuration section.\n Repository.\n     Class Base is \"java.lang.Object\"\n     Class stringArray is \"jobjectArray:java.lang.String\"\n     Class jstring is \"java.lang.String\"\n     Class Echo is \"Echo\".\n*\n Identification Division.\n Factory.\n  Procedure division.\n*\n   Identification Division.\n   Method-id. \"main\".\n   Data division.\n   Local-storage section.\n   01 SAlen        pic s9(9) binary.\n   01 I            pic s9(9) binary.\n   01 SAelement    object reference jstring.\n   01 SAelementlen pic s9(9) binary. \n   01 Sbuffer      pic X(65535).\n   01 P            pointer.\n   Linkage section.\n   01 SA           object reference stringArray.\n   Copy \"JNI.cpy\" suppress.\n   Procedure division using by value SA.\n     Set address of JNIEnv to JNIEnvPtr\n     Set address of JNINativeInterface to JNIEnv\n     Call GetArrayLength using by value JNIEnvPtr SA\n       returning SAlen\n     Display \"Input string array length: \" SAlen\n     Display \"Input strings:\"\n     Perform varying I from 0 by 1 until I = SAlen\n       Call GetObjectArrayElement\n         using by value JNIEnvPtr SA I\n         returning SAelement\n       Call \"GetStringPlatformLength\"\n         using by value JNIEnvPtr\n                        SAelement\n                        address of SAelementlen\n                        0\n       Call \"GetStringPlatform\"\n         using by value JNIEnvPtr\n                        SAelement\n                        address of Sbuffer\n                        length of Sbuffer\n                        0\n       Display Sbuffer(1:SAelementlen)\n     End-perform\n     .\n   End method \"main\".\n End factory.\n End class Echo.\nRelated tasks   \nChapter 17, “Compiling, linking, and running OO applications,” on page 305  \n“Defining a factory method” on page 735  \nChapter 41, “Communicating with Java methods,” on page 745\nChapter 40. Writing object-oriented programs  743"}
{"instruction": "What is that given JSON\nGENERATE or JSON PARSE statement in COBOL?", "input": "", "output": "that given JSON\nGENERATE or JSON PARSE statement is nested JSON GENERATE or JSON PARSE statement"}
{"instruction": "What is A bookmark in COBOL?", "input": "", "output": "A bookmark is symbolic name which\nidentifies an insertion point in the document"}
{"instruction": "Summarize this COBOL documentation section", "input": "Table 134. SYSADATA options record (continued)\nField\nSize\nDescription\nImbedded diagnostic\nlevel\nXL1\nX'00'\nFlag(I)\nX'04'\nFlag(W)\nX'08'\nFlag(E)\nX'0C'\nFlag(S)\nX'10'\nFlag(U)\nX'FF'\nNoflag\nFLAGSTD (FIPS)\nspecification\nXL1\n1... ....\nMinimum\n.1.. ....\nIntermediate\n..1. ....\nHigh\n...1 ....\nIBM extensions\n.... 1...\nLevel-1 segmentation\n.... .1..\nLevel-2 segmentation\n.... ..1.\nDebugging\n.... ...1\nObsolete\nReserved for flagging\nXL1\n1111 1111\nReserved for future use\nCompiler mode\nXL1\nX'00'\nUnconditional Nocompile, Nocompile(I)\nX'04'\nNocompile(W)\nX'08'\nNocompile(E)\nX'0C'\nNocompile(S)\nX'FF'\nCompile\nSpace value\nCL1\n \nAppendix G. COBOL SYSADATA file contents  893", "output": "Table 134. SYSADATA options record (continued)\nField\nSize\nDescription\nImbedded diagnostic\nlevel\nXL1\nX'00'\nFlag(I)\nX'04'\nFlag(W)\nX'08'\nFlag(E)\nX'0C'\nFlag(S)\nX'10'\nFlag(U)\nX'FF'\nNoflag\nFLAGSTD (FIPS)\nspecification\nXL1\n1... ....\nMinimum\n.1.. ....\nIntermediate\n..1. ....\nHigh\n...1 ....\nIBM extensions\n.... 1...\nLevel-1 segmentation\n.... .1..\nLevel-2 segmentation\n.... ..1.\nDebugging\n.... ...1\nObsolete\nReserved for flagging\nXL1\n1111 1111\nReserved for future use\nCompiler mode\nXL1\nX'00'\nUnconditional Nocompile, Nocompile(I)\nX'04'\nNocompile(W)\nX'08'\nNocompile(E)\nX'0C'\nNocompile(S)\nX'FF'\nCompile\nSpace value\nCL1\n \nAppendix G. COBOL SYSADATA file contents  893"}
{"instruction": "What is This in COBOL?", "input": "", "output": "This is value to which a named\ncounter is reset as a result of a REWIND command"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Trademarks..........................................................................................", "output": "Trademarks..............................................................................................................................................999\nGlossary..........................................................................................................1001\nList of resources.............................................................................................. 1045\nEnterprise COBOL for z/OS publications...............................................................................................1045\nRelated publications..............................................................................................................................1045\nIndex.............................................................................................................. 1049\nxx"}
{"instruction": "What is including no subordinate items referenced when the item in COBOL?", "input": "", "output": "including no subordinate items referenced when the item is group, are reported,\nregardless of whether the definition of the data item appears directly in the user source program or\nwas included in the program from a copy member"}
{"instruction": "What is where literal in COBOL?", "input": "", "output": "where literal is valid COBOL\nalphanumeric literal (optionally a hexadecimal literal) that represents a single character"}
{"instruction": "What is STORAGE content in COBOL?", "input": "", "output": "STORAGE content is same as program LOCAL-STORAGE\ncontent except that the GLOBAL clause has no effect (because methods and user-defined functions\ncannot be nested)"}
{"instruction": "Summarize this COBOL documentation section", "input": "8\nThe activity named on the FROMACTIVITY or TOACTIVITY option could not be found.\n110 CONTAINERERR\nRESP2 values:\n10\nThe container named on the CONTAINER option could not be found.\n26\nThe process container named on the CONTAINER option is read-only.\n16 INVREQ\nRESP2 values:\n4\nThe command was issued outside the scope of a currently-active activity.\n25\nThe FROMPROCESS or TOPROCESS option was used, but the command was issued outside the\nscope of a currently-active process.\n17 IOERR\nRESP2 values:\n30\nAn input/output error has occurred on the repository file.\n31\nThe record on the repository file is in use.\n100 LOCKED\nThe request cannot be performed because a retained lock exists against the relevant record on the\nrepository file.\nMOVE CONTAINER (CHANNEL)\nMove a container (and its contents) from one channel to another.\nMOVE CONTAINER (CHANNEL)\nMOVE\nCONTAINER(  data-value )\nAS( data-value )\nCHANNEL(  data-value )\nTOCHANNEL(  data-value )\nConditions: CHANNELERR, CONTAINERERR, INVREQ\nThis command is threadsafe.\nDescription\nMOVE CONTAINER (CHANNEL) moves a container from one channel to another. After the move, the\nsource container no longer exists.\nThe source and target containers are identified by name and by the channels that own them. The channel\nthat owns the source container can be identified as follows:\n• Explicitly, by specifying the CHANNEL option.\n• Implicitly, by omitting the CHANNEL option. If this is omitted, the current channel is implied.\nSimilarly, the channel that owns the target container can be identified as follows:\n• Explicitly, by specifying the TOCHANNEL option.\n• Implicitly, by omitting the TOCHANNEL option. If this is omitted, the current channel is implied.\n322  CICS TS for z/OS: API Reference", "output": "8\nThe activity named on the FROMACTIVITY or TOACTIVITY option could not be found.\n110 CONTAINERERR\nRESP2 values:\n10\nThe container named on the CONTAINER option could not be found.\n26\nThe process container named on the CONTAINER option is read-only.\n16 INVREQ\nRESP2 values:\n4\nThe command was issued outside the scope of a currently-active activity.\n25\nThe FROMPROCESS or TOPROCESS option was used, but the command was issued outside the\nscope of a currently-active process.\n17 IOERR\nRESP2 values:\n30\nAn input/output error has occurred on the repository file.\n31\nThe record on the repository file is in use.\n100 LOCKED\nThe request cannot be performed because a retained lock exists against the relevant record on the\nrepository file.\nMOVE CONTAINER (CHANNEL)\nMove a container (and its contents) from one channel to another.\nMOVE CONTAINER (CHANNEL)\nMOVE\nCONTAINER(  data-value )\nAS( data-value )\nCHANNEL(  data-value )\nTOCHANNEL(  data-value )\nConditions: CHANNELERR, CONTAINERERR, INVREQ\nThis command is threadsafe.\nDescription\nMOVE CONTAINER (CHANNEL) moves a container from one channel to another. After the move, the\nsource container no longer exists.\nThe source and target containers are identified by name and by the channels that own them. The channel\nthat owns the source container can be identified as follows:\n• Explicitly, by specifying the CHANNEL option.\n• Implicitly, by omitting the CHANNEL option. If this is omitted, the current channel is implied.\nSimilarly, the channel that owns the target container can be identified as follows:\n• Explicitly, by specifying the TOCHANNEL option.\n• Implicitly, by omitting the TOCHANNEL option. If this is omitted, the current channel is implied.\n322  CICS TS for z/OS: API Reference"}
{"instruction": "Explain this COBOL concept", "input": "Value CVDA\n831 RRINDOUBT\n832 LCKSTRUCFULL\n833 CFTABLE\n834 LOAD\n835 NOLOAD\n836 CONTENTION\n837 LOCKING\n840 CSDAPI\n841 CSDBATCH\n842 GRPLIST\n843 DREPAPI\n844 CREATESPI\n845 DREPBATCH\n847 TABLE\n848 CLOUD\n850 FROMEPR\n851 TOEPR\n852 REPLYTOEPR\n853 FAULTTOEPR\n854 REQCONTEXT\n856 ALL\n857 METADATA\n858 REFPARMS\n859 ADDRESS\n860 ALLVALUES\n861 DOESNOTEQUAL\n862 DOESNOTSTART\n863 EQUALS\n864 GREATERTHAN\n865 ISNOTGREATER\n866 ISNOTLESS\n867 LESSTHAN\n868 STARTSWITH\n869 CONTAINER\n870 CURRENTPGM\nChapter 4. CICS-value data areas used by all commands  759", "output": "Value CVDA\n831 RRINDOUBT\n832 LCKSTRUCFULL\n833 CFTABLE\n834 LOAD\n835 NOLOAD\n836 CONTENTION\n837 LOCKING\n840 CSDAPI\n841 CSDBATCH\n842 GRPLIST\n843 DREPAPI\n844 CREATESPI\n845 DREPBATCH\n847 TABLE\n848 CLOUD\n850 FROMEPR\n851 TOEPR\n852 REPLYTOEPR\n853 FAULTTOEPR\n854 REQCONTEXT\n856 ALL\n857 METADATA\n858 REFPARMS\n859 ADDRESS\n860 ALLVALUES\n861 DOESNOTEQUAL\n862 DOESNOTSTART\n863 EQUALS\n864 GREATERTHAN\n865 ISNOTGREATER\n866 ISNOTLESS\n867 LESSTHAN\n868 STARTSWITH\n869 CONTAINER\n870 CURRENTPGM\nChapter 4. CICS-value data areas used by all commands  759"}
{"instruction": "Explain this COBOL concept", "input": "Default action: terminate the task abnormally.\n22 LENGERR\nThis condition occurs in any of the following situations:\n• Data that is received is discarded by CICS because its length exceeds the maximum that the\nprogram accepts (see TOLENGTH and MAXLENGTH options), and the NOTRUNCATE option is not\nspecified.\n• An out-of-range value is supplied in one of the options, FROMLENGTH, FROMFLENGTH,\nMAXLENGTH, MAXFLENGTH, TOLENGTH, or TOFLENGTH.\nDefault action: terminate the task abnormally.\n61 NOTALLOC\nThis condition occurs if the facility specified in the command is not owned by the application, or does\nnot relate to a conversation owned by the application.\nDefault action: terminate the task abnormally.\n24 SIGNAL\nThis condition occurs when an inbound SIGNAL data flow control command is received from a logical\nunit or session, or the partner transaction. EIBSIG is always set when an inbound signal is received.\nDefault action: ignore the condition.\n81 TERMERR\nThis condition occurs for a terminal or session-related error. Any action on that conversation other\nthan a FREE causes an ATCV abend.\nA CANCEL TASK request by a user node error program (NEP) can cause this condition if the task has\nan outstanding terminal control request active when the node abnormal condition program handles\nthe session error.\nDefault action: terminate the task abnormally with abend code ATNI.\nCONVERSE (non-z/OS Communications Server default)\nCommunicate on standard CICS terminal support.\nCONVERSE (default)\nCONVERSE\nFROM( data-area )\nFROMLENGTH(  data-value )\nFROMFLENGTH(  data-value )\nINTO( data-area )\nSET( ptr-ref )\nTOLENGTH(  data-area )\nTOFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nNOTRUNCATE\nConditions: LENGERR\n \nDescription\nThis form of the CONVERSE command is used by all CICS-supported terminals for which the other\nCONVERSE descriptions are not appropriate.\n92  CICS TS for z/OS: API Reference", "output": "Default action: terminate the task abnormally.\n22 LENGERR\nThis condition occurs in any of the following situations:\n• Data that is received is discarded by CICS because its length exceeds the maximum that the\nprogram accepts (see TOLENGTH and MAXLENGTH options), and the NOTRUNCATE option is not\nspecified.\n• An out-of-range value is supplied in one of the options, FROMLENGTH, FROMFLENGTH,\nMAXLENGTH, MAXFLENGTH, TOLENGTH, or TOFLENGTH.\nDefault action: terminate the task abnormally.\n61 NOTALLOC\nThis condition occurs if the facility specified in the command is not owned by the application, or does\nnot relate to a conversation owned by the application.\nDefault action: terminate the task abnormally.\n24 SIGNAL\nThis condition occurs when an inbound SIGNAL data flow control command is received from a logical\nunit or session, or the partner transaction. EIBSIG is always set when an inbound signal is received.\nDefault action: ignore the condition.\n81 TERMERR\nThis condition occurs for a terminal or session-related error. Any action on that conversation other\nthan a FREE causes an ATCV abend.\nA CANCEL TASK request by a user node error program (NEP) can cause this condition if the task has\nan outstanding terminal control request active when the node abnormal condition program handles\nthe session error.\nDefault action: terminate the task abnormally with abend code ATNI.\nCONVERSE (non-z/OS Communications Server default)\nCommunicate on standard CICS terminal support.\nCONVERSE (default)\nCONVERSE\nFROM( data-area )\nFROMLENGTH(  data-value )\nFROMFLENGTH(  data-value )\nINTO( data-area )\nSET( ptr-ref )\nTOLENGTH(  data-area )\nTOFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nNOTRUNCATE\nConditions: LENGERR\n \nDescription\nThis form of the CONVERSE command is used by all CICS-supported terminals for which the other\nCONVERSE descriptions are not appropriate.\n92  CICS TS for z/OS: API Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Related tasks   \n“Using data in input and output operations” on page 11 \nRelated references   \nEXTER", "output": "Related tasks   \n“Using data in input and output operations” on page 11 \nRelated references   \nEXTERNAL clause (Enterprise COBOL for z/OS Language Reference)\nExample: using external files\nThe following example shows the use of an external file in several programs. COPY statements ensure that\neach subprogram contains an identical description of the file.\nThe following table describes the main program and subprograms.\nName\nFunction\nef1\nThe main program, which calls all the subprograms and then verifies the contents of a\nrecord area\nef1openo\nOpens the external file for output and checks the file status code\nef1write\nWrites a record to the external file and checks the file status code\nef1openi\nOpens the external file for input and checks the file status code\nef1read\nReads a record from the external file and checks the file status code\nef1close\nCloses the external file and checks the file status code\nEach program uses three copybooks:\n• efselect is placed in the FILE-CONTROL paragraph:\nSelect ef1 \nAssign To ef1\nFile Status Is efs1\nOrganization Is Sequential.\n• effile is placed in the FILE SECTION:\nFd ef1 Is External\n          Record Contains 80 Characters\n          Recording Mode F.\n01  ef-record-1.\n    02 ef-item-1  Pic X(80).\n• efwrkstg is placed in the WORKING-STORAGE SECTION:\n01  efs1          Pic 99 External.\nInput/output using external files\n IDENTIFICATION DIVISION.\n Program-Id.\n     ef1.\n*\n* This main program controls external file processing.\n*\n ENVIRONMENT DIVISION.\n Input-Output Section.\n File-Control.\n     Copy efselect.\n DATA DIVISION.\n FILE SECTION.\n     Copy effile.\n WORKING-STORAGE SECTION.\n     Copy efwrkstg.\n PROCEDURE DIVISION.\n600  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What is each possible receiving operand in COBOL?", "input": "", "output": "each possible receiving operand is receiving operand if at least one of the following\nconditions is true:\n• The VALUE phrase is specified, the category of the elementary data item is one of the categories\nspecified or implied in the VALUE phrase, and either of the following conditions is true:\n– A data-item format VALUE clause is specified in the data description entry of the elementary\ndata item.\n– A table format VALUE clause is specified in the data description entry of the elementary item\nand that VALUE clause specifies a value for the particular occurrence of the elementary data\nitem.\n• The REPLACING phrase is specified and the category of the elementary data item is one of the\ncategories specified in the REPLACING phrase.\n• The DEFAULT phrase is specified.\n• Neither the REPLACING phrase nor the VALUE phrase is specified.\n2"}
{"instruction": "What is NNAMESPACE in COBOL?", "input": "", "output": "NNAMESPACE is elementary data item of category national"}
{"instruction": "Summarize this COBOL documentation section", "input": "DATA DIVISION.\nWORKING-STORAGE SECTION.\n77  AREA-POINTER    USAGE IS POINTER.\nLINKAGE SECTION.\n  01  WORKAREA          PIC X(100).\nPROCEDURE DIVISION.\n  EXEC CICS GETMAIN SET(AREA-POINTER)\n  LENGTH(100)\n  END-EXEC.\n      .\n  SET ADDRESS OF WORKAREA TO AREA-POINTER.\n      .\n      .\n  EXEC CICS FREEMAIN DATA(WORKAREA)\n  END-EXEC.\n  EXEC CICS RETURN\n  END-EXEC.\nAlternatively, the previous COBOL example could free the storage by using the following command:\nEXEC CICS FREEMAIN DATAPOINTER(AREA-POINTER)\nEND-EXEC.\nExample: C\n#pragma XOPTS(CICS);\n#define MAINSIZE 100;\nmain()\n{\n char              *buffer;\n struct eib_record dfheiptr;\n EXEC CICS ADDRESS EIB(dfheiptr);\n EXEC CICS GETMAIN SET(buffer)\n                   LENGTH(MAINSIZE);\n buffer[2] = 'a';\n   .\n   .\n EXEC CICS FREEMAIN DATA(buffer);\n EXEC CICS RETURN;\n}\nExample: PL/I\nDCL AREA_PTR    POINTER,\n    WORKAREA    CHAR(100) BASED(AREA_PTR);\n  .\n  .\n  .\nEXEC CICS GETMAIN SET(AREA_PTR) LENGTH(100);\n  .\nEXEC CICS FREEMAIN DATA(WORKAREA);\nExample: Assembler\nWORKAREA   DS   CL100\n  .\n  .\n           EXEC CICS GETMAIN SET(9) LENGTH(100)\n           USING  WORKAREA,9\n           EXEC CICS FREEMAIN DATA(WORKAREA)\nAlternatively, you can free storage using the DATAPOINTER option as shown in the following example:\nChapter 2. CICS command summary  195", "output": "DATA DIVISION.\nWORKING-STORAGE SECTION.\n77  AREA-POINTER    USAGE IS POINTER.\nLINKAGE SECTION.\n  01  WORKAREA          PIC X(100).\nPROCEDURE DIVISION.\n  EXEC CICS GETMAIN SET(AREA-POINTER)\n  LENGTH(100)\n  END-EXEC.\n      .\n  SET ADDRESS OF WORKAREA TO AREA-POINTER.\n      .\n      .\n  EXEC CICS FREEMAIN DATA(WORKAREA)\n  END-EXEC.\n  EXEC CICS RETURN\n  END-EXEC.\nAlternatively, the previous COBOL example could free the storage by using the following command:\nEXEC CICS FREEMAIN DATAPOINTER(AREA-POINTER)\nEND-EXEC.\nExample: C\n#pragma XOPTS(CICS);\n#define MAINSIZE 100;\nmain()\n{\n char              *buffer;\n struct eib_record dfheiptr;\n EXEC CICS ADDRESS EIB(dfheiptr);\n EXEC CICS GETMAIN SET(buffer)\n                   LENGTH(MAINSIZE);\n buffer[2] = 'a';\n   .\n   .\n EXEC CICS FREEMAIN DATA(buffer);\n EXEC CICS RETURN;\n}\nExample: PL/I\nDCL AREA_PTR    POINTER,\n    WORKAREA    CHAR(100) BASED(AREA_PTR);\n  .\n  .\n  .\nEXEC CICS GETMAIN SET(AREA_PTR) LENGTH(100);\n  .\nEXEC CICS FREEMAIN DATA(WORKAREA);\nExample: Assembler\nWORKAREA   DS   CL100\n  .\n  .\n           EXEC CICS GETMAIN SET(9) LENGTH(100)\n           USING  WORKAREA,9\n           EXEC CICS FREEMAIN DATA(WORKAREA)\nAlternatively, you can free storage using the DATAPOINTER option as shown in the following example:\nChapter 2. CICS command summary  195"}
{"instruction": "Summarize this COBOL documentation section", "input": "Example: subscripting\nThe following example shows valid references to SAMPLE-TABLE-THREE that use literal subscripts. The\nspaces are required in the second example.\nTABLE-COLUMN (2, 2, 1)\nTABLE-COLUMN (2 2 1)\nIn either table reference, the first value (2) refers to the second occurrence within TABLE-DEPTH, the\nsecond value (2) refers to the second occurrence within TABLE-ROW, and the third value (1) refers to the\nfirst occurrence within TABLE-COLUMN.\nThe following reference to SAMPLE-TABLE-TWO uses variable subscripts. The reference is valid if SUB1\nand SUB2 are data-names that contain positive integer values within the range of the table.\nTABLE-COLUMN (SUB1 SUB2)\nRelated tasks   \n“Subscripting” on page 77 \nExample: indexing\nThe following example shows how displacements to elements that are referenced with indexes are\ncalculated.\nConsider the following three-dimensional table, SAMPLE-TABLE-FOUR:\n01  SAMPLE-TABLE-FOUR\n    05 TABLE-DEPTH OCCURS 3 TIMES INDEXED BY INX-A.\n       10 TABLE-ROW OCCURS 4 TIMES INDEXED BY INX-B.\n          15 TABLE-COLUMN OCCURS 8 TIMES INDEXED BY INX-C  PIC X(8).\nSuppose you code the following relative indexing reference to SAMPLE-TABLE-FOUR:\nTABLE-COLUMN (INX-A + 1, INX-B + 2, INX-C - 1)\nThis reference causes the following computation of the displacement to the TABLE-COLUMN element:\n  (contents of INX-A) + (256 * 1)\n+ (contents of INX-B) + (64 * 2)\n+ (contents of INX-C) - (8 * 1)\nThis calculation is based on the following element lengths:\n• Each occurrence of TABLE-DEPTH is 256 bytes in length (4 * 8 * 8).\n• Each occurrence of TABLE-ROW is 64 bytes in length (8 * 8).\n• Each occurrence of TABLE-COLUMN is 8 bytes in length.\nRelated tasks   \n“Indexing” on page 78 \nReferring to an item in a table\nA table element has a collective name, but the individual items within it do not have unique data-names.\nTo refer to an item, you have a choice of three techniques:\n76  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "Example: subscripting\nThe following example shows valid references to SAMPLE-TABLE-THREE that use literal subscripts. The\nspaces are required in the second example.\nTABLE-COLUMN (2, 2, 1)\nTABLE-COLUMN (2 2 1)\nIn either table reference, the first value (2) refers to the second occurrence within TABLE-DEPTH, the\nsecond value (2) refers to the second occurrence within TABLE-ROW, and the third value (1) refers to the\nfirst occurrence within TABLE-COLUMN.\nThe following reference to SAMPLE-TABLE-TWO uses variable subscripts. The reference is valid if SUB1\nand SUB2 are data-names that contain positive integer values within the range of the table.\nTABLE-COLUMN (SUB1 SUB2)\nRelated tasks   \n“Subscripting” on page 77 \nExample: indexing\nThe following example shows how displacements to elements that are referenced with indexes are\ncalculated.\nConsider the following three-dimensional table, SAMPLE-TABLE-FOUR:\n01  SAMPLE-TABLE-FOUR\n    05 TABLE-DEPTH OCCURS 3 TIMES INDEXED BY INX-A.\n       10 TABLE-ROW OCCURS 4 TIMES INDEXED BY INX-B.\n          15 TABLE-COLUMN OCCURS 8 TIMES INDEXED BY INX-C  PIC X(8).\nSuppose you code the following relative indexing reference to SAMPLE-TABLE-FOUR:\nTABLE-COLUMN (INX-A + 1, INX-B + 2, INX-C - 1)\nThis reference causes the following computation of the displacement to the TABLE-COLUMN element:\n  (contents of INX-A) + (256 * 1)\n+ (contents of INX-B) + (64 * 2)\n+ (contents of INX-C) - (8 * 1)\nThis calculation is based on the following element lengths:\n• Each occurrence of TABLE-DEPTH is 256 bytes in length (4 * 8 * 8).\n• Each occurrence of TABLE-ROW is 64 bytes in length (8 * 8).\n• Each occurrence of TABLE-COLUMN is 8 bytes in length.\nRelated tasks   \n“Indexing” on page 78 \nReferring to an item in a table\nA table element has a collective name, but the individual items within it do not have unique data-names.\nTo refer to an item, you have a choice of three techniques:\n76  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Chapter 42. COS\nThe COS function returns a numeric value that approximates the cosine of the angle o", "output": "Chapter 42. COS\nThe COS function returns a numeric value that approximates the cosine of the angle or arc specified by\nthe argument in radians.\nThe function type is numeric.\nFormat\nFUNCTION COS\n(\nargument-1\n)\nargument-1\nMust be class numeric.\nThe returned value is the approximation of the cosine of the argument and is greater than or equal to -1\nand less than or equal to +1.\n© Copyright IBM Corp. 1991, 2025\n549"}
{"instruction": "Summarize this COBOL documentation section", "input": "Table 86. Reserved words (continued)\nWord\nReserved\nStandard only\nPotential\nreserved words\nEGCS\nX\n \n \nEGI\n \nX\n \nEJECT\nX\n \n \nELSE\nX\n \n \nEMI\n \nX\n \nENABLE\n \nX\n \nEND\nX\n \n \nEND-ACCEPT\n \n \nX\nEND-ADD\nX\n \n \nEND-CALL\nX\n \n \nEND-COMPUTE\nX\n \n \nEND-DELETE\nX\n \n \nEND-DISPLAY\n \n \nX\nEND-DIVIDE\nX\n \n \nEND-EVALUATE\nX\n \n \nEND-EXEC\nX\n \n \nEND-IF\nX\n \n \nEND-INVOKE\nX\n \n \nEND-JSON\nX\nEND-MULTIPLY\nX\n \n \nEND-OF-PAGE\nX\n \n \nEND-PERFORM\nX\n \n \nEND-READ\nX\n \n \nEND-RECEIVE\n \nX\n \nEND-RETURN\nX\n \n \nEND-REWRITE\nX\n \n \nEND-SEARCH\nX\n \n \nEND-START\nX\n \n \nEND-STRING\nX\n \n \nEND-SUBTRACT\nX\n \n \nEND-UNSTRING\nX\n \n \nEND-WRITE\nX\n \n \nEND-XML\nX\n \n \nENDING\nX\n \n \n776  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "Table 86. Reserved words (continued)\nWord\nReserved\nStandard only\nPotential\nreserved words\nEGCS\nX\n \n \nEGI\n \nX\n \nEJECT\nX\n \n \nELSE\nX\n \n \nEMI\n \nX\n \nENABLE\n \nX\n \nEND\nX\n \n \nEND-ACCEPT\n \n \nX\nEND-ADD\nX\n \n \nEND-CALL\nX\n \n \nEND-COMPUTE\nX\n \n \nEND-DELETE\nX\n \n \nEND-DISPLAY\n \n \nX\nEND-DIVIDE\nX\n \n \nEND-EVALUATE\nX\n \n \nEND-EXEC\nX\n \n \nEND-IF\nX\n \n \nEND-INVOKE\nX\n \n \nEND-JSON\nX\nEND-MULTIPLY\nX\n \n \nEND-OF-PAGE\nX\n \n \nEND-PERFORM\nX\n \n \nEND-READ\nX\n \n \nEND-RECEIVE\n \nX\n \nEND-RETURN\nX\n \n \nEND-REWRITE\nX\n \n \nEND-SEARCH\nX\n \n \nEND-START\nX\n \n \nEND-STRING\nX\n \n \nEND-SUBTRACT\nX\n \n \nEND-UNSTRING\nX\n \n \nEND-WRITE\nX\n \n \nEND-XML\nX\n \n \nENDING\nX\n \n \n776  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 105. IGZCA2D return codes (continued)\nReturn code\nExplanation\n10\nparameter-1 was converted and", "output": "Table 105. IGZCA2D return codes (continued)\nReturn code\nExplanation\n10\nparameter-1 was converted and the results were placed in parameter-2. A single-\nbyte character in the range X'00' to X'3F' or X'FF' was encountered. The valid single-\nbyte character was converted into an out-of-range DBCS character.\nThe DBCS data in parameter-2 was truncated on the right.\n12\nAn odd number of bytes was found between paired shift codes in parameter-1. No\nconversion occurred.\n13\nUnpaired or nested shift codes were found in parameter-1. No conversion occurred.\n14\nparameter-1 and parameter-2 were overlapping. No conversion occurred.\n15\nThe value provided for parameter-3 or parameter-4 was out of range. No conversion\noccurred.\n16\nAn odd number of bytes was coded in parameter-4. No conversion occurred.\nExample: IGZCA2D\nThis example CALL statement converts the alphanumeric data in alpha-item to DBCS data. The results\nof the conversion are placed in dbcs-item.\nCALL \"IGZCA2D\" USING BY REFERENCE alpha-item dbcs-item\n    BY CONTENT LENGTH OF alpha-item LENGTH OF dbcs-item\nSuppose the contents of alpha-item and dbcs-item and the lengths before the conversion are:\nalpha-item = AB<D1D2D3>CD\ndbcs-item  = D4D5D6D7D8D9D0\nLENGTH OF alpha-item = 12\nLENGTH OF dbcs-item  = 14\nThen after the conversion, alpha-item and dbcs-item will contain:\nalpha-item = AB<D1D2D3>CD\ndbcs-item  = .A.BD1D2D3.C.D\nThe content of the RETURN-CODE register is 0.\nRelated references   \n“DBCS notation” on page 829 \nDBCS to alphanumeric data conversion (IGZCD2A)\nThe Language Environment IGZCD2A routine converts pure DBCS data to alphanumeric data that can\ncontain double-byte characters.\nIGZCD2A syntax\nTo use the IGZCD2A service routine, pass the following four parameters to the routine using the CALL\nstatement:\nparameter-1\nThe sending field for the conversion, handled as a DBCS data item.\nAppendix B. Converting double-byte character set (DBCS) data  831"}
{"instruction": "Explain this COBOL concept", "input": "EBCDIC DBCS\nSee double-byte EBCDIC.\nedited data item\nA data item that has been modified by suppressing zeros or inserting editing characters or both.\n* editing character\nA single character or a fixed two-character combination belonging to the following set:\nCharacter\nMeaning\nSpace\n0\nZero\n+\nPlus\n-\nMinus\nCR\nCredit\nDB\nDebit\nZ\nZero suppress\n*\nCheck protect\n$\nCurrency sign\n,\nComma (decimal point)\n.\nPeriod (decimal point)\n/\nSlant (forward slash)\nEGCS\nSee extended graphic character set (EGCS).\nEJB\nSee Enterprise JavaBeans.\nEJB container\nA container that implements the EJB component contract of the J2EE architecture. This contract\nspecifies a runtime environment for enterprise beans that includes security, concurrency, life cycle\nmanagement, transaction, deployment, and other services. An EJB container is provided by an EJB or\nJ2EE server. (Oracle)\nEJB server\nSoftware that provides services to an EJB container. An EJB server can host one or more EJB\ncontainers. (Oracle)\nelement (text element)\nOne logical unit of a string of text, such as the description of a single data item or verb, preceded by a\nunique code identifying the element type.\n* elementary item\nA data item that is described as not being further logically subdivided.\nencapsulation\nIn object-oriented programming, the technique that is used to hide the inherent details of an\nobject. The object provides an interface that queries and manipulates the data without exposing\nits underlying structure. Synonymous with information hiding.\nenclave\nWhen running under Language Environment, an enclave is analogous to a run unit. An enclave can\ncreate other enclaves by using LINK and by using the system() function in C.\nencoding unit\nSee character encoding unit.\n826  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "EBCDIC DBCS\nSee double-byte EBCDIC.\nedited data item\nA data item that has been modified by suppressing zeros or inserting editing characters or both.\n* editing character\nA single character or a fixed two-character combination belonging to the following set:\nCharacter\nMeaning\nSpace\n0\nZero\n+\nPlus\n-\nMinus\nCR\nCredit\nDB\nDebit\nZ\nZero suppress\n*\nCheck protect\n$\nCurrency sign\n,\nComma (decimal point)\n.\nPeriod (decimal point)\n/\nSlant (forward slash)\nEGCS\nSee extended graphic character set (EGCS).\nEJB\nSee Enterprise JavaBeans.\nEJB container\nA container that implements the EJB component contract of the J2EE architecture. This contract\nspecifies a runtime environment for enterprise beans that includes security, concurrency, life cycle\nmanagement, transaction, deployment, and other services. An EJB container is provided by an EJB or\nJ2EE server. (Oracle)\nEJB server\nSoftware that provides services to an EJB container. An EJB server can host one or more EJB\ncontainers. (Oracle)\nelement (text element)\nOne logical unit of a string of text, such as the description of a single data item or verb, preceded by a\nunique code identifying the element type.\n* elementary item\nA data item that is described as not being further logically subdivided.\nencapsulation\nIn object-oriented programming, the technique that is used to hide the inherent details of an\nobject. The object provides an interface that queries and manipulates the data without exposing\nits underlying structure. Synonymous with information hiding.\nenclave\nWhen running under Language Environment, an enclave is analogous to a run unit. An enclave can\ncreate other enclaves by using LINK and by using the system() function in C.\nencoding unit\nSee character encoding unit.\n826  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What is This in COBOL?", "input": "", "output": "This is eleventh\nEMP in this application"}
{"instruction": "What is where m in COBOL?", "input": "", "output": "where m is number of national (UTF-16) characters in the group"}
{"instruction": "What are the compiler rules or directives for this?", "input": "name specified by the remote system that caused the", "output": "name specified by the remote system that caused the"}
{"instruction": "What is the syntax for this COBOL construct?", "input": "checked but has no effect on the execution of the program when", "output": "checked but has no effect on the execution of the program when"}
{"instruction": "What is Using constants\nA constant in COBOL?", "input": "", "output": "Using constants\nA constant is data item that has only one value"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "22\nMilliseconds are out of range.\nAlso occurs (RESP2 not set) if the DELAY command is not valid for ", "output": "22\nMilliseconds are out of range.\nAlso occurs (RESP2 not set) if the DELAY command is not valid for processing by CICS.\nDefault action: terminate the task abnormally.\nExamples\nThe following example shows you how to suspend the processing of a task for five minutes:\nEXEC CICS DELAY\n     INTERVAL(500)\n     REQID('GXLBZQMR')\nEXEC CICS DELAY FOR MINUTES(5)\nThe following example shows you how, at 09:00, to suspend the processing of a task until 12:45:\nEXEC CICS DELAY\n     TIME(124500)\n     REQID('UNIQCODE')\nThere are two ways to enter the time under UNTIL.\n• A combination of at least two of HOURS(0–99), MINUTES(0–59) and SECONDS(0–59). HOURS(1)\nSECONDS(3) would mean one hour and three seconds (the minutes default to zero).\n• Any one of HOURS(0–99), MINUTES(0–5999), or SECONDS(0–359 999). HOURS(1) means one hour.\nMINUTES(62) means one hour and two minutes. SECONDS(3723) means one hour, two minutes, and\nthree seconds.\nUnder FOR you can enter the time in both ways that apply to UNTIL and additionally you can specify a\ndelay to include milliseconds or specify the delay completely in milliseconds. To specify fractions of a\nsecond on a delay, code the MILLISECS parameter in the range 0-999 in addition to other time units. To\nspecify the delay purely in milliseconds, code the MILLISECS parameter in the range 0-359999999. The\nfollowing example shows you how to suspend the processing of a task for 15000 milliseconds:\nEXEC CICS DELAY\n     FOR MILLISECS(15000)\n     REQID('UNIQCODE')\n114  CICS TS for z/OS: API Reference"}
{"instruction": "What is You must specify an identifier that in COBOL?", "input": "", "output": "You must specify an identifier that is name of an entry in the WORKING-STORAGE SECTION or the\nLINKAGE SECTION, or of a record description for another previously opened file"}
{"instruction": "What is The nth entry in the array in COBOL?", "input": "", "output": "The nth entry in the array is address of the nth character string passed as\nan argument in the spawn() or exec() function or in the command invocation"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "DFHMDF\nThe DFHMDF macro defines a field within a map defined by the previous DFHMDI macro.\nDFHMDF (p", "output": "DFHMDF\nThe DFHMDF macro defines a field within a map defined by the previous DFHMDI macro.\nDFHMDF (part 1)\nfld\nDFHMDF\n,\nPOS\n=\nnumber\n(\nline\n,\ncolumn\n)\nLENGTH\n=\nnumber\nJUSTIFY\n=\n(\nLEFT\nRIGHT\n,\nBLANK\nZERO\n)\nINITIAL\n=\n'\nchar-data\n'\nXINIT\n=\nhex-data\nGINIT\n=\n'\nDBCS-characters\n'\nATTRB\n=\n(\nASKIP\nPROT\nUNPROT\n,\nNUM\n,\nBRT\nNORM\nDRK\n,\nDET\n,\nIC\n,\nFSET\n)\nHILIGHT\n=\nOFF\nBLINK\nREVERSE\nUNDERLINE\nVALIDN\n=\n(\n,\nMUSTFILL\nMUSTENTER\nTRIGGER\nUSEREXIT\n)\nOUTLINE\n=\nBOX\n(\n,\nLEFT\nRIGHT\nOVER\nUNDER\n)\nTRANSP\n=\nYES\nNO\nNotes:\n1 DBCS characters start with a shift-out character X'0E' and end with a shift-in character X'0F'.\n790  CICS TS for z/OS: API Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "XRBA\nspecifies that the record identification field specified in the RIDFLD option contains an exten", "output": "XRBA\nspecifies that the record identification field specified in the RIDFLD option contains an extended\nrelative byte address. This option should be used when reading records from an ESDS extended\naddressing data set.\nKSDS data sets cannot be accessed by XRBA.\nConditions\n84 DISABLED\nRESP2 values:\n50\nA file is disabled because it was initially defined as disabled and has not since been enabled.\nA file is disabled because it has been disabled by a SET FILE or a CEMT SET FILE command.\nDefault action: terminate the task abnormally.\n15 DUPKEY\nRESP2 values: (VSAM)\n140\nA record is retrieved by way of an alternate index with the NONUNIQUEKEY attribute, and another\nalternate index record with the same key follows\nIn assembler language, if the SET option is being used, the specified register has not been set, but\ncan be loaded from DFHEITP1.\nDefault action: terminate the task abnormally.\n12 FILENOTFOUND\nRESP2 values:\n1\nThe file name supplied in the FILE option is not defined to CICS.\nDefault action: terminate the task abnormally.\n21 ILLOGIC\nRESP2 values: (VSAM)\n110\nA VSAM error occurs that is not in one of the other CICS response categories.\nSee EIBRCODE in the EXEC interface block; for details, see EIB fields.\nFor user-maintained data tables, this condition occurs only for a non-UPDATE READ during loading\nwhen CICS has attempted to retrieve the record from the source data set.\nDefault action: terminate the task abnormally.\n16 INVREQ\nRESP2 values:\n20\nREAD is not allowed according to the resource definition.\nA READ command with the UPDATE option is issued to a file where update operations are not\nallowed according to the resource definition.\n25\nThe KEYLENGTH and GENERIC options are specified, and the length specified in the KEYLENGTH\noption is greater than or equal to the length of a full key.\nChapter 2. CICS command summary  353"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "• Include each contained program in the containing program immediately before the END PROGRAM\nmarker", "output": "• Include each contained program in the containing program immediately before the END PROGRAM\nmarker of the containing program.\n• Use an END PROGRAM marker to terminate contained and containing programs.\nYou cannot use the THREAD option when compiling programs that contain nested programs.\nRelated concepts   \n“Nested programs” on page 581 \nRelated references   \n“Scope of names” on page 582 \nNested programs\nA COBOL program can nest, or contain, other COBOL programs. The nested programs can themselves\ncontain other programs. A nested program can be directly or indirectly contained in a program.\nThere are four main advantages to nesting called programs:\n• Nested programs provide a method for creating modular functions and maintaining structured\nprogramming techniques. They can be used analogously to perform procedures (using the PERFORM\nstatement), but with more structured control flow and with the ability to protect local data items.\n• Nested programs let you debug a program before including it in an application.\n• Nested programs enable you to compile an application with a single invocation of the compiler.\n• Calls to nested programs have the best performance of all the forms of COBOL CALL statements.\nThe following example describes a nested structure that has directly and indirectly contained programs:\n“Example: structure of nested programs” on page 582\nChapter 29. Using subprograms  581"}
{"instruction": "What is An index data item in COBOL?", "input": "", "output": "An index data item is 4-byte elementary item or an 8-byte elementary item depending on whether the\nLP(32) or LP(64) compiler option is in effect, that can be used to save index-name values for future\nreference"}
{"instruction": "What is the header on the\nfirst page of a source listing in COBOL?", "input": "", "output": "the header on the\nfirst page of a source listing is same as that for IBM Enterprise COBOL for z/OS"}
{"instruction": "Explain this COBOL concept", "input": "Table 141. SYSADATA symbol record (continued)\nField\nSize\nDescription\nData flags 4\nXL1\nFor symbols that have a symbol attribute of Numeric (X'01'):\n1... ....\nNumeric national\nFor symbols that have a symbol attribute of Elementary character\n(X'02'):\n1... ....\nNational\n.1.. ....\nNational edited\nFor symbols that have a symbol attribute of Group (X'03'):\n1... ....\nGroup-Usage National\n.1.. ....\nUnbounded length group\nData flags 5\nXL1\nOCCURS flags:\n1... ....\nUNBOUNDED\nBase locator Cell\nFL2\nBase locator cell number\nSymbol Identifier\nFL4\nNumber identifying the symbol\nStructure displacement\nAL4\nOffset of symbol within structure. This offset is set to 0 for variably\nlocated items.\nParent displacement\nAL4\nByte offset from immediate parent of the item being defined.\nParent ID\nFL4\nThe symbol ID of the immediate parent of the item being defined.\nRedefined ID\nFL4\nThe symbol ID of the data item that this item redefines, if\napplicable.\nStart-renamed ID\nFL4\nIf this item is a level-66 item, the symbol ID of the starting COBOL\ndata item that this item renames. If not a level-66 item, this field is\nset to 0.\nEnd-renamed ID\nFL4\nIf this item is a level-66 item, the symbol ID of the ending COBOL\ndata item that this item renames. If not a level-66 item, this field is\nset to 0.\nProgram-name symbol\nID\nFL4\nID of the program-name of the program or the class-name of the\nclass where this symbol is defined.\nOCCURS minimum\nParagraph ID\nFL4\nMinimum value for OCCURS\nProc-name ID for a paragraph-name\nOCCURS maximum\nSection ID\nFL4\nMaximum value for OCCURS\nProc-name ID for a section-name\nDimensions\nFL4\nNumber of dimensions\nAppendix G. COBOL SYSADATA file contents  963", "output": "Table 141. SYSADATA symbol record (continued)\nField\nSize\nDescription\nData flags 4\nXL1\nFor symbols that have a symbol attribute of Numeric (X'01'):\n1... ....\nNumeric national\nFor symbols that have a symbol attribute of Elementary character\n(X'02'):\n1... ....\nNational\n.1.. ....\nNational edited\nFor symbols that have a symbol attribute of Group (X'03'):\n1... ....\nGroup-Usage National\n.1.. ....\nUnbounded length group\nData flags 5\nXL1\nOCCURS flags:\n1... ....\nUNBOUNDED\nBase locator Cell\nFL2\nBase locator cell number\nSymbol Identifier\nFL4\nNumber identifying the symbol\nStructure displacement\nAL4\nOffset of symbol within structure. This offset is set to 0 for variably\nlocated items.\nParent displacement\nAL4\nByte offset from immediate parent of the item being defined.\nParent ID\nFL4\nThe symbol ID of the immediate parent of the item being defined.\nRedefined ID\nFL4\nThe symbol ID of the data item that this item redefines, if\napplicable.\nStart-renamed ID\nFL4\nIf this item is a level-66 item, the symbol ID of the starting COBOL\ndata item that this item renames. If not a level-66 item, this field is\nset to 0.\nEnd-renamed ID\nFL4\nIf this item is a level-66 item, the symbol ID of the ending COBOL\ndata item that this item renames. If not a level-66 item, this field is\nset to 0.\nProgram-name symbol\nID\nFL4\nID of the program-name of the program or the class-name of the\nclass where this symbol is defined.\nOCCURS minimum\nParagraph ID\nFL4\nMinimum value for OCCURS\nProc-name ID for a paragraph-name\nOCCURS maximum\nSection ID\nFL4\nMaximum value for OCCURS\nProc-name ID for a section-name\nDimensions\nFL4\nNumber of dimensions\nAppendix G. COBOL SYSADATA file contents  963"}
{"instruction": "What is the syntax for this COBOL construct?", "input": "checked, but has no effect on the execution of the program.", "output": "checked, but has no effect on the execution of the program."}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Conditions\n123 CCSIDERR\nRESP2 values are:\n13\nAn invalid CCSID has been specified.\n14\nAn unsupported ", "output": "Conditions\n123 CCSIDERR\nRESP2 values are:\n13\nAn invalid CCSID has been specified.\n14\nAn unsupported CCSID has been specified.\n122 CHANNELERR\nRESP2 values are:\n3\nThe channel where this SOAPFAULT object is being created is read-only.\n16 INVREQ\nRESP2 values are:\n3\nThe command was issued outside the environment of a CICS-supplied SOAP handler.\n11\nThe FAULTCODE specified is invalid or FAULTCODESTR was specified for a SOAP 1.2. fault.\n13\nThe DETAIL option does not contain valid namespace-qualified XML or whitespace.\n22 LENGERR\nRESP2 values are:\n5\nThe FAULTCODELEN value is invalid\n6\nThe FAULTSTRLEN value is invalid\n7\nThe ROLELENGTH value is invalid\n8\nThe FAULTACTLEN value is invalid\n9\nThe DETAILLENGTH value is invalid\nSOAPFAULT DELETE\nDeletes an existing SOAPFAULT object. You can use it only in a program that is invoked from a CICS-\nsupplied SOAP message handler.\nSOAPFAULT DELETE\nSOAPFAULT DELETE\nConditions: CHANNELERR, INVREQ, NOTFND\nThis command is threadsafe.\nDescription\nThis command deletes a SOAPFAULT object that was created with an earlier SOAPFAULT CREATE\ncommand.\nThis command requires information that is held in containers on the channel of the supplied SOAP\nmessage handler. To use this command, you must have access to the channel. Only the following types of\nprograms have this access:\n• Programs that are invoked as SOAP header handlers\n506  CICS TS for z/OS: API Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "13\nThe request timed out. It may be that another task using this process-record has been prevented\nf", "output": "13\nThe request timed out. It may be that another task using this process-record has been prevented\nfrom ending.\n33\nThe process specified on the PROCESS option has not yet been committed.\nINQUIRE EVENT\nRetrieve the attributes of a BTS event.\nINQUIRE EVENT\nINQUIRE\nEVENT( data-value )\nACTIVITYID(  data-value )\nEVENTTYPE(  cvda)\nFIRESTATUS(  cvda)\nCOMPOSITE(  data-area )\nPREDICATE(  cvda)\nTIMER(  data-area )\nConditions: ACTIVITYERR, EVENTERR, INVREQ, IOERR, NOTAUTH\nDescription\nINQUIRE EVENT returns the attributes of a named BTS event.\nTo inquire upon an event associated with the current activity, omit the ACTIVITYID option. To inquire upon\nan event associated with another activity, specify the ACTIVITYID option. (The activity identifier specified\non the ACTIVITYID option may, for example, have been returned on a GETNEXT ACTIVITY command\nduring a browse operation.)\nOptions\nACTIVITYID(data-value)\nspecifies the identifier (1–52 characters) of the activity which the event is associated with.\nIf this option is omitted, the current activity is assumed.\nCOMPOSITE(data-area)\nreturns, if the named event is a sub-event, the 16-character name of the composite event that it is\npart of.\nEVENT(data-value)\nspecifies the name (1–16 characters) of the event being inquired upon.\nEVENTTYPE(cvda)\nindicates the type of the named event. CVDA values are:\nACTIVITY\nActivity completion\nCOMPOSITE\nComposite\nINPUT\nInput\nSYSTEM\nSystem\n256  CICS TS for z/OS: API Reference"}
{"instruction": "Explain this COBOL concept", "input": "• Literals are listed as a type of operand only in the first column. They do not appear as column headings\nbecause literals cannot be used as both operands of a relation condition.\nTable 23. Comparisons involving data items and literals\nType of data item or literal\nAlpha-\nnumeric\ngroup\nitems\nAlpha-\nbetic and\nalpha-\nnumeric\ncharacte\nr items\nZoned\ndecimal\nitems\nNative\nnumeri\nc items\nAlpha-\nnumeric\nfloating-\npoint\nitems\nNational\ncharacte\nr items\nNational\ndecimal\nitems\nNational\nfloating-\npoint\nitems\nDBC\nS\nitem\ns\nUTF-\n8\nchar\nacter\nitem\ns\nAlphanumeric group item\nGroup\nGroup\nGroup\n(Int)\n \nGroup\nGroup\nGroup\n(Int)\nGroup\nGrou\np\nGrou\np\nAlphabetic data items\nGroup\nAlph\nAlph\n(Int)\n \nAlph\nNat\nAlph (Int)\nNat\n \nAlphanumeric character\nitems:\n• Data items of category:\n–\nAlphanumeric\n–\nAlphanumeric- edited\n–\nNumeric-edited with\nusage DISPLAY\n• Alphanumeric functions\nGroup\nAlph\nAlph\n(Int)\n \nAlph\nNat\nAlph (Int)\nNat\n \nUTF-\n8\nAlphanumeric literals\nGroup\nAlph\nAlph\n(Int)\n \nAlph\nNat\nAlph (Int)\nNat\n \nUTF-\n8\nNumeric literals\nGroup\n(Int)\nAlph (Int)\nNum\nNum\nNum\nNat (Int)\nNum\nNum\n \nZoned decimal data items\nGroup\n(Int)\nAlph (Int)\nNum\nNum\nNum\nNat (Int)\nNum\nNum\n \nNative numeric items:\n• Binary\n• Arithmetic expression\n• Internal decimal\n• Internal floating point\nNumeric and integer intrinsic\nfunctions\nNum\nNum\nNum\nNum\nNum\nDisplay floating-point items\nGroup\nAlph\nNum\nNum\nNum\nNat\nNum\nNum\n \nFloating-point literals\n \n \nNum\nNum\nNum\n \nNum\nNum\n \nNational character items:\n• Data items of category:\n–\nNational\n–\nNational- edited\n–\nNumeric- edited with\nusage NATIONAL\n• National intrinsic functions\n• National groups (treated as\nelementary item)\nGroup\nNat\nNat\n(Int)\n \nNat\nNat\nNat (Int)\nNat\nNat\nGrou\np\nNational literals\nGroup\nNat\nNat\n(Int)\n \nNat\nNat\nNat (Int)\nNat\nNat \nUTF-\n8\nNational decimal items\nGroup\n(Int)\nAlph (Int)\nNum\nNum\nNum\nNat (Int)\nNum\nNum\n \nNational floating-point items\nGroup\nNat\nNum\nNum\nNum\nNat\nNum\nNum\n \nChapter 27. Procedure division structure  281", "output": "• Literals are listed as a type of operand only in the first column. They do not appear as column headings\nbecause literals cannot be used as both operands of a relation condition.\nTable 23. Comparisons involving data items and literals\nType of data item or literal\nAlpha-\nnumeric\ngroup\nitems\nAlpha-\nbetic and\nalpha-\nnumeric\ncharacte\nr items\nZoned\ndecimal\nitems\nNative\nnumeri\nc items\nAlpha-\nnumeric\nfloating-\npoint\nitems\nNational\ncharacte\nr items\nNational\ndecimal\nitems\nNational\nfloating-\npoint\nitems\nDBC\nS\nitem\ns\nUTF-\n8\nchar\nacter\nitem\ns\nAlphanumeric group item\nGroup\nGroup\nGroup\n(Int)\n \nGroup\nGroup\nGroup\n(Int)\nGroup\nGrou\np\nGrou\np\nAlphabetic data items\nGroup\nAlph\nAlph\n(Int)\n \nAlph\nNat\nAlph (Int)\nNat\n \nAlphanumeric character\nitems:\n• Data items of category:\n–\nAlphanumeric\n–\nAlphanumeric- edited\n–\nNumeric-edited with\nusage DISPLAY\n• Alphanumeric functions\nGroup\nAlph\nAlph\n(Int)\n \nAlph\nNat\nAlph (Int)\nNat\n \nUTF-\n8\nAlphanumeric literals\nGroup\nAlph\nAlph\n(Int)\n \nAlph\nNat\nAlph (Int)\nNat\n \nUTF-\n8\nNumeric literals\nGroup\n(Int)\nAlph (Int)\nNum\nNum\nNum\nNat (Int)\nNum\nNum\n \nZoned decimal data items\nGroup\n(Int)\nAlph (Int)\nNum\nNum\nNum\nNat (Int)\nNum\nNum\n \nNative numeric items:\n• Binary\n• Arithmetic expression\n• Internal decimal\n• Internal floating point\nNumeric and integer intrinsic\nfunctions\nNum\nNum\nNum\nNum\nNum\nDisplay floating-point items\nGroup\nAlph\nNum\nNum\nNum\nNat\nNum\nNum\n \nFloating-point literals\n \n \nNum\nNum\nNum\n \nNum\nNum\n \nNational character items:\n• Data items of category:\n–\nNational\n–\nNational- edited\n–\nNumeric- edited with\nusage NATIONAL\n• National intrinsic functions\n• National groups (treated as\nelementary item)\nGroup\nNat\nNat\n(Int)\n \nNat\nNat\nNat (Int)\nNat\nNat\nGrou\np\nNational literals\nGroup\nNat\nNat\n(Int)\n \nNat\nNat\nNat (Int)\nNat\nNat \nUTF-\n8\nNational decimal items\nGroup\n(Int)\nAlph (Int)\nNum\nNum\nNum\nNat (Int)\nNum\nNum\n \nNational floating-point items\nGroup\nNat\nNum\nNum\nNum\nNat\nNum\nNum\n \nChapter 27. Procedure division structure  281"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "BIF DIGEST\nCalculate the SHA-1 digest of a string of data.\nBIF DIGEST\nBIF\nDIGEST\nRECORD( data-value ", "output": "BIF DIGEST\nCalculate the SHA-1 digest of a string of data.\nBIF DIGEST\nBIF\nDIGEST\nRECORD( data-value )\nRECORDLEN(  data-value )\nHEX\nBINARY\nBASE64\nDIGESTTYPE(  cvda)\nRESULT(  data-area )\nConditions: INVREQ, LENGERR\nThis command is threadsafe.\nDescription\nThe BIF DIGEST command is a CICS built-in function that calculates the SHA-1 digest of a string of data.\nThe result can be returned as binary (20 bytes long), hexadecimal (40 bytes long), or base64-encoded\n(28 bytes long). The SHA-1 digest is a cryptographically strong checksum of the string, so for practical\npurposes it is unique for each string.\nThis command uses z/Architecture® message security assist (MSA) functions that require z Systems\ncryptographic hardware with CP Assist for Cryptographic Functions (CPACF). For more information, see\nz/OS Cryptographic Services ICSF Overview.\nOptions\nRECORD(data-value)\nThis option specifies the string of data for which the digest is to be calculated.\nRECORDLEN(data-value)\nThis option specifies the length, as a fullword binary value, of the data string.\nDIGESTTYPE(cvda)\nThis option specifies the format in which the digest is returned.\nHEX\nHexadecimal, which produces a result 40 bytes long, encoded as hexadecimal characters (0 - 9, A\n- F).\nBINARY\nBinary, which produces a result 20 bytes long.\nBASE64\nBase64 encoding, which produces a result 28 bytes long, by using the characters A - Z, a - z, 0 - 9,\n+, /, =.\nRESULT(data-area)\nThis option returns the SHA-1 digest of the data string in the format that is specified by the\nDIGESTTYPE option. The length of the result depends on the requested format.\nConditions\n16 INVREQ\nRESP2 values:\n1\nDIGESTTYPE has an invalid CVDA value.\nChapter 2. CICS command summary  57"}
{"instruction": "Summarize this COBOL documentation section", "input": "KEEP\nFor an INPUT report, KEEP specifies that the report is to be read again when SPOOLOPEN INPUT is\nnext issued.\nFor an OUTPUT report, KEEP specifies that the report is to be sent to its destination node.\nTOKEN(data-area)\nspecifies the 8-character CICS-allocated token used to identify a report.\nConditions\nNote: There are no default actions.\n85 ALLOCERR\noccurs in any of the following situations:\n• Dynamic allocation has rejected a request to allocate an input data set.\nRESP2 gives the dynamic allocation response code that denotes this error. The first two characters\nare the information reason code (S99INFO), and the second two are the error reason code\n(S99ERROR), as defined in the z/OS MVS Programming: Authorized Assembler Services Guide.\n16 INVREQ\nRESP2 values:\n4\nUnsupported language.\n8\nUnsupported function.\n40\nSubsystem interface already enabled.\nNote: Errors 1024 and over are internal, and should not occur. If one of these error codes is\nreturned, contact your IBM support center.\n80 NOSPOOL\nRESP2 values:\n4\nNo subsystem present.\n8\nInterface being disabled; CICS is quiescing.\n12\nInterface has been stopped.\n42 NOSTG\noccurs in any of the following situations:\n• A GETMAIN has failed within the JES interface subtask (DFHPSPSS).\nRESP2 gives the GETMAIN register 15 return code.\n13 NOTFND\nRESP2 values:\n1024\nInput or output function has been corrupted, and SPOOLCLOSE could not complete.\n19 NOTOPEN\nRESP2 values:\n8\nData set has not been opened.\n86 STRELERR\noccurs in any of the following situations:\n508  CICS TS for z/OS: API Reference", "output": "KEEP\nFor an INPUT report, KEEP specifies that the report is to be read again when SPOOLOPEN INPUT is\nnext issued.\nFor an OUTPUT report, KEEP specifies that the report is to be sent to its destination node.\nTOKEN(data-area)\nspecifies the 8-character CICS-allocated token used to identify a report.\nConditions\nNote: There are no default actions.\n85 ALLOCERR\noccurs in any of the following situations:\n• Dynamic allocation has rejected a request to allocate an input data set.\nRESP2 gives the dynamic allocation response code that denotes this error. The first two characters\nare the information reason code (S99INFO), and the second two are the error reason code\n(S99ERROR), as defined in the z/OS MVS Programming: Authorized Assembler Services Guide.\n16 INVREQ\nRESP2 values:\n4\nUnsupported language.\n8\nUnsupported function.\n40\nSubsystem interface already enabled.\nNote: Errors 1024 and over are internal, and should not occur. If one of these error codes is\nreturned, contact your IBM support center.\n80 NOSPOOL\nRESP2 values:\n4\nNo subsystem present.\n8\nInterface being disabled; CICS is quiescing.\n12\nInterface has been stopped.\n42 NOSTG\noccurs in any of the following situations:\n• A GETMAIN has failed within the JES interface subtask (DFHPSPSS).\nRESP2 gives the GETMAIN register 15 return code.\n13 NOTFND\nRESP2 values:\n1024\nInput or output function has been corrupted, and SPOOLCLOSE could not complete.\n19 NOTOPEN\nRESP2 values:\n8\nData set has not been opened.\n86 STRELERR\noccurs in any of the following situations:\n508  CICS TS for z/OS: API Reference"}
{"instruction": "Explain this COBOL concept", "input": "Table 83. IBM extension language elements (continued)\nLanguage area\nExtension elements\nIntrinsic functions\nThe effect of the INTDATE compiler options on the INTEGER-OF-DATE\nand INTEGER-OF-DAY functions\nThe following functions:\n• Chapter 36, “BIT-OF,” on page 537\n• Chapter 37, “BIT-TO-CHAR,” on page 539\n• Chapter 45, “DATE-TO-YYYYMMDD,” on page 555\n• Chapter 47, “DAY-TO-YYYYDDD,” on page 559\n• Chapter 48, “DISPLAY-OF,” on page 561\n• Chapter 57, “HEX-OF,” on page 579\n• Chapter 58, “HEX-TO-CHAR,” on page 581\n• Chapter 74, “NATIONAL-OF,” on page 613\n• ULENGTH\n• UPOS\n• USUBSTR\n• USUPPLEMENTARY\n• Chapter 107, “UUID4,” on page 679\n• UVALID\n• UWIDTH\n• Chapter 112, “YEAR-TO-YYYY,” on page 691\nFACTORIAL function\nThe effect of the ARITH(EXTEND) compiler option on the range of\nvalues permitted in the argument\nLENGTH function\nSpecifying a pointer, the ADDRESS OF special register, or the LENGTH\nOF special register as an argument to the function\nNUMVAL function\nThe effect of the ARITH(EXTEND) compiler option on the maximum\nnumber of digits allowed in the argument\nNUMVAL-C function\nThe effect of the ARITH(EXTEND) compiler option on the maximum\nnumber of digits allowed in the argument\nNUMVAL-F function\nThe effect of the ARITH(EXTEND) compiler option on the maximum\nnumber of digits allowed in the argument\nTEST-NUMVAL function\nThe effect of the ARITH(EXTEND) compiler option on the maximum\nnumber of digits allowed in the argument\nTEST-NUMVAL-C function\nThe effect of the ARITH(EXTEND) compiler option on the maximum\nnumber of digits allowed in the argument\nTEST-NUMVAL-F function\nThe effect of the ARITH(EXTEND) compiler option on the maximum\nnumber of digits allowed in the argument\n758  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "Table 83. IBM extension language elements (continued)\nLanguage area\nExtension elements\nIntrinsic functions\nThe effect of the INTDATE compiler options on the INTEGER-OF-DATE\nand INTEGER-OF-DAY functions\nThe following functions:\n• Chapter 36, “BIT-OF,” on page 537\n• Chapter 37, “BIT-TO-CHAR,” on page 539\n• Chapter 45, “DATE-TO-YYYYMMDD,” on page 555\n• Chapter 47, “DAY-TO-YYYYDDD,” on page 559\n• Chapter 48, “DISPLAY-OF,” on page 561\n• Chapter 57, “HEX-OF,” on page 579\n• Chapter 58, “HEX-TO-CHAR,” on page 581\n• Chapter 74, “NATIONAL-OF,” on page 613\n• ULENGTH\n• UPOS\n• USUBSTR\n• USUPPLEMENTARY\n• Chapter 107, “UUID4,” on page 679\n• UVALID\n• UWIDTH\n• Chapter 112, “YEAR-TO-YYYY,” on page 691\nFACTORIAL function\nThe effect of the ARITH(EXTEND) compiler option on the range of\nvalues permitted in the argument\nLENGTH function\nSpecifying a pointer, the ADDRESS OF special register, or the LENGTH\nOF special register as an argument to the function\nNUMVAL function\nThe effect of the ARITH(EXTEND) compiler option on the maximum\nnumber of digits allowed in the argument\nNUMVAL-C function\nThe effect of the ARITH(EXTEND) compiler option on the maximum\nnumber of digits allowed in the argument\nNUMVAL-F function\nThe effect of the ARITH(EXTEND) compiler option on the maximum\nnumber of digits allowed in the argument\nTEST-NUMVAL function\nThe effect of the ARITH(EXTEND) compiler option on the maximum\nnumber of digits allowed in the argument\nTEST-NUMVAL-C function\nThe effect of the ARITH(EXTEND) compiler option on the maximum\nnumber of digits allowed in the argument\nTEST-NUMVAL-F function\nThe effect of the ARITH(EXTEND) compiler option on the maximum\nnumber of digits allowed in the argument\n758  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What are the compiler rules or directives for this?", "input": "in effect.\n• Characters appearing in literal-1 will be matched to the JSON names in a case-sensitive manner, unlike", "output": "in effect.\n• Characters appearing in literal-1 will be matched to the JSON names in a case-sensitive manner, unlike"}
{"instruction": "What are the compiler rules or directives for this?", "input": "data in any code page (including CCSID 1388 or 1392) by converting the data to", "output": "data in any code page (including CCSID 1388 or 1392) by converting the data to"}
{"instruction": "Explain this COBOL concept", "input": "• Utilities\nz/OS DFSORT\n• Application Programming Guide\n• Installation and Customization\nz/OS ISPF\n• Dialog Developer's Guide and Reference\n• User's Guide Vol I\n• User's Guide Vol II\nz/OS Language Environment\n• Concepts Guide\n• Customization\n• Debugging Guide\n• Language Environment Vendor Interfaces\n• Programming Guide\n• Programming Reference\n• Run-Time Messages\n• Run-Time Application Migration Guide\n• Writing Interlanguage Communication Applications\nz/OS MVS\n• JCL Reference\n• JCL User's Guide\n• Programming: Callable Services for High-Level Languages\n• Program Management: User's Guide and Reference\n• System Commands\n• z/OS Unicode Services User's Guide and Reference\n• z/OS XML System Services User's Guide and Reference\nz/OS TSO/E\n• Command Reference\n• Primer\n• User's Guide\nz/OS UNIX System Services\n• Command Reference\n• Programming: Assembler Callable Services Reference\n• User's Guide\nz/OS XL C/C++\n• Programming Guide\n• Run-Time Library Reference\nCICS Transaction Server for z/OS\nYou can find the following publications in the CICS library:\n• Developing CICS Applications\n858  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "• Utilities\nz/OS DFSORT\n• Application Programming Guide\n• Installation and Customization\nz/OS ISPF\n• Dialog Developer's Guide and Reference\n• User's Guide Vol I\n• User's Guide Vol II\nz/OS Language Environment\n• Concepts Guide\n• Customization\n• Debugging Guide\n• Language Environment Vendor Interfaces\n• Programming Guide\n• Programming Reference\n• Run-Time Messages\n• Run-Time Application Migration Guide\n• Writing Interlanguage Communication Applications\nz/OS MVS\n• JCL Reference\n• JCL User's Guide\n• Programming: Callable Services for High-Level Languages\n• Program Management: User's Guide and Reference\n• System Commands\n• z/OS Unicode Services User's Guide and Reference\n• z/OS XML System Services User's Guide and Reference\nz/OS TSO/E\n• Command Reference\n• Primer\n• User's Guide\nz/OS UNIX System Services\n• Command Reference\n• Programming: Assembler Callable Services Reference\n• User's Guide\nz/OS XL C/C++\n• Programming Guide\n• Run-Time Library Reference\nCICS Transaction Server for z/OS\nYou can find the following publications in the CICS library:\n• Developing CICS Applications\n858  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "Summarize this COBOL documentation section", "input": "Table 14. Data categories (continued)\nData category\nType of editing\nInsertion symbol\nAlphanumeric\nNone\nNone\nAlphanumeric-edited\nSimple insertion\nB 0 /\nDBCS\nSimple insertion\nB\nExternal floating-point\nSpecial insertion\n.\nNational\nNone\nNone\nNational-edited\nSimple insertion\nB 0 /\nNumeric\nNone\nNone\nNumeric-edited\nSimple insertion\nSpecial insertion\nFixed insertion\nFloating insertion\nZero suppression\nReplacement\nB 0 / ,\n.\ncs + - CR DB\ncs + -\nZ *\nZ * + - cs\nUTF-8\nNone\nNone\nTypes of editing are described in the following sections:\n• “Simple insertion editing” on page 224\n• “Special insertion editing” on page 225\n• “Fixed insertion editing” on page 225\n• “Floating insertion editing” on page 226\n• “Zero suppression and replacement editing” on page 228\nSimple insertion editing\nThis type of editing is valid for alphanumeric-edited, numeric-edited, and DBCS items.\nEach insertion symbol is counted in the size of the item, and represents the position within the item where\nthe equivalent character is to be inserted. For edited DBCS items, each insertion symbol (B) is counted in\nthe size of the item and represents the position within the item where the DBCS space is to be inserted.\nFor example:\nPICTURE\nValue of data\nEdited result\nX(10)/XX\nALPHANUMER01\nALPHANUMER/01\nX(5)BX(7)\nALPHANUMERIC\nALPHA NUMERIC\n99,B999,B000\n1234\n01,b234,b0001\n99,999\n12345\n12,345\nGGBBGG\nD1D2D3D4\nD1D2bbbbD3D41\nNotes:\n1. The symbol b represents a space.\n224  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "Table 14. Data categories (continued)\nData category\nType of editing\nInsertion symbol\nAlphanumeric\nNone\nNone\nAlphanumeric-edited\nSimple insertion\nB 0 /\nDBCS\nSimple insertion\nB\nExternal floating-point\nSpecial insertion\n.\nNational\nNone\nNone\nNational-edited\nSimple insertion\nB 0 /\nNumeric\nNone\nNone\nNumeric-edited\nSimple insertion\nSpecial insertion\nFixed insertion\nFloating insertion\nZero suppression\nReplacement\nB 0 / ,\n.\ncs + - CR DB\ncs + -\nZ *\nZ * + - cs\nUTF-8\nNone\nNone\nTypes of editing are described in the following sections:\n• “Simple insertion editing” on page 224\n• “Special insertion editing” on page 225\n• “Fixed insertion editing” on page 225\n• “Floating insertion editing” on page 226\n• “Zero suppression and replacement editing” on page 228\nSimple insertion editing\nThis type of editing is valid for alphanumeric-edited, numeric-edited, and DBCS items.\nEach insertion symbol is counted in the size of the item, and represents the position within the item where\nthe equivalent character is to be inserted. For edited DBCS items, each insertion symbol (B) is counted in\nthe size of the item and represents the position within the item where the DBCS space is to be inserted.\nFor example:\nPICTURE\nValue of data\nEdited result\nX(10)/XX\nALPHANUMER01\nALPHANUMER/01\nX(5)BX(7)\nALPHANUMERIC\nALPHA NUMERIC\n99,B999,B000\n1234\n01,b234,b0001\n99,999\n12345\n12,345\nGGBBGG\nD1D2D3D4\nD1D2bbbbD3D41\nNotes:\n1. The symbol b represents a space.\n224  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What is name in COBOL?", "input": "", "output": "name is alphanumeric literal, the underscore character can be the first character"}
{"instruction": "Explain this COBOL concept", "input": "DFHMSD Minimum BMS\nmapset\nDFHMSD\nTYPE\n=\nDSECT\nMAP\nFINAL\n,\nMODE\n=\nOUT\nIN\nINOUT\nFOLD\n=\nLOWER\nUPPER\nTRIGRAPH\n=\nNO\nYES\nLANG\n=\nASM\nCOBOL\nCOBOL2\nPLI\nC\nSTORAGE\n=\nAUTO\nBASE\n=\nname\nCTRL\n=\n(\n,\nPRINT\nlength\nFREEKB\nALARM\nFRSET\n)\nEXTATT\n=\nNO\nMAPONLY\nYES\nCOLOR\n=\nDEFAULT\ncolor\nDSECT\n=\nADS\nADSL\n,\nCURSLOC\n=\nNO\nYES\nHILIGHT\n=\nOFF\nBLINK\nREVERSE\nUNDERLINE\nPS\n=\nBASE\npsid\nVALIDN\n=\n,\nMUSTFILL\nMUSTENTER\nTRIGGER\nUSEREXIT\nTERM\n=\ntype\nSUFFIX\n=\nn\nTIOAPFX\n=\nNO\nYES\n,\nMAPATTS\n=\n(\nattr\n)\n,\nDSATTS\n=\n(\nattr\n)\nOUTLINE\n=\nBOX\n(\n,\nLEFT\nRIGHT\nOVER\nUNDER\n)\nSOSI\n=\nNO\nYES\nTRANSP\n=\nYES\nNO\nChapter 9. BMS macros  809", "output": "DFHMSD Minimum BMS\nmapset\nDFHMSD\nTYPE\n=\nDSECT\nMAP\nFINAL\n,\nMODE\n=\nOUT\nIN\nINOUT\nFOLD\n=\nLOWER\nUPPER\nTRIGRAPH\n=\nNO\nYES\nLANG\n=\nASM\nCOBOL\nCOBOL2\nPLI\nC\nSTORAGE\n=\nAUTO\nBASE\n=\nname\nCTRL\n=\n(\n,\nPRINT\nlength\nFREEKB\nALARM\nFRSET\n)\nEXTATT\n=\nNO\nMAPONLY\nYES\nCOLOR\n=\nDEFAULT\ncolor\nDSECT\n=\nADS\nADSL\n,\nCURSLOC\n=\nNO\nYES\nHILIGHT\n=\nOFF\nBLINK\nREVERSE\nUNDERLINE\nPS\n=\nBASE\npsid\nVALIDN\n=\n,\nMUSTFILL\nMUSTENTER\nTRIGGER\nUSEREXIT\nTERM\n=\ntype\nSUFFIX\n=\nn\nTIOAPFX\n=\nNO\nYES\n,\nMAPATTS\n=\n(\nattr\n)\n,\nDSATTS\n=\n(\nattr\n)\nOUTLINE\n=\nBOX\n(\n,\nLEFT\nRIGHT\nOVER\nUNDER\n)\nSOSI\n=\nNO\nYES\nTRANSP\n=\nYES\nNO\nChapter 9. BMS macros  809"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "The above example produces the following display output:\nDeposit in euro  =  EUR 8000.00\nDeposit in ", "output": "The above example produces the following display output:\nDeposit in euro  =  EUR 8000.00\nDeposit in franc = CHF 12311.44\nThe exchange rate used in this example is for illustrative purposes only.\n72  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What are the compiler rules or directives for this?", "input": "causes BTS to invoke the process's root activity and send it an input event. If the root", "output": "causes BTS to invoke the process's root activity and send it an input event. If the root"}
{"instruction": "What is 1 in COBOL?", "input": "", "output": "1 is name of the file in your program"}
{"instruction": "Summarize this COBOL documentation section", "input": "Table 137. SYSADATA token record (continued)\nField\nSize\nDescription\n \n \n0514\nFILLER\n0516\nFOOTING\n0520\nLABEL\n0521\nLENGTH\n0524\nLINAGE\n0526\nOMITTED\n0531\nRENAMES\n0543\nTOP\n0545\nTRAILING\n0549\nRECORDING\n0500\nPOINTER-32\n0551\nBYTE-LENGTH\n0555\nLIMIT\n0601\nINHERITS\n0603\nRECURSIVE\n0604\nPROTOTYPE\n940  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "Table 137. SYSADATA token record (continued)\nField\nSize\nDescription\n \n \n0514\nFILLER\n0516\nFOOTING\n0520\nLABEL\n0521\nLENGTH\n0524\nLINAGE\n0526\nOMITTED\n0531\nRENAMES\n0543\nTOP\n0545\nTRAILING\n0549\nRECORDING\n0500\nPOINTER-32\n0551\nBYTE-LENGTH\n0555\nLIMIT\n0601\nINHERITS\n0603\nRECURSIVE\n0604\nPROTOTYPE\n940  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "Explain this COBOL concept", "input": "IF FUNCTION MOD(JSON-STATUS 2 * code) / code = 1\n    DISPLAY 'JSON-STATUS condition ' code ' occurred.'\n  END-IF\nwhere code is one of the individual JSON-STATUS codes.\nThe runtime messages are issued only if the WITH DETAIL phrase was specified on the JSON PARSE\nstatement. Special registers JSON-STATUS and JSON-CODE are always set.\nNonexception conditions and corresponding values of JSON-STATUS\nTable 112. Reason codes for JSON nonexception conditions\nReason code in the JSON-STATUS register\nDescription\n1\nOne or more data items had no matching JSON\nname/value pair, and thus were not changed.\n2\nOne or more JSON name/value pairs did not match\nany data item.\n4\nOne or more data items had multiple matching\nJSON name/value pairs with duplicate values.\n8\nOne or more table data items had more elements\nthan the matching JSON array.\n16\nOne or more JSON arrays had more values than the\nmatching data item.\n32\nOne or more data items were not changed because\nthe corresponding JSON name/value pair had the\nvalue null.\n64\nOne or more table data items had elements that\nwere not changed because the corresponding\nJSON value was null.\n128\nA \"SIZE ERROR\" condition was detected in one or\nmore numeric assignments. The data items were\nmodified anyway.\n256\nA loss of information occurred in one or more\nalphanumeric assignments. The data items were\nmodified anyway.\n512\nOne or more JSON name/value pairs had a\nvalue that resulted in one or more substitution\ncharacters when translated from Unicode to\nthe CCSID specified by the CODEPAGE compiler\noption.\nException conditions, and corresponding values of JSON-CODE\nTable 113. Reason codes for JSON exception conditions\nReason code in the JSON-CODE register\nDescription\n100\nThe JSON text was invalid.\n101\nThe JSON text was zero-length, or consisted only\nof whitespace.\n846  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "IF FUNCTION MOD(JSON-STATUS 2 * code) / code = 1\n    DISPLAY 'JSON-STATUS condition ' code ' occurred.'\n  END-IF\nwhere code is one of the individual JSON-STATUS codes.\nThe runtime messages are issued only if the WITH DETAIL phrase was specified on the JSON PARSE\nstatement. Special registers JSON-STATUS and JSON-CODE are always set.\nNonexception conditions and corresponding values of JSON-STATUS\nTable 112. Reason codes for JSON nonexception conditions\nReason code in the JSON-STATUS register\nDescription\n1\nOne or more data items had no matching JSON\nname/value pair, and thus were not changed.\n2\nOne or more JSON name/value pairs did not match\nany data item.\n4\nOne or more data items had multiple matching\nJSON name/value pairs with duplicate values.\n8\nOne or more table data items had more elements\nthan the matching JSON array.\n16\nOne or more JSON arrays had more values than the\nmatching data item.\n32\nOne or more data items were not changed because\nthe corresponding JSON name/value pair had the\nvalue null.\n64\nOne or more table data items had elements that\nwere not changed because the corresponding\nJSON value was null.\n128\nA \"SIZE ERROR\" condition was detected in one or\nmore numeric assignments. The data items were\nmodified anyway.\n256\nA loss of information occurred in one or more\nalphanumeric assignments. The data items were\nmodified anyway.\n512\nOne or more JSON name/value pairs had a\nvalue that resulted in one or more substitution\ncharacters when translated from Unicode to\nthe CCSID specified by the CODEPAGE compiler\noption.\nException conditions, and corresponding values of JSON-CODE\nTable 113. Reason codes for JSON exception conditions\nReason code in the JSON-CODE register\nDescription\n100\nThe JSON text was invalid.\n101\nThe JSON text was zero-length, or consisted only\nof whitespace.\n846  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What is Using literals\nA literal in COBOL?", "input": "", "output": "Using literals\nA literal is character string whose value is given by the characters themselves"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "When a paragraph is referred to by an ALTER statement, the paragraph must consist of a paragraph-nam", "output": "When a paragraph is referred to by an ALTER statement, the paragraph must consist of a paragraph-name\nfollowed by an unconditional or altered GO TO statement.\nConditional GO TO\nThe conditional GO TO statement transfers control to one of a series of procedures, depending on the\nvalue of the data item referenced by identifier-1.\nFormat 2: conditional GO TO statement\nGO\nTO\nprocedure-name-1\nDEPENDING\nON\nidentifier-1\nprocedure-name-1\nMust be a procedure or a section in the same PROCEDURE DIVISION as the GO TO statement. The\nnumber of procedure-names must not exceed 255.\nidentifier-1\nMust be a numeric elementary data item that is an integer.\nIf 1, control is transferred to the first statement in the procedure named by the first occurrence of\nprocedure-name-1.\nIf 2, control is transferred to the first statement in the procedure named by the second occurrence of\nprocedure-name-1, and so forth.\nIf the value of identifier is anything other than a value within the range of 1 through n (where n is the\nnumber of procedure-names specified in this GO TO statement), no control transfer occurs. Instead,\ncontrol passes to the next statement in the normal sequence of execution.\nAltered GO TO\nThe altered GO TO statement transfers control to the first statement of the paragraph named in the ALTER\nstatement.\nYou cannot specify the altered GO TO statement in the following cases:\n• A program or method that has the RECURSIVE attribute\n• A program compiled with the THREAD compiler option\nAn ALTER statement referring to the paragraph that contains the altered GO TO statement should be\nexecuted before the GO TO statement is executed. Otherwise, the GO TO statement acts like a CONTINUE\nstatement.\nFormat 3: altered GO TO statement\nparagraph-name\n.\nGO\nTO\n.\nWhen an ALTER statement refers to a paragraph, the paragraph can consist only of the paragraph-name\nfollowed by an unconditional or altered GO TO statement.\n354  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Translated code for CICS commands\nApplication programs can be written in COBOL, C, PL/I, or assemble", "output": "Translated code for CICS commands\nApplication programs can be written in COBOL, C, PL/I, or assembler language, and contain CICS\ncommands. CICS translates these programs and creates an equivalent source program where each\ncommand is now translated into a call macro or statement in the language of the original source program.\nCOBOL translation output\nEXEC CICS commands are converted to calls to the CICS interface DFHEI1.\nThe following example shows how the EXEC statement:\nEXEC CICS RETURN TRANSID('fred')\n     COMMAREA(mycommarea) END-EXEC.\nis translated to:\nMove length of mycommarea to dfhb0020\nCall 'DFHEI1' using by content\n          x'0e08e0000700001000f0f0f0f2f7404040'\n          by content 'fred' by reference mycommarea\n          by reference dfhb0020 end-call.\nCopybook DFHEIBLC\nThis new copybook is a lower case version of the existing DFHEIBLK copybook.\nA difference is that in DFHEIBLK the top level name is\n01 EIBLK.\nwhereas in DFHEIBLC the top level name is\n01 dfheiblk.\nThis is consistent with the name generated by the translator today, and also conforms to the rule that\nCICS reserved words should start with DFH.\nC translation output\nFor a C application program, each command is replaced by reassignment statements followed by a\ndfhexec statement that passes the parameters.\nPL/I translation output\nFor a PL/I application program, each command is always replaced by a DO statement, a declaration of a\ngenerated entry name, a CALL statement, and an END statement. The ENTRY declaration ensures that the\nappropriate conversions for argument values take place.\nIf a PL/I on-unit consists of a single EXEC CICS command, the command should be inside a BEGIN block,\nfor example:\nON ERROR BEGIN;\n         EXEC CICS RETURN;\n         END;\nChapter 1. CICS API command format  11"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 136. SYSADATA parse tree record (continued)\nField\nSize\nDescription\n \n \nFor ENVIRONMENT DIVISIO", "output": "Table 136. SYSADATA parse tree record (continued)\nField\nSize\nDescription\n \n \nFor ENVIRONMENT DIVISION clause type:\n0001\nWITH DEBUGGING MODE\n0002\nMEMORY-SIZE\n0003\nSEGMENT-LIMIT\n0004\nCURRENCY-SIGN\n0005\nDECIMAL POINT\n0006\nPROGRAM COLLATING SEQUENCE\n0007\nALPHABET\n0008\nSYMBOLIC-CHARACTER\n0009\nCLASS\n0010\nENVIRONMENT NAME\n0011\nSELECT\n0012\nXML-SCHEMA\nAppendix G. COBOL SYSADATA file contents  905"}
{"instruction": "What is events that you specify must previously have been defined to the current activity by in COBOL?", "input": "", "output": "events that you specify must previously have been defined to the current activity by is of\nDEFINE INPUT EVENT, DEFINE ACTIVITY, or DEFINE TIMER commands"}
{"instruction": "Summarize this COBOL documentation section", "input": "ROUTE\nROUTE\nINTERVAL(  0)\nINTERVAL(  hhmmss )\nTIME( hhmmss )\nAFTER\nHOURS( data-value )\nMINUTES( data-value )\nSECONDS(  data-value )\nAT\nHOURS( data-value )\nMINUTES( data-value )\nSECONDS(  data-value )\nERRTERM\n( name )\nTITLE( data-area )\nLIST( data-area )\nOPCLASS(  data-area )\nREQID( name )\nLDC( name )\nNLEOM\nConditions: IGREQID, INVERRTERM, INVLDC, INVREQ, RTEFAIL, RTESOME\nDescription\nROUTE routes a BMS logical message to one or more terminals or terminal operators.\nThe default is INTERVAL(0), but for C the default is AFTER HOURS(0) MINUTES(0) SECONDS(0).\nOptions\nAFTER\nspecifies the amount of time to elapse before the route.\nThere are two ways to enter the time under AFTER and AT.\n1. A combination of at least two of HOURS(0–99), MINUTES(0–59), and SECONDS(0–59). HOURS(1)\nSECONDS(3) would mean one hour and three seconds (the minutes default to zero).\n2. As one of HOURS(0–99), MINUTES(0–5999), or SECONDS(0–359 999). HOURS(1) means one\nhour. MINUTES(62) means one hour and two minutes. SECONDS(3723) means one hour, two\nminutes, and three seconds.\nAT\nspecifies the time of the route. For the ways to enter the time, see the AFTER option.\nERRTERM(name)\nspecifies the name of the terminal to be notified if the message is deleted because it is undeliverable.\nThe message number, title identification, and destination are indicated. If no name is specified, the\noriginating terminal is assumed.\nThis option is effective only if PRGDLAY has been specified in the system initialization parameters.\nChapter 2. CICS command summary  437", "output": "ROUTE\nROUTE\nINTERVAL(  0)\nINTERVAL(  hhmmss )\nTIME( hhmmss )\nAFTER\nHOURS( data-value )\nMINUTES( data-value )\nSECONDS(  data-value )\nAT\nHOURS( data-value )\nMINUTES( data-value )\nSECONDS(  data-value )\nERRTERM\n( name )\nTITLE( data-area )\nLIST( data-area )\nOPCLASS(  data-area )\nREQID( name )\nLDC( name )\nNLEOM\nConditions: IGREQID, INVERRTERM, INVLDC, INVREQ, RTEFAIL, RTESOME\nDescription\nROUTE routes a BMS logical message to one or more terminals or terminal operators.\nThe default is INTERVAL(0), but for C the default is AFTER HOURS(0) MINUTES(0) SECONDS(0).\nOptions\nAFTER\nspecifies the amount of time to elapse before the route.\nThere are two ways to enter the time under AFTER and AT.\n1. A combination of at least two of HOURS(0–99), MINUTES(0–59), and SECONDS(0–59). HOURS(1)\nSECONDS(3) would mean one hour and three seconds (the minutes default to zero).\n2. As one of HOURS(0–99), MINUTES(0–5999), or SECONDS(0–359 999). HOURS(1) means one\nhour. MINUTES(62) means one hour and two minutes. SECONDS(3723) means one hour, two\nminutes, and three seconds.\nAT\nspecifies the time of the route. For the ways to enter the time, see the AFTER option.\nERRTERM(name)\nspecifies the name of the terminal to be notified if the message is deleted because it is undeliverable.\nThe message number, title identification, and destination are indicated. If no name is specified, the\noriginating terminal is assumed.\nThis option is effective only if PRGDLAY has been specified in the system initialization parameters.\nChapter 2. CICS command summary  437"}
{"instruction": "Summarize this COBOL documentation section", "input": "Value CVDA\n735 CHUNKNO\n736 CHUNKYES\n737 CHUNKEND\n738 SRVCONVERT\n739 NOSRVCONVERT\n740 REMSESSION\n741 CLOSE\n742 NOCLOSE\n743 CLICONVERT\n744 NOCLICONVERT\n745 NOINCONVERT\n746 NOOUTCONVERT\n747 EXPECT\n748 GET\n749 PUT\n750 HEAD\n751 EXECENQ\n752 EXECENQADDR\n753 OWNER\n754 WAITER\n755 CONNECTION\n756 DATASET\n757 HEURCOMMIT\n758 HEURBACKOUT\n759 OPTIONS\n760 TRACE\n761 RLSSERVER\n762 SHUNTED\n763 WAITCOMMIT\n765 WAITING\n766 WAITRMI\n767 TDQ (TDQUEUE)\n768 TSQ (TSQUEUE)\n770 COORDINATOR\n771 RMI\nChapter 4. CICS-value data areas used by all commands  757", "output": "Value CVDA\n735 CHUNKNO\n736 CHUNKYES\n737 CHUNKEND\n738 SRVCONVERT\n739 NOSRVCONVERT\n740 REMSESSION\n741 CLOSE\n742 NOCLOSE\n743 CLICONVERT\n744 NOCLICONVERT\n745 NOINCONVERT\n746 NOOUTCONVERT\n747 EXPECT\n748 GET\n749 PUT\n750 HEAD\n751 EXECENQ\n752 EXECENQADDR\n753 OWNER\n754 WAITER\n755 CONNECTION\n756 DATASET\n757 HEURCOMMIT\n758 HEURBACKOUT\n759 OPTIONS\n760 TRACE\n761 RLSSERVER\n762 SHUNTED\n763 WAITCOMMIT\n765 WAITING\n766 WAITRMI\n767 TDQ (TDQUEUE)\n768 TSQ (TSQUEUE)\n770 COORDINATOR\n771 RMI\nChapter 4. CICS-value data areas used by all commands  757"}
{"instruction": "What is The EXTRACT PROCESS command is valid only on an APPC conversation that in COBOL?", "input": "", "output": "The EXTRACT PROCESS command is valid only on an APPC conversation that is principal facility for\nthe task"}
{"instruction": "Explain this COBOL concept", "input": "A sequence of separate COBOL programs can also be input to the compiler. The following format is for the\nentries and statements that constitute a sequence of source programs (batch compile).\nFormat: sequence of COBOL source programs\nCOBOL-source-program\nEND PROGRAM program-name\nAn end program marker separates each program in the sequence of programs. program-name must\nbe identical to a program-name declared in a preceding program-ID paragraph.\nprogram-name can be specified either as a user-defined word or in an alphanumeric literal. Either\nway, program-name must follow the rules for forming program-names. program-name cannot be a\nfigurative constant. Any lowercase letters in the literal are folded to uppercase.\nAn end program marker is optional for the last program in the sequence only if that program does not\ncontain any nested source programs.\nNested programs\nA COBOL program can contain other COBOL programs, which in turn can contain still other COBOL\nprograms. These contained programs are called nested programs. Nested programs can be directly or\nindirectly contained in the containing program.\nNested programs are not supported for programs compiled with the THREAD option.\nIn the following code fragment, program Outer-program directly contains program Inner-1. Program\nInner-1 directly contains program Inner-1a, and Outer-program indirectly contains Inner-1a:\nId division.\nProgram-id. Outer-program.\n  Procedure division.\n    Call \"Inner-1\".\n    Stop run.\nId division.\n  Program-id. Inner-1\n  ...\n    Call Inner-1a.\n    Stop run.\n  Id division.\n  Program-id. Inner-1a.\n  ...\n  End Inner-1a.\n  End Inner-1.\nEnd Outer-program.\nThe following figure describes a more complex nested program structure with directly and indirectly\ncontained programs.\nChapter 10. COBOL program structure  87", "output": "A sequence of separate COBOL programs can also be input to the compiler. The following format is for the\nentries and statements that constitute a sequence of source programs (batch compile).\nFormat: sequence of COBOL source programs\nCOBOL-source-program\nEND PROGRAM program-name\nAn end program marker separates each program in the sequence of programs. program-name must\nbe identical to a program-name declared in a preceding program-ID paragraph.\nprogram-name can be specified either as a user-defined word or in an alphanumeric literal. Either\nway, program-name must follow the rules for forming program-names. program-name cannot be a\nfigurative constant. Any lowercase letters in the literal are folded to uppercase.\nAn end program marker is optional for the last program in the sequence only if that program does not\ncontain any nested source programs.\nNested programs\nA COBOL program can contain other COBOL programs, which in turn can contain still other COBOL\nprograms. These contained programs are called nested programs. Nested programs can be directly or\nindirectly contained in the containing program.\nNested programs are not supported for programs compiled with the THREAD option.\nIn the following code fragment, program Outer-program directly contains program Inner-1. Program\nInner-1 directly contains program Inner-1a, and Outer-program indirectly contains Inner-1a:\nId division.\nProgram-id. Outer-program.\n  Procedure division.\n    Call \"Inner-1\".\n    Stop run.\nId division.\n  Program-id. Inner-1\n  ...\n    Call Inner-1a.\n    Stop run.\n  Id division.\n  Program-id. Inner-1a.\n  ...\n  End Inner-1a.\n  End Inner-1.\nEnd Outer-program.\nThe following figure describes a more complex nested program structure with directly and indirectly\ncontained programs.\nChapter 10. COBOL program structure  87"}
{"instruction": "What is value which in COBOL?", "input": "", "output": "value which is maximum time in milliseconds that the command\nwill wait for the requested child to complete before the command returns"}
{"instruction": "Summarize this COBOL documentation section", "input": "Editing symbol in PICTURE\ncharacter-string\nResult: data item positive or\nzero\nResult: data item negative\n+\n+\n-\n-\nspace\n-\nCR\n2 spaces\nCR\nDB\n2 spaces\nDB\nFor example:\nPICTURE\nValue of data\nEdited result\n        999.99+      \n      +6555.556      \n        555.55+      \n      +9999.99       \n      -6555.555      \n      -6555.55       \n       9999.99       \n      +1234.56       \n       1234.56       \n       $999.99       \n       -123.45       \n       $123.45       \n      -$999.99       \n       -123.456      \n      -$123.45       \n      -$999.99       \n       +123.456      \n       $123.45       \n      $9999.99CR     \n       +123.45       \n      $0123.45       \n      $9999.99CR     \n       -123.45       \n      $0123.45CR   \nFloating insertion editing\nFloating insertion editing is valid only for numeric-edited items.\nThe following symbols are used:\ncs + -\nWithin one PICTURE character-string, these symbols are mutually exclusive as floating insertion\ncharacters.\nFloating insertion editing is specified by using a string of at least two of the allowable floating insertion\nsymbols to represent leftmost character positions into which the actual characters can be inserted.\nThe leftmost floating insertion symbol in the character-string represents the leftmost limit at which the\nactual character can appear in the data item. The rightmost floating insertion symbol represents the\nrightmost limit at which the actual character can appear.\n226  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "Editing symbol in PICTURE\ncharacter-string\nResult: data item positive or\nzero\nResult: data item negative\n+\n+\n-\n-\nspace\n-\nCR\n2 spaces\nCR\nDB\n2 spaces\nDB\nFor example:\nPICTURE\nValue of data\nEdited result\n        999.99+      \n      +6555.556      \n        555.55+      \n      +9999.99       \n      -6555.555      \n      -6555.55       \n       9999.99       \n      +1234.56       \n       1234.56       \n       $999.99       \n       -123.45       \n       $123.45       \n      -$999.99       \n       -123.456      \n      -$123.45       \n      -$999.99       \n       +123.456      \n       $123.45       \n      $9999.99CR     \n       +123.45       \n      $0123.45       \n      $9999.99CR     \n       -123.45       \n      $0123.45CR   \nFloating insertion editing\nFloating insertion editing is valid only for numeric-edited items.\nThe following symbols are used:\ncs + -\nWithin one PICTURE character-string, these symbols are mutually exclusive as floating insertion\ncharacters.\nFloating insertion editing is specified by using a string of at least two of the allowable floating insertion\nsymbols to represent leftmost character positions into which the actual characters can be inserted.\nThe leftmost floating insertion symbol in the character-string represents the leftmost limit at which the\nactual character can appear in the data item. The rightmost floating insertion symbol represents the\nrightmost limit at which the actual character can appear.\n226  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "Summarize this COBOL documentation section", "input": "4\nThe application entry point program is a Java program but the JVMSERVER resource is not\nenabled.\nDefault action: end the task abnormally.\n22 LENGERR\nRESP 2 values:\n11\nThe COMMAREA length is less than 0 or greater than the permitted length.\n26\nThe COMMAREA address is zero, but the COMMAREA length is nonzero.\nDefault action: end the task abnormally.\n70 NOTAUTH\nRESP2 values:\n101\nA resource security check has failed on the name of the application entry point program that\nimplements the operation for the specified application.\nDefault action: end the task abnormally.\n27 PGMIDERR\nRESP2 values:\n1\nThe application entry point program is disabled.\n2\nThe application entry point program could not be loaded\nDefault action: end the task abnormally.\nINVOKE SERVICE\nCall a service from a CICS application. The command specifies the name of a service or the CICS resource,\nsuch as a WEBSERVICE resource, that contains information about the service to be called.\nINVOKE SERVICE\nINVOKE SERVICE(  data-value )\nCHANNEL(  data-value )\nOPERATION(  data-value )\nURI( data-value )\nURIMAP( data-value )\nSCOPE( data-value )\nSCOPELEN(  data-value )\nConditions: INVREQ, LENGERR, NOTFND, TIMEDOUT\nThis command is threadsafe.\nDescription\nUse the INVOKE SERVICE command in CICS applications to call a service; for example, the application\ncan act as a web service requester and call an XML-based service, or the application can call another\nCICS application that is acting as a channel-based service. For more information about these two types of\nservices, see Creating business services from CICS applications.\nChapter 2. CICS command summary  263", "output": "4\nThe application entry point program is a Java program but the JVMSERVER resource is not\nenabled.\nDefault action: end the task abnormally.\n22 LENGERR\nRESP 2 values:\n11\nThe COMMAREA length is less than 0 or greater than the permitted length.\n26\nThe COMMAREA address is zero, but the COMMAREA length is nonzero.\nDefault action: end the task abnormally.\n70 NOTAUTH\nRESP2 values:\n101\nA resource security check has failed on the name of the application entry point program that\nimplements the operation for the specified application.\nDefault action: end the task abnormally.\n27 PGMIDERR\nRESP2 values:\n1\nThe application entry point program is disabled.\n2\nThe application entry point program could not be loaded\nDefault action: end the task abnormally.\nINVOKE SERVICE\nCall a service from a CICS application. The command specifies the name of a service or the CICS resource,\nsuch as a WEBSERVICE resource, that contains information about the service to be called.\nINVOKE SERVICE\nINVOKE SERVICE(  data-value )\nCHANNEL(  data-value )\nOPERATION(  data-value )\nURI( data-value )\nURIMAP( data-value )\nSCOPE( data-value )\nSCOPELEN(  data-value )\nConditions: INVREQ, LENGERR, NOTFND, TIMEDOUT\nThis command is threadsafe.\nDescription\nUse the INVOKE SERVICE command in CICS applications to call a service; for example, the application\ncan act as a web service requester and call an XML-based service, or the application can call another\nCICS application that is acting as a channel-based service. For more information about these two types of\nservices, see Creating business services from CICS applications.\nChapter 2. CICS command summary  263"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 141. SYSADATA symbol record (continued)\nField\nSize\nDescription\n \n \nFor file types:\n1... ....\nO", "output": "Table 141. SYSADATA symbol record (continued)\nField\nSize\nDescription\n \n \nFor file types:\n1... ....\nObject of ODO in record\n.1.. ....\nSubject of ODO in record\n..1. ....\nSequential access\n...1 ....\nRandom access\n.... 1...\nDynamic access\n.... .1..\nLocate mode\n.... ..1.\nRecord area\n.... ...1\nReserved for future use\nData flags 3\nXL1\n1... ....\nAll records are the same length\n.1.. ....\nFixed length\n..1. ....\nVariable length\n...1 ....\nUndefined\n.... 1...\nSpanned\n.... .1..\nBlocked\n.... ..1.\nApply write only\n.... ...1\nSame sort merge area\nAppendix G. COBOL SYSADATA file contents  959"}
{"instruction": "What is The IGZXOPT macro in COBOL?", "input": "", "output": "The IGZXOPT macro is assembler macro that is used in an assembler program that must be assembled\nand then linked into a load module called either IGZUOPT or IGZQUOPT applications"}
{"instruction": "Explain this COBOL concept", "input": "2. class-name-1 is used if external-class-name-1 or java-array-class-reference is not specified. To create\nan external name that identifies the class and conforms to Java rules of formation, class-name-1 is\nprocessed as follows:\n• The name is converted to uppercase.\n• Hyphens are translated to zero.\n• Underscores are not translated.\n• If the first character of the name is a digit, it is converted as follows:\n– Digits 1 though 9 are changed to A through I.\n– 0 is changed to J.\nThe class can be implemented in Java or COBOL.\nWhen referencing a class that is part of a Java package, external-class-name-1 must be specified and\nmust give the fully qualified Java class-name.\nFor example, the repository entry\nRepository.\n    Class JavaException is \"java.lang.Exception\"\ndefines local class-name JavaException for referring to the fully qualified external-class-name\n\"java.lang.Exception.\"\nWhen defining a COBOL class that is to be part of a Java package, specify an entry in the repository\nparagraph of that class itself, giving the full Java package-qualified name as the external class-name.\nChapter 22. Configuration section  137", "output": "2. class-name-1 is used if external-class-name-1 or java-array-class-reference is not specified. To create\nan external name that identifies the class and conforms to Java rules of formation, class-name-1 is\nprocessed as follows:\n• The name is converted to uppercase.\n• Hyphens are translated to zero.\n• Underscores are not translated.\n• If the first character of the name is a digit, it is converted as follows:\n– Digits 1 though 9 are changed to A through I.\n– 0 is changed to J.\nThe class can be implemented in Java or COBOL.\nWhen referencing a class that is part of a Java package, external-class-name-1 must be specified and\nmust give the fully qualified Java class-name.\nFor example, the repository entry\nRepository.\n    Class JavaException is \"java.lang.Exception\"\ndefines local class-name JavaException for referring to the fully qualified external-class-name\n\"java.lang.Exception.\"\nWhen defining a COBOL class that is to be part of a Java package, specify an entry in the repository\nparagraph of that class itself, giving the full Java package-qualified name as the external class-name.\nChapter 22. Configuration section  137"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Chapter 73. MOD\nThe MOD function returns an integer value that is argument-1 modulo argument-2.\nThe ", "output": "Chapter 73. MOD\nThe MOD function returns an integer value that is argument-1 modulo argument-2.\nThe function type is integer.\nThe function result is an integer with as many digits as the shorter of argument-1 and argument-2.\nFormat\nFUNCTION MOD\n(\nargument-1\nargument-2\n)\nargument-1\nMust be an integer.\nargument-2\nMust be an integer. Must not be zero.\nThe returned value is argument-1 modulo argument-2. The returned value is defined as:\nargument-1 - (argument-2 * FUNCTION INTEGER (argument-1 / argument-2))\nThe following table lists expected results for some values of argument-1 and argument-2.\nargument-1\nargument-2\nReturned value\n11\n5\n1\n-11\n5\n4\n11\n-5\n-4\n-11\n-5\n-1\n© Copyright IBM Corp. 1991, 2025\n611"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Specify WAIT(YES) and WAITACTION(QUEUE) in the TDQUEUE resource definition if you want the\ntransacti", "output": "Specify WAIT(YES) and WAITACTION(QUEUE) in the TDQUEUE resource definition if you want the\ntransaction to wait.\nDefault action: terminate the task abnormally.\n18 NOSPACE\nOccurs if no more space exists on the intrapartition or extrapartition queue, or the relative byte\naddress (RBA) for an intrapartition queue would exceed 2 GB. When this happens, no more data\nshould be written to the queue because it may be lost.\nDefault action: terminate the task abnormally.\n70 NOTAUTH\nRESP2 values:\n101\nA resource security check has failed on QUEUE(name).\n102\nA surrogate security check has failed. For more information, see Security for submitting a JCL job\nto the internal reader.\nDefault action: terminate the task abnormally.\n19 NOTOPEN\nOccurs if the destination is closed.\nNote: This condition cannot be raised for intrapartition queues.\nDefault action: terminate the task abnormally.\n44 QIDERR\nOccurs if the symbolic destination to be used with a transient data control command cannot be found.\nDefault action: terminate the task abnormally.\n53 SYSIDERR\nOccurs when the SYSID option specifies a name that is neither the local system nor a remote system\n(made known to CICS by defining a CONNECTION or an IPCONN). SYSIDERR also occurs when the link\nto the remote system is closed.\nDefault action: terminate the task abnormally.\nChapter 2. CICS command summary  683"}
{"instruction": "Explain this COBOL concept", "input": "Note\nBefore using this information and the product it supports, be sure to read the general information under\n“Notices” on page 997.", "output": "Note\nBefore using this information and the product it supports, be sure to read the general information under\n“Notices” on page 997."}
{"instruction": "What are the compiler rules or directives for this?", "input": "containers can be deleted only by the root activity or by a program that has acquired the", "output": "containers can be deleted only by the root activity or by a program that has acquired the"}
{"instruction": "What is It in COBOL?", "input": "", "output": "It is application's responsibility to set the options\naccordingly"}
{"instruction": "What are the compiler rules or directives for this?", "input": "is in effect, then the maximum length of an external", "output": "is in effect, then the maximum length of an external"}
{"instruction": "What is Options\nCARD\nspecifies that the output medium in COBOL?", "input": "", "output": "Options\nCARD\nspecifies that the output medium is card reader or card punch device"}
{"instruction": "What is the user to be queried in COBOL?", "input": "", "output": "the user to be queried is user that invokes the transaction issuing the\nQUERY SECURITY command"}
{"instruction": "What is A in the following code in COBOL?", "input": "", "output": "A in the following code is index-name:\n05 TABLE-ITEM PIC X(8)\n     OCCURS 10 INDEXED BY INX-A"}
{"instruction": "What is Processes\nThe only process that a program can run in COBOL?", "input": "", "output": "Processes\nThe only process that a program can run is one that it has acquired in the current unit of work—see\nAcquiring processes and activities"}
{"instruction": "Explain this COBOL concept", "input": "ASSIGN\nRequest values from outside the local environment of the application program.\nChapter 2. CICS command summary  39", "output": "ASSIGN\nRequest values from outside the local environment of the application program.\nChapter 2. CICS command summary  39"}
{"instruction": "Summarize this COBOL documentation section", "input": "Table 135. SYSADATA external symbol record (continued)\nField\nSize\nDescription\nAlias section name\nCL(n)\nNot applicable for COBOL\nParse tree record: X'0024'\nThe following table shows the contents of the parse tree record.\nNote: Sometimes the compiler will emit more than one SYSADATA record for the same node. In this case\nthe data from the two records should be combined. Examples include the node for the DEPENDING ON\nobjects of OCCURS and RECORD IS VARYING, where the name appears twice in the data division. The\nsecond record usually adds the SYMBOL-ID for the first record.\nTable 136. SYSADATA parse tree record\nField\nSize\nDescription\nNode number\nFL4\nThe node number generated by the compiler, starting at 1\nNode type\nHL2\nThe type of the node:\n001\nProgram\n002\nClass\n003\nMethod\n004\nUser-defined function\n005\nFunction prototype\n \n \n101\nIDENTIFICATION DIVISION\n102\nENVIRONMENT DIVISION\n103\nDATA DIVISION\n104\nPROCEDURE DIVISION\n105\nEnd Program/Method/Class/Function\n \n \n201\nDeclaratives body\n202\nNondeclaratives body\n \n \n301\nSection\n302\nProcedure section\n898  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "Table 135. SYSADATA external symbol record (continued)\nField\nSize\nDescription\nAlias section name\nCL(n)\nNot applicable for COBOL\nParse tree record: X'0024'\nThe following table shows the contents of the parse tree record.\nNote: Sometimes the compiler will emit more than one SYSADATA record for the same node. In this case\nthe data from the two records should be combined. Examples include the node for the DEPENDING ON\nobjects of OCCURS and RECORD IS VARYING, where the name appears twice in the data division. The\nsecond record usually adds the SYMBOL-ID for the first record.\nTable 136. SYSADATA parse tree record\nField\nSize\nDescription\nNode number\nFL4\nThe node number generated by the compiler, starting at 1\nNode type\nHL2\nThe type of the node:\n001\nProgram\n002\nClass\n003\nMethod\n004\nUser-defined function\n005\nFunction prototype\n \n \n101\nIDENTIFICATION DIVISION\n102\nENVIRONMENT DIVISION\n103\nDATA DIVISION\n104\nPROCEDURE DIVISION\n105\nEnd Program/Method/Class/Function\n \n \n201\nDeclaratives body\n202\nNondeclaratives body\n \n \n301\nSection\n302\nProcedure section\n898  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "Explain this COBOL concept", "input": "KEEP\nFor an INPUT report, KEEP specifies that the report is to be read again when SPOOLOPEN INPUT is\nnext issued.\nFor an OUTPUT report, KEEP specifies that the report is to be sent to its destination node.\nTOKEN(data-area)\nspecifies the 8-character CICS-allocated token used to identify a report.\nConditions\nNote: There are no default actions.\n85 ALLOCERR\noccurs in any of the following situations:\n• Dynamic allocation has rejected a request to allocate an input data set.\nRESP2 gives the dynamic allocation response code that denotes this error. The first two characters\nare the information reason code (S99INFO), and the second two are the error reason code\n(S99ERROR), as defined in the z/OS MVS Programming: Authorized Assembler Services Guide.\n16 INVREQ\nRESP2 values:\n4\nUnsupported language.\n8\nUnsupported function.\n40\nSubsystem interface already enabled.\nNote: Errors 1024 and over are internal, and should not occur. If one of these error codes is\nreturned, contact your IBM support center.\n80 NOSPOOL\nRESP2 values:\n4\nNo subsystem present.\n8\nInterface being disabled; CICS is quiescing.\n12\nInterface has been stopped.\n42 NOSTG\noccurs in any of the following situations:\n• A GETMAIN has failed within the JES interface subtask (DFHPSPSS).\nRESP2 gives the GETMAIN register 15 return code.\n13 NOTFND\nRESP2 values:\n1024\nInput or output function has been corrupted, and SPOOLCLOSE could not complete.\n19 NOTOPEN\nRESP2 values:\n8\nData set has not been opened.\n86 STRELERR\noccurs in any of the following situations:\n508  CICS TS for z/OS: API Reference", "output": "KEEP\nFor an INPUT report, KEEP specifies that the report is to be read again when SPOOLOPEN INPUT is\nnext issued.\nFor an OUTPUT report, KEEP specifies that the report is to be sent to its destination node.\nTOKEN(data-area)\nspecifies the 8-character CICS-allocated token used to identify a report.\nConditions\nNote: There are no default actions.\n85 ALLOCERR\noccurs in any of the following situations:\n• Dynamic allocation has rejected a request to allocate an input data set.\nRESP2 gives the dynamic allocation response code that denotes this error. The first two characters\nare the information reason code (S99INFO), and the second two are the error reason code\n(S99ERROR), as defined in the z/OS MVS Programming: Authorized Assembler Services Guide.\n16 INVREQ\nRESP2 values:\n4\nUnsupported language.\n8\nUnsupported function.\n40\nSubsystem interface already enabled.\nNote: Errors 1024 and over are internal, and should not occur. If one of these error codes is\nreturned, contact your IBM support center.\n80 NOSPOOL\nRESP2 values:\n4\nNo subsystem present.\n8\nInterface being disabled; CICS is quiescing.\n12\nInterface has been stopped.\n42 NOSTG\noccurs in any of the following situations:\n• A GETMAIN has failed within the JES interface subtask (DFHPSPSS).\nRESP2 gives the GETMAIN register 15 return code.\n13 NOTFND\nRESP2 values:\n1024\nInput or output function has been corrupted, and SPOOLCLOSE could not complete.\n19 NOTOPEN\nRESP2 values:\n8\nData set has not been opened.\n86 STRELERR\noccurs in any of the following situations:\n508  CICS TS for z/OS: API Reference"}
{"instruction": "What is Character sets and code pages\nA character set in COBOL?", "input": "", "output": "Character sets and code pages\nA character set is set of letters, numbers, special characters, and other elements used to represent\ninformation"}
{"instruction": "What are the compiler rules or directives for this?", "input": "setting influences how ALLOCATE acquires storage:\n• If DATA(24) is in effect and the LOC 31 phrase of the ALLOCATE statement is not specified, ALLOCATE", "output": "setting influences how ALLOCATE acquires storage:\n• If DATA(24) is in effect and the LOC 31 phrase of the ALLOCATE statement is not specified, ALLOCATE"}
{"instruction": "What is This in COBOL?", "input": "", "output": "This is WEB EXTRACT (Client) error only"}
{"instruction": "What is The quotation mark in COBOL?", "input": "", "output": "The quotation mark is character with the value X'7F'.\n6  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference\n\n\nChapter 2"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 66. Signature information bytes (continued)\nOffset\nin\ndecim\nal\nSignatur\ne byte\nBit\nItem\nOn\nOff", "output": "Table 66. Signature information bytes (continued)\nOffset\nin\ndecim\nal\nSignatur\ne byte\nBit\nItem\nOn\nOff\n27\n20\n0-7\nReserved\n28\n21\n0\nHexadecimal literal\n1\nAltered GO TO\n2\nI-O ERROR declarative\n3\nDECIMAL-POINT IS COMMA clause\n4\nDEBUGGING declarative\n5\nProgram segmentation\n6\nOPEN . . . EXTEND\n7\nEXIT PROGRAM\n29\n22\n0\nCALL literal\n1\nCALL identifier\n2\nCALL . . . ON OVERFLOW\n3\nCALL . . . LENGTH OF\n4\nCALL . . . ADDRESS OF\n5\nCLOSE . . . REEL/UNIT\n6\nExponentiation used\n7\nFloating-point items used\n30\n23\n0\nCOPY\n1\nBASIS\n2\nDBCS name in program\n3\nShift-out and Shift-in in program\n4\nSUPPRESS|NOSUPPRESS\n5\nSSRANGE(ZLEN) (if bit 6 in byte 3 is on) SSRANGE(NOZLEN) (if bit 6 in byte 3 is\non)\n6\nSSRANGE(ABD) (if bit 6 in byte 3 is on)\nSSRANGE(MSG) (if bit 6 in byte 3 is on)\n7\nINLINE|NOINLINE\nChapter 22. Debugging  497"}
{"instruction": "What are the compiler rules or directives for this?", "input": "its content. For each unbounded element, check if the current limit is", "output": "its content. For each unbounded element, check if the current limit is"}
{"instruction": "Summarize this COBOL documentation section", "input": "Value CVDA\n322 USEROFF\n323 SINGLEON\n324 SINGLEOFF\n326 OPTIONAL\n327 NOTALLOWED\n328 IDNTY\n329 NOIDNTY\n330 PERF\n331 NOPERF\n332 EXCEPT\n333 NOEXCEPT\n334 EVENT\n335 NOEVENT\n336 RESRCE\n337 NORESRCE\n338 APPLNAME\n339 NOAPPLNAME\n340 WAIT\n341 NOWAIT\n347 RESOLVED\n348 STOPPING\n349 CLOSEFAILED\n350 IMMCLOSE\n351 FORCECLOSE\n352 IMMCLOSING\n353 FORCECLOSING\n354 FWDRECOVABLE\n355 UNDETERMINED\n356 NORMALBKOUT\n357 FAILEDBKOUT\n358 FAILINGBKOUT\n359 INVALID\n360 VALID\n361 NOTFWDRCVBLE\n362 EXITTRACE\nChapter 4. CICS-value data areas used by all commands  747", "output": "Value CVDA\n322 USEROFF\n323 SINGLEON\n324 SINGLEOFF\n326 OPTIONAL\n327 NOTALLOWED\n328 IDNTY\n329 NOIDNTY\n330 PERF\n331 NOPERF\n332 EXCEPT\n333 NOEXCEPT\n334 EVENT\n335 NOEVENT\n336 RESRCE\n337 NORESRCE\n338 APPLNAME\n339 NOAPPLNAME\n340 WAIT\n341 NOWAIT\n347 RESOLVED\n348 STOPPING\n349 CLOSEFAILED\n350 IMMCLOSE\n351 FORCECLOSE\n352 IMMCLOSING\n353 FORCECLOSING\n354 FWDRECOVABLE\n355 UNDETERMINED\n356 NORMALBKOUT\n357 FAILEDBKOUT\n358 FAILINGBKOUT\n359 INVALID\n360 VALID\n361 NOTFWDRCVBLE\n362 EXITTRACE\nChapter 4. CICS-value data areas used by all commands  747"}
{"instruction": "What is the returned value in COBOL?", "input": "", "output": "the returned value is position of the 19th digit\nif no prior error is found, because the character in error for an argument that is greater than 18 digits\nis the 19th digit.\n– If the ARITH(EXTEND) compiler option is in effect, the returned value is the position of the 32nd digit\nif no prior error is found, because the character in error for an argument that is greater than 31 digits\nis the 32nd digit.\n• Otherwise, the returned value is (FUNCTION LENGTH (argument-1) + 1)"}
{"instruction": "Summarize this COBOL documentation section", "input": "Table 3. Assignment to data items in a program\nWhat you want to do\nHow to do it\nAssign values to a data item or large data area.\nUse one of these ways:\n• INITIALIZE statement\n• MOVE statement\n• STRING or UNSTRING statement\n• VALUE clause (to set data items to the values\nyou want them to have when the program is in\ninitial state)\nAssign the results of arithmetic.\nUse COMPUTE, ADD, SUBTRACT, MULTIPLY, or\nDIVIDE statements.\nAssign the results of intrinsic functions.\nUse COMPUTE, ADD, SUBTRACT, MULTIPLY,\nDIVIDE, or MOVE statements.\nExamine or replace characters or groups of characters in a\ndata item.\nUse the INSPECT statement.\nReceive values from a file.\nUse the READ (or READ INTO) statement.\nReceive values from a system input device or a file.\nUse the ACCEPT statement.\nEstablish a constant.\nUse the VALUE clause in the definition of the\ndata item, and do not use the data item as a\nreceiver. Such an item is in effect a constant\neven though the compiler does not enforce read-\nonly constants.\nOne of these actions:\n• Place a value associated with a table element in an index.\n• Set the status of an external switch to ON or OFF.\n• Move data to a condition-name to make the condition\ntrue.\n• Set a POINTER, PROCEDURE-POINTER, or FUNCTION-\nPOINTER data item to an address.\n• Associate an OBJECT REFERENCE data item with an\nobject instance.\nUse the SET statement.\n“Examples: initializing data items” on page 28\nRelated tasks   \n“Initializing a structure (INITIALIZE)” on page 31  \n“Assigning values to elementary\ndata items (MOVE)” on page 32  \n“Assigning values to group data items (MOVE)” on page 33  \n“Assigning input from a screen or file (ACCEPT)” on page 35  \n“Joining data items (STRING)” on page 109  \n“Splitting data items (UNSTRING)” on page 111  \n“Assigning arithmetic results (MOVE or COMPUTE)” on page 34  \n“Tallying and replacing data items (INSPECT)” on page 118  \nChapter 7, “Processing data in an international environment,” on page 129 \nChapter 2. Using data  27", "output": "Table 3. Assignment to data items in a program\nWhat you want to do\nHow to do it\nAssign values to a data item or large data area.\nUse one of these ways:\n• INITIALIZE statement\n• MOVE statement\n• STRING or UNSTRING statement\n• VALUE clause (to set data items to the values\nyou want them to have when the program is in\ninitial state)\nAssign the results of arithmetic.\nUse COMPUTE, ADD, SUBTRACT, MULTIPLY, or\nDIVIDE statements.\nAssign the results of intrinsic functions.\nUse COMPUTE, ADD, SUBTRACT, MULTIPLY,\nDIVIDE, or MOVE statements.\nExamine or replace characters or groups of characters in a\ndata item.\nUse the INSPECT statement.\nReceive values from a file.\nUse the READ (or READ INTO) statement.\nReceive values from a system input device or a file.\nUse the ACCEPT statement.\nEstablish a constant.\nUse the VALUE clause in the definition of the\ndata item, and do not use the data item as a\nreceiver. Such an item is in effect a constant\neven though the compiler does not enforce read-\nonly constants.\nOne of these actions:\n• Place a value associated with a table element in an index.\n• Set the status of an external switch to ON or OFF.\n• Move data to a condition-name to make the condition\ntrue.\n• Set a POINTER, PROCEDURE-POINTER, or FUNCTION-\nPOINTER data item to an address.\n• Associate an OBJECT REFERENCE data item with an\nobject instance.\nUse the SET statement.\n“Examples: initializing data items” on page 28\nRelated tasks   \n“Initializing a structure (INITIALIZE)” on page 31  \n“Assigning values to elementary\ndata items (MOVE)” on page 32  \n“Assigning values to group data items (MOVE)” on page 33  \n“Assigning input from a screen or file (ACCEPT)” on page 35  \n“Joining data items (STRING)” on page 109  \n“Splitting data items (UNSTRING)” on page 111  \n“Assigning arithmetic results (MOVE or COMPUTE)” on page 34  \n“Tallying and replacing data items (INSPECT)” on page 118  \nChapter 7, “Processing data in an international environment,” on page 129 \nChapter 2. Using data  27"}
{"instruction": "Explain this COBOL concept", "input": "SEND (3650-3653)\nWrite data to a 3650 (3653) logical unit. \nSEND (3650-3653)\nSEND\nFROM( data-area )\nLENGTH( data-value )\nFLENGTH(  data-value )\nWAIT\nINVITE\nLAST\nCNOTCOMPL\nDEFRESP\nConditions: INVREQ, LENGERR, TERMERR\n \nDescription\nSEND writes data to a terminal.\nSEND (3650-3680)\nWrite data to a 3650 (3680) logical unit. \nSEND (3650-3680)\nSEND\nFROM( data-area )\nLENGTH( data-value )\nFLENGTH(  data-value )\nWAIT\nINVITE\nLAST\nCNOTCOMPL\nDEFRESP\nFMH\nConditions: INVREQ, LENGERR, TERMERR\n \nDescription\nSEND writes data to a terminal.\nSEND (3767)\nWrite data to a 3767 interactive logical unit. \n452  CICS TS for z/OS: API Reference", "output": "SEND (3650-3653)\nWrite data to a 3650 (3653) logical unit. \nSEND (3650-3653)\nSEND\nFROM( data-area )\nLENGTH( data-value )\nFLENGTH(  data-value )\nWAIT\nINVITE\nLAST\nCNOTCOMPL\nDEFRESP\nConditions: INVREQ, LENGERR, TERMERR\n \nDescription\nSEND writes data to a terminal.\nSEND (3650-3680)\nWrite data to a 3650 (3680) logical unit. \nSEND (3650-3680)\nSEND\nFROM( data-area )\nLENGTH( data-value )\nFLENGTH(  data-value )\nWAIT\nINVITE\nLAST\nCNOTCOMPL\nDEFRESP\nFMH\nConditions: INVREQ, LENGERR, TERMERR\n \nDescription\nSEND writes data to a terminal.\nSEND (3767)\nWrite data to a 3767 interactive logical unit. \n452  CICS TS for z/OS: API Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 83. IBM extension language elements (continued)\nLanguage area\nExtension elements\nImplicit item", "output": "Table 83. IBM extension language elements (continued)\nLanguage area\nExtension elements\nImplicit items\nSpecial object references:\n• SELF\n• SUPER\nSpecial registers:\n• ADDRESS OF\n• JNIENVPTR\n• JSON-CODE\n• JSON-STATUS\n• LENGTH OF\n• RETURN-CODE\n• SHIFT-IN\n• SHIFT-OUT\n• SORT-CONTROL\n• SORT-CORE-SIZE\n• SORT-FILE-SIZE\n• SORT-MESSAGE\n• SORT-MODE-SIZE\n• SORT-RETURN\n• TALLY\n• WHEN-COMPILED\n• XML-CODE\n• XML-EVENT\n• XML-INFORMATION\n• XML-NAMESPACE\n• XML-NAMESPACE-PREFIX\n• XML-NNAMESPACE\n• XML-NNAMESPACE-PREFIX\n• XML-NTEXT\n• XML-TEXT\nFigurative constants\nSelection of apostrophe (') as the value of the figurative constant\nQUOTE\nNULL and NULLS for pointers and object references\n746  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What is that interact by in COBOL?", "input": "", "output": "that interact by is of COBOL CALL or\nINVOKE statements and function at run time as an entity"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "31\nThe user is revoked in the connection to the default group.\nDefault action: terminate the task ab", "output": "31\nThe user is revoked in the connection to the default group.\nDefault action: terminate the task abnormally.\n69 USERIDERR\nRESP2 values:\n8\nThe USERID is not known to the ESM.\nDefault action: terminate the task abnormally.\nCHANGE TASK\nChange priority of a task. \nCHANGE TASK\nCHANGE TASK\nPRIORITY(  data-value )\nCondition: INVREQ\nThis command is threadsafe.\nDescription\nCHANGE TASK changes the priority of the issuing task. It has immediate effect (unlike SET TASK) because\ncontrol is relinquished during execution of the command so that the current task has to be redispatched.\nThe redispatch does not happen until tasks that are of higher or equal priority, and that are also ready to\nrun, are dispatched.\nIf you omit the PRIORITY option, the task does not lose control and the priority remains the same. This is\neffectively a no-op.\nOptions\nPRIORITY(data-value)\nThis option specifies a fullword binary value in the range 0–255, defining the priority of the task. You\ncan also have a value of -1 but this does not change the priority or cause a redispatch.\nConditions\n16 INVREQ\nRESP2 values:\n1\nYour PRIORITY value is outside the range -1–255.\nCHECK ACQPROCESS\nCheck the completion status of a BTS process.\nChapter 2. CICS command summary  71"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "14\nThe code page combination for client and server is invalid.\n17\nInvalid forms data was found in th", "output": "14\nThe code page combination for client and server is invalid.\n17\nInvalid forms data was found in the input message.\n22 LENGERR\nRESP2 values are:\n1\nThe length in NAMELENGTH or VALUELENGTH is less than or equal to zero.\n4\nThe form field name has been truncated during a read operation because the receiving buffer is\ntoo small.\n5\nThe form field value has been truncated during a read operation because the receiving buffer is\ntoo small.\n153\nThe form type is unknown.\n154\nA boundary string was expected in the forms data, but was not found.\n13 NOTFND\nRESP2 values are:\n1\nThe form field with the given name cannot be found.\nWEB READ HTTPHEADER\nExtract HTTP header information.\nWEB READ HTTPHEADER\nWEB\nREAD\nHTTPHEADER(  data-area )\nNAMELENGTH(  data-value )\nSESSTOKEN(  data-area )\nVALUE(  data-area )\nVALUELENGTH(  data-area )\nConditions: INVREQ, LENGERR, NOTFND, NOTOPEN\nThis command is threadsafe.\nDescription\nWEB READ HTTPHEADER enables an application to extract HTTP header information from a message.\nWhen CICS is an HTTP server, the message is a request from a Web client. When CICS is an HTTP client,\nthe message is a response from a server, and the SESSTOKEN option is specified.\nFor CICS as an HTTP server, you can use the WEB READ HTTPHEADER command either before, or after,\nyou use the WEB RECEIVE command to receive the body of the message. For CICS as an HTTP client, you\nmust first receive the message using the WEB RECEIVE command, and then you can read the headers\nusing the WEB READ HTTPHEADER command.\nHTTP header reference for CICS web support lists HTTP/1.1 headers that you are likely to receive, and\ngives guidance for the actions that you might take in response to them.\nThe HTTP header browsing commands (WEB STARTBROWSE HTTPHEADER, WEB READNEXT\nHTTPHEADER, WEB ENDBROWSE HTTPHEADER) can be used to browse through all the HTTP header\ninformation for a message.\nChapter 2. CICS command summary  623"}
{"instruction": "What is Performance\nThere in COBOL?", "input": "", "output": "Performance\nThere is extra overhead to transition between AMODE 31 and 64"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "TEST EVENT\nTEST\nEVENT( data-value )\nFIRESTATUS(  cvda)\nConditions: EVENTERR, INVREQ\nDescription\nTEST", "output": "TEST EVENT\nTEST\nEVENT( data-value )\nFIRESTATUS(  cvda)\nConditions: EVENTERR, INVREQ\nDescription\nTEST EVENT tests whether a named BTS event has occurred (fired).\nOptions\nEVENT(data-value)\nspecifies the name (1–16 characters) of the event to test for completion.\nFIRESTATUS(cvda)\nFIRESTATUS returns the fire status of the event. CVDA values are:\nFIRED\nThe event has fired.\nNOTFIRED\nThe event has not fired.\nConditions\n111 EVENTERR\nRESP2 values:\n4\nThe event specified on the EVENT option is not recognized by BTS.\n16 INVREQ\nRESP2 values:\n1\nThe command was issued outside the scope of an activity.\nTRANSFORM DATATOJSON\nUse the TRANSFORM DATATOJSON command to convert application data to JSON.\nTRANSFORM DATATOJSON\nTRANSFORM DATATOJSON\nCHANNEL(  data-value )\nINCONTAINER(  data-value )\nOUTCONTAINER(  data-value )\nTRANSFORMER(  name )\nConditions: CHANNELERR, CONTAINERERR, INVREQ, NOTFND\nThis command is threadsafe.\nDescription\nThe TRANSFORM DATATOJSON command transforms application data to JSON using mappings that are\ndefined in the JSON binding. The JSON transformer resource is a bundle that defines where the JSON\nbinding and the JSON schema are located.\nChapter 2. CICS command summary  555"}
{"instruction": "What is 120\nThere in COBOL?", "input": "", "output": "120\nThere is I/O error during the file control operation"}
{"instruction": "What are the compiler rules or directives for this?", "input": "to specify the level of error to be diagnosed during compilation and to", "output": "to specify the level of error to be diagnosed during compilation and to"}
{"instruction": "What is COUNTER at any given time in COBOL?", "input": "", "output": "COUNTER at any given time is line number at which the device is positioned\nwithin the current page"}
{"instruction": "What is The sequence in which records\nare accessed in COBOL?", "input": "", "output": "The sequence in which records\nare accessed is order in which the records were originally written"}
{"instruction": "What is File position indicator\nThe file position indicator in COBOL?", "input": "", "output": "File position indicator\nThe file position indicator is conceptual entity used in this document to facilitate exact specification of\nthe next record to be accessed within a given file during certain sequences of input-output operations"}
{"instruction": "What are the compiler rules or directives for this?", "input": "or activity that owns the container can be identified:\n• Explicitly, by specifying one of the PROCESS- or ACTIVITY-related options.\n• Implicitly, by omitting the PROCESS- and ACTIVITY-related options.", "output": "or activity that owns the container can be identified:\n• Explicitly, by specifying one of the PROCESS- or ACTIVITY-related options.\n• Implicitly, by omitting the PROCESS- and ACTIVITY-related options. If these are omitted, the current"}
{"instruction": "What is the returned value in COBOL?", "input": "", "output": "the returned value is byte position in argument-1 where the nth UTF-8 or\nUTF-16 character starts"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "The operands are equal if the two addresses used in the comparison would both result in the same\nsto", "output": "The operands are equal if the two addresses used in the comparison would both result in the same\nstorage location.\nThis relation condition is allowed in IF, PERFORM, EVALUATE, and SEARCH format-1 statements. It is not\nallowed in SEARCH format-2 (SEARCH ALL) statements, because there is no meaningful ordering that can\nbe applied to procedure-pointer data items.\nFormat 3: procedure-pointer and function-pointer relation condition\nidentifier-1\nNULL\nNULLS\nIS\nNOT\nEQUAL\nTO\n = \nidentifier-2\nNULL\nNULLS\nidentifier-1 , identifier-2\nMust be described as USAGE PROCEDURE-POINTER or USAGE FUNCTION-POINTER. identifier-1 and\nidentifier-2 need not be described the same.\nNULL, NULLS\nCan be used only if the other operand is defined as USAGE FUNCTION-POINTER or USAGE\nPROCEDURE-POINTER. That is, NULL=NULL is not allowed.\nObject-reference relation conditions\nA data item of usage OBJECT REFERENCE can be compared for equality or inequality with another data\nitem of usage OBJECT REFERENCE or with NULL, NULLS, or SELF.\nFormat 4: object-reference relation condition\nobject-reference-identifier-1\nSELF\nNULL\nNULLS\nIS\nNOT\nEQUAL\nTO\n = \nobject-reference-identifier-2\nSELF\nNULL\nNULLS\nA comparison with SELF is allowed only in a method.\nTwo object-references compare equal only if the data items identify the same object.\n288  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What is which in COBOL?", "input": "", "output": "which is the year is not within the range of 1601 to 9999.\n• If the value of FUNCTION MOD (argument-1 1000) is less than 1 or greater than the number of days in\nthe year determined by FUNCTION INTEGER (argument-1/1000), the returned value is 2, which means\nthe day is not valid in the given year.\n• Otherwise, the returned value is 0 (zero), which means the date is valid"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "160-character name, the first 70 characters are displayed on the first two lines, and the remaining ", "output": "160-character name, the first 70 characters are displayed on the first two lines, and the remaining 20\ncharacters appear on the third line. There is no special character to indicate the name wrapping.\n(6)\nThe LONG SERVICE STRING LIST section is optionally displayed depending on whether any\nSERVICE strings exceed 10 characters. See also SERVICE in (2).\nRelated references\n“Making dynamic calls” on page 574\n518  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "Summarize this COBOL documentation section", "input": "SEND (LUTYPE6.1)\nSEND\nSESSION(  name )\nWAIT\nINVITE\nLAST\nATTACHID(  name )\nFROM( data-area )\nLENGTH( data-value )\nFLENGTH(  data-value )\nFMH\nDEFRESP\nConditions: CBIDERR, INVREQ, LENGERR, NOTALLOC, SIGNAL, TERMERR\n \nDescription\nSEND sends data to a conversation partner on an LUTYPE6.1 conversation.\nSEND (SCS)\nWrite data to a 3270 SCS printer logical unit. \nSEND (SCS)\nSEND\nFROM( data-area )\nLENGTH( data-value )\nFLENGTH(  data-value )\nWAIT\nINVITE\nLAST\nCNOTCOMPL\nDEFRESP\nSTRFIELD\nFMH\nConditions: INVREQ, LENGERR, TERMERR\n \nDescription\nSEND writes data to a logical unit. The SCS printer logical unit accepts a character string as defined by\nSystems Network Architecture (SNA). \nSEND (3270 logical)\nWrite data to a 3270 logical unit. \n448  CICS TS for z/OS: API Reference", "output": "SEND (LUTYPE6.1)\nSEND\nSESSION(  name )\nWAIT\nINVITE\nLAST\nATTACHID(  name )\nFROM( data-area )\nLENGTH( data-value )\nFLENGTH(  data-value )\nFMH\nDEFRESP\nConditions: CBIDERR, INVREQ, LENGERR, NOTALLOC, SIGNAL, TERMERR\n \nDescription\nSEND sends data to a conversation partner on an LUTYPE6.1 conversation.\nSEND (SCS)\nWrite data to a 3270 SCS printer logical unit. \nSEND (SCS)\nSEND\nFROM( data-area )\nLENGTH( data-value )\nFLENGTH(  data-value )\nWAIT\nINVITE\nLAST\nCNOTCOMPL\nDEFRESP\nSTRFIELD\nFMH\nConditions: INVREQ, LENGERR, TERMERR\n \nDescription\nSEND writes data to a logical unit. The SCS printer logical unit accepts a character string as defined by\nSystems Network Architecture (SNA). \nSEND (3270 logical)\nWrite data to a 3270 logical unit. \n448  CICS TS for z/OS: API Reference"}
{"instruction": "Explain this COBOL concept", "input": "Related tasks   \n“Coding input-output statements for line-sequential files” on page 231  \n“Handling errors in input and output operations” on page 257 \n234  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "Related tasks   \n“Coding input-output statements for line-sequential files” on page 231  \n“Handling errors in input and output operations” on page 257 \n234  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "Explain this COBOL concept", "input": "IDENTIFICATION\nID\nDIVISION.\nOBJECT.\nDATA DIVISION.\nobject-data-division-content\nPROCEDURE DIVISION.\nmethod-definition\nEND OBJECT.\nEND CLASS\nSpecifies the end of a class definition.\nEND FACTORY\nSpecifies the end of a factory definition.\nEND OBJECT\nSpecifies the end of an object definition.\n94  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "IDENTIFICATION\nID\nDIVISION.\nOBJECT.\nDATA DIVISION.\nobject-data-division-content\nPROCEDURE DIVISION.\nmethod-definition\nEND OBJECT.\nEND CLASS\nSpecifies the end of a class definition.\nEND FACTORY\nSpecifies the end of a factory definition.\nEND OBJECT\nSpecifies the end of an object definition.\n94  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "DISPLAY \"WS-A: \" WS-A.\n   DISPLAY \"WS-B: \" WS-B.\n   DISPLAY \"WS-C: \" WS-C.\nSTOP RUN.\nThe output is a", "output": "DISPLAY \"WS-A: \" WS-A.\n   DISPLAY \"WS-B: \" WS-B.\n   DISPLAY \"WS-C: \" WS-C.\nSTOP RUN.\nThe output is as follows:\nWS-A: 5.6\nWS-B: Hello world\nWS-C: 0\nFormat 2\nThis format associates a value, values, or ranges of values with a condition-name. Each such condition-\nname requires a separate level-88 entry. Level-number 88 and the condition-name are not part of the\nformat-2 VALUE clause itself. They are included in the format only for clarity.\nFormat 2: condition-name value\n88\ncondition-name-1\nVALUE\nIS\nVALUES\nARE\nliteral-1\nTHROUGH\nTHRU\nliteral-2\nWHEN\nSET\nTO\nFALSE\nIS\nliteral-3\n.\ncondition-name-1\nA user-specified name that associates a value with a conditional variable. If the associated conditional\nvariable requires subscripts or indexes, each procedural reference to the condition-name must be\nsubscripted or indexed as required for the conditional variable.\nCondition-names are tested procedurally in condition-name conditions (see “Conditional expressions”\non page 274).\nliteral-1\nAssociates the condition-name with a single value.\nThe class of literal-1 must be a valid class for assignment to the associated conditional variable.\nliteral-1 THROUGH literal-2\nAssociates the condition-name with at least one range of values. When the THROUGH phrase is used,\nliteral-1 must be less than literal-2. For details, see “Rules for condition-name entries” on page 255.\nliteral-1 and literal-2 must be of the same class. The class of literal-1 and literal-2 must be a valid\nclass for assignment to the associated conditional variable.\nWhen literal-1 and literal-2 are DBCS literals, the range of DBCS values specified by the THROUGH\nphrase is based on the binary collating sequence of the hexadecimal values of the DBCS characters.\n254  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "Explain this COBOL concept", "input": "RESET ACTIVITY\nRESET\nACTIVITY(  data-value )\nConditions: ACTIVITYBUSY, ACTIVITYERR, INVREQ, IOERR, LOCKED, NOTAUTH\nDescription\nRESET ACTIVITY resets a BTS child activity to its initial state. Its completion event is added to the\nparent's event pool, with the fired status set to NOTFIRED. If the activity has children of its own, they are\ndeleted.\nNote: RESET has no effect on the contents of the activity's data containers, which are unchanged.\nIssue this command, before a second RUN command, when an activity needs to be retried. When the\nactivity is re-run, it is sent a DFHINITIAL event.\nTo be eligible to be reset, an activity must:\n1. Be a child of the activity that issues the RESET command.\n2. Be in one of the following modes:\n• COMPLETE. This is the usual case. Perhaps the activity has completed abnormally, and needs to be\nreset before being retried.\n• INITIAL. The activity has not yet been run.\nOptions\nACTIVITY(data-value)\nspecifies the name (1–16 characters) of the activity to be reset. This must be a child of the current\nactivity.\nConditions\n107 ACTIVITYBUSY\nRESP2 values:\n19\nThe request timed out. It may be that another task using this activity-record has been prevented\nfrom ending.\n109 ACTIVITYERR\nRESP2 values:\n8\nThe activity named in the ACTIVITY option is not a child of the current activity.\n14\nThe activity to be reset is not in COMPLETE or INITIAL mode.\n16 INVREQ\nRESP2 values:\n4\nThe RESET ACTIVITY command was issued outside the scope of a currently-active activity.\n17 IOERR\nRESP2 values:\n29\nThe repository file is unavailable.\n30\nAn input/output error has occurred on the repository file.\n414  CICS TS for z/OS: API Reference", "output": "RESET ACTIVITY\nRESET\nACTIVITY(  data-value )\nConditions: ACTIVITYBUSY, ACTIVITYERR, INVREQ, IOERR, LOCKED, NOTAUTH\nDescription\nRESET ACTIVITY resets a BTS child activity to its initial state. Its completion event is added to the\nparent's event pool, with the fired status set to NOTFIRED. If the activity has children of its own, they are\ndeleted.\nNote: RESET has no effect on the contents of the activity's data containers, which are unchanged.\nIssue this command, before a second RUN command, when an activity needs to be retried. When the\nactivity is re-run, it is sent a DFHINITIAL event.\nTo be eligible to be reset, an activity must:\n1. Be a child of the activity that issues the RESET command.\n2. Be in one of the following modes:\n• COMPLETE. This is the usual case. Perhaps the activity has completed abnormally, and needs to be\nreset before being retried.\n• INITIAL. The activity has not yet been run.\nOptions\nACTIVITY(data-value)\nspecifies the name (1–16 characters) of the activity to be reset. This must be a child of the current\nactivity.\nConditions\n107 ACTIVITYBUSY\nRESP2 values:\n19\nThe request timed out. It may be that another task using this activity-record has been prevented\nfrom ending.\n109 ACTIVITYERR\nRESP2 values:\n8\nThe activity named in the ACTIVITY option is not a child of the current activity.\n14\nThe activity to be reset is not in COMPLETE or INITIAL mode.\n16 INVREQ\nRESP2 values:\n4\nThe RESET ACTIVITY command was issued outside the scope of a currently-active activity.\n17 IOERR\nRESP2 values:\n29\nThe repository file is unavailable.\n30\nAn input/output error has occurred on the repository file.\n414  CICS TS for z/OS: API Reference"}
{"instruction": "Summarize this COBOL documentation section", "input": "• symbolic-character\n• ALL alphanumeric-literal\nAlphanumeric-edited items\nThe PICTURE character-string can contain the following symbols: A X 9 B 0 /. \nThe string must contain at least one A or X, and at least one B or 0 (zero) or /.\nThe contents of the item in standard data format must be two or more characters from the character set\nof the computer.\nOther clauses\nUSAGE DISPLAY must be specified or implied.\nAny associated VALUE clause must specify an alphanumeric literal or or one of the following figurative\nconstants:\n• ZERO\n• SPACE\n• QUOTE\n• HIGH-VALUE\n• LOW-VALUE\n• symbolic-character\n• ALL alphanumeric-literal\nThe literal is treated exactly as specified; no editing is done.\nDBCS items\nThe PICTURE character-string can contain the symbols G, G and B, or N. Each G, B, or N represents a single\nDBCS character position.\nAny associated VALUE clause must contain a DBCS literal, the figurative constant SPACE, or the figurative\nconstant ALL DBCS-literal.\nOther clauses\nWhen PICTURE symbol G is used, USAGE DISPLAY-1 must be specified. When PICTURE symbol N is\nused and the NSYMBOL(DBCS) compiler option is in effect, USAGE DISPLAY-1 is implied if the USAGE\nclause is omitted.\nExternal floating-point items\nA data item is described as category external floating-point by its PICTURE character-string. \nThe PICTURE character-string details are described here.\nFormat\n + \n - \nmantissa E\n + \n - \nexponent\n+ or -\nA sign character must immediately precede both the mantissa and the exponent.\nA + sign indicates that a positive sign will be used in the output to represent positive values and that a\nnegative sign will represent negative values.\n218  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "• symbolic-character\n• ALL alphanumeric-literal\nAlphanumeric-edited items\nThe PICTURE character-string can contain the following symbols: A X 9 B 0 /. \nThe string must contain at least one A or X, and at least one B or 0 (zero) or /.\nThe contents of the item in standard data format must be two or more characters from the character set\nof the computer.\nOther clauses\nUSAGE DISPLAY must be specified or implied.\nAny associated VALUE clause must specify an alphanumeric literal or or one of the following figurative\nconstants:\n• ZERO\n• SPACE\n• QUOTE\n• HIGH-VALUE\n• LOW-VALUE\n• symbolic-character\n• ALL alphanumeric-literal\nThe literal is treated exactly as specified; no editing is done.\nDBCS items\nThe PICTURE character-string can contain the symbols G, G and B, or N. Each G, B, or N represents a single\nDBCS character position.\nAny associated VALUE clause must contain a DBCS literal, the figurative constant SPACE, or the figurative\nconstant ALL DBCS-literal.\nOther clauses\nWhen PICTURE symbol G is used, USAGE DISPLAY-1 must be specified. When PICTURE symbol N is\nused and the NSYMBOL(DBCS) compiler option is in effect, USAGE DISPLAY-1 is implied if the USAGE\nclause is omitted.\nExternal floating-point items\nA data item is described as category external floating-point by its PICTURE character-string. \nThe PICTURE character-string details are described here.\nFormat\n + \n - \nmantissa E\n + \n - \nexponent\n+ or -\nA sign character must immediately precede both the mantissa and the exponent.\nA + sign indicates that a positive sign will be used in the output to represent positive values and that a\nnegative sign will represent negative values.\n218  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "Summarize this COBOL documentation section", "input": "Appendix H. Using sample programs\nThe sample programs, which are included on your product tape, demonstrate many language elements\nand concepts of COBOL.\nThis information contains the following items:\n• Overview of the programs, including program charts for two of the samples\n• Format and sample of the input data\n• Sample of reports produced\n• Information about how to run the programs\n• List of the language elements and concepts that are illustrated\nPseudocode and other comments about the programs are included in the program prolog, which you can\nobtain in a program listing.\nThere are three sample programs:\n• IGYTCARA is an example of using QSAM files and VSAM indexed files, and shows how to use many\nCOBOL intrinsic functions.\n• IGYTCARB is an example of using IBM Interactive System Product Facility (ISPF).\n• IGYTSALE is an example of using several of the features of the Language Environment callable services.\nRelated concepts   \n“IGYTCARA: batch application” on page 973  \n“IGYTCARB: interactive program” on page 977  \n“IGYTSALE: nested program\napplication” on page 979 \nIGYTCARA: batch application\nA company that has several local offices wants to establish employee carpools. Application IGYTCARA\nvalidates the transaction-file entries (QSAM sequential file processing) and updates a main file (VSAM\nindexed file processing).\nThis batch application does two tasks:\n• Produces reports of employees who can share rides from the same home location to the same work\nlocation\n• Updates the carpool data:\n– Adds data for new employees\n– Changes information for participating employees\n– Deletes employee records\n– Lists update requests that are not valid\nThe following diagram shows the parts of the application and how they are organized:\n© Copyright IBM Corp. 1991, 2025\n973", "output": "Appendix H. Using sample programs\nThe sample programs, which are included on your product tape, demonstrate many language elements\nand concepts of COBOL.\nThis information contains the following items:\n• Overview of the programs, including program charts for two of the samples\n• Format and sample of the input data\n• Sample of reports produced\n• Information about how to run the programs\n• List of the language elements and concepts that are illustrated\nPseudocode and other comments about the programs are included in the program prolog, which you can\nobtain in a program listing.\nThere are three sample programs:\n• IGYTCARA is an example of using QSAM files and VSAM indexed files, and shows how to use many\nCOBOL intrinsic functions.\n• IGYTCARB is an example of using IBM Interactive System Product Facility (ISPF).\n• IGYTSALE is an example of using several of the features of the Language Environment callable services.\nRelated concepts   \n“IGYTCARA: batch application” on page 973  \n“IGYTCARB: interactive program” on page 977  \n“IGYTSALE: nested program\napplication” on page 979 \nIGYTCARA: batch application\nA company that has several local offices wants to establish employee carpools. Application IGYTCARA\nvalidates the transaction-file entries (QSAM sequential file processing) and updates a main file (VSAM\nindexed file processing).\nThis batch application does two tasks:\n• Produces reports of employees who can share rides from the same home location to the same work\nlocation\n• Updates the carpool data:\n– Adds data for new employees\n– Changes information for participating employees\n– Deletes employee records\n– Lists update requests that are not valid\nThe following diagram shows the parts of the application and how they are organized:\n© Copyright IBM Corp. 1991, 2025\n973"}
{"instruction": "Explain this COBOL concept", "input": "8\nInterface already in use by current task.\nAlso occurs (RESP2 not set) in the following situation:\n• The JES/input single thread within the JES interface was not available.\n89 SPOLERR\noccurs in the following situation:\n• The subsystem interface macro (IEFSSREQ) has failed. No input data set name was selected.\nRESP2 gives the 'IEFSSREQ' response code.\n86 STRELERR\noccurs in the following situation:\n• A FREEMAIN has failed within the JES interface subtask (DFHPSPSS).\nRESP2 gives the FREEMAIN register 15 return code.\nSTART\nStart a task at a specified time.\nSee also:\n• START ATTACH\n• START BREXIT\n• START CHANNEL\nChapter 2. CICS command summary  521", "output": "8\nInterface already in use by current task.\nAlso occurs (RESP2 not set) in the following situation:\n• The JES/input single thread within the JES interface was not available.\n89 SPOLERR\noccurs in the following situation:\n• The subsystem interface macro (IEFSSREQ) has failed. No input data set name was selected.\nRESP2 gives the 'IEFSSREQ' response code.\n86 STRELERR\noccurs in the following situation:\n• A FREEMAIN has failed within the JES interface subtask (DFHPSPSS).\nRESP2 gives the FREEMAIN register 15 return code.\nSTART\nStart a task at a specified time.\nSee also:\n• START ATTACH\n• START BREXIT\n• START CHANNEL\nChapter 2. CICS command summary  521"}
{"instruction": "Explain this COBOL concept", "input": "Chapter 94. TAN\nThe TAN function returns a numeric value that approximates the tangent of the angle or arc that is\nspecified by the argument in radians.\nThe function type is numeric.\nFormat\nFUNCTION TAN\n(\nargument-1\n)\nargument-1\nMust be class numeric.\nThe returned value is the approximation of the tangent of argument-1.\n© Copyright IBM Corp. 1991, 2025\n653", "output": "Chapter 94. TAN\nThe TAN function returns a numeric value that approximates the tangent of the angle or arc that is\nspecified by the argument in radians.\nThe function type is numeric.\nFormat\nFUNCTION TAN\n(\nargument-1\n)\nargument-1\nMust be class numeric.\nThe returned value is the approximation of the tangent of argument-1.\n© Copyright IBM Corp. 1991, 2025\n653"}
{"instruction": "Explain this COBOL concept", "input": "Chapter 100. TEST-NUMVAL-F\nThe TEST-NUMVAL-F function verifies that the contents of argument-1 conform to the specification for\nargument-1 of the NUMVAL-F function.\nThe function type is integer.\nFormat\nFUNCTION TEST-NUMVAL-F\n(\nargument-1\n)\nargument-1\nMust be an alphanumeric literal, a national literal, or a data item of class alphanumeric or class\nnational.\nThe returned value is as follows:\n• If the content of argument-1 conforms to the argument rules for the NUMVAL-F function, the returned\nvalue is 0.\n• If one or more characters are in error, the returned value is the position of the first character in error.\nNotes:\n– If one or more spaces are embedded within a string of numeric characters, the returned value is the\nposition of the first non-space character following the spaces, because one or more spaces following\none or more digits is valid. For example, if argument-1 is '0 1', the returned value will be 3.\n– If the ARITH(COMPAT) compiler option is in effect, the returned value is the position of the 19th digit\nif no prior error is found, because the character in error for an argument that is greater than 18 digits\nis the 19th digit.\n– If the ARITH(EXTEND) compiler option is in effect, the returned value is the position of the 32nd digit\nif no prior error is found, because the character in error for an argument that is greater than 31 digits\nis the 32nd digit.\n– If the exponent value in the argument contains more than four significant digits, the returned value is\nthe position of the fifth digit of the exponent.\n• Otherwise, the returned value is (FUNCTION LENGTH (argument-1) + 1).\nThese errors include, but are not limited to:\n– argument-1 is zero-length.\n– argument-1 contains only spaces.\n– argument-1 contains valid characters but is incomplete, such as the string ' +.'.\n© Copyright IBM Corp. 1991, 2025\n665", "output": "Chapter 100. TEST-NUMVAL-F\nThe TEST-NUMVAL-F function verifies that the contents of argument-1 conform to the specification for\nargument-1 of the NUMVAL-F function.\nThe function type is integer.\nFormat\nFUNCTION TEST-NUMVAL-F\n(\nargument-1\n)\nargument-1\nMust be an alphanumeric literal, a national literal, or a data item of class alphanumeric or class\nnational.\nThe returned value is as follows:\n• If the content of argument-1 conforms to the argument rules for the NUMVAL-F function, the returned\nvalue is 0.\n• If one or more characters are in error, the returned value is the position of the first character in error.\nNotes:\n– If one or more spaces are embedded within a string of numeric characters, the returned value is the\nposition of the first non-space character following the spaces, because one or more spaces following\none or more digits is valid. For example, if argument-1 is '0 1', the returned value will be 3.\n– If the ARITH(COMPAT) compiler option is in effect, the returned value is the position of the 19th digit\nif no prior error is found, because the character in error for an argument that is greater than 18 digits\nis the 19th digit.\n– If the ARITH(EXTEND) compiler option is in effect, the returned value is the position of the 32nd digit\nif no prior error is found, because the character in error for an argument that is greater than 31 digits\nis the 32nd digit.\n– If the exponent value in the argument contains more than four significant digits, the returned value is\nthe position of the fifth digit of the exponent.\n• Otherwise, the returned value is (FUNCTION LENGTH (argument-1) + 1).\nThese errors include, but are not limited to:\n– argument-1 is zero-length.\n– argument-1 contains only spaces.\n– argument-1 contains valid characters but is incomplete, such as the string ' +.'.\n© Copyright IBM Corp. 1991, 2025\n665"}
{"instruction": "What is NAMES paragraph in COBOL?", "input": "", "output": "NAMES paragraph is name of an ENVIRONMENT DIVISION paragraph in which\nenvironment-names are related to user-specified mnemonic-names"}
{"instruction": "Summarize this COBOL documentation section", "input": "Chapter 20. COBOL compiler and runtime options\nThis section provides detailed information on the options available for the COBOL compiler and COBOL\nruntime environment.\nCOBOL compiler options\nYou can direct and control your compilation by using compiler options or by using compiler-directing\nstatements (compiler directives).\nCompiler options affect the aspects of your program that are listed in the table below. The linked-to\ninformation for each option provides the syntax for specifying the option and describes the option, its\nparameters, and its interaction with other parameters.\nTable 47. Compiler options\nAspect of your\nprogram\nCompiler option\nDefault\nOption abbreviations\nSource language\n“APOST/QUOTE” on page\n361\nQUOTE\nAPOST | Q\n“ARITH” on page 363\nARITH(COMPAT)\nAR(C | E)\n“CICS” on page 366\nNOCICS\nNone\n“CODEPAGE” on page 367\nCODEPAGE(1140)\nCP(ccsid)\n“CURRENCY” on page 372\nNOCURRENCY\nCURR | NOCURR\n“DBCS” on page 374\nDBCS\nNone\n“NSYMBOL” on page 403\nNSYMBOL(NATIONAL)\nNS(DBCS | NAT)\n“NUMBER” on page 404\nNONUMBER\nNUM | NONUM\n“QUALIFY” on page 416\nQUALIFY(COMPAT)\nQUA(C | E)\n“SEQUENCE” on page 421\nSEQUENCE\nSEQ | NOSEQ\n“SQL” on page 424\nNOSQL\nNone\n“SQLCCSID” on page 425\nSQLCCSID\nSQLC | NOSQLC\n“SQLIMS” on page 426\nNOSQLIMS\nNone\n“SUPPRESS” on page 429\nSUPPRESS\nSUPP\n“WORD” on page 442\nNOWORD\nWD | NOWD\n“XMLPARSE” on page 442\nXMLPARSE(XMLSS)\nXP(X) | XP(C)\nDate processing\n“INTDATE” on page 389\nINTDATE(ANSI)\nNone\n© Copyright IBM Corp. 1991, 2025\n353", "output": "Chapter 20. COBOL compiler and runtime options\nThis section provides detailed information on the options available for the COBOL compiler and COBOL\nruntime environment.\nCOBOL compiler options\nYou can direct and control your compilation by using compiler options or by using compiler-directing\nstatements (compiler directives).\nCompiler options affect the aspects of your program that are listed in the table below. The linked-to\ninformation for each option provides the syntax for specifying the option and describes the option, its\nparameters, and its interaction with other parameters.\nTable 47. Compiler options\nAspect of your\nprogram\nCompiler option\nDefault\nOption abbreviations\nSource language\n“APOST/QUOTE” on page\n361\nQUOTE\nAPOST | Q\n“ARITH” on page 363\nARITH(COMPAT)\nAR(C | E)\n“CICS” on page 366\nNOCICS\nNone\n“CODEPAGE” on page 367\nCODEPAGE(1140)\nCP(ccsid)\n“CURRENCY” on page 372\nNOCURRENCY\nCURR | NOCURR\n“DBCS” on page 374\nDBCS\nNone\n“NSYMBOL” on page 403\nNSYMBOL(NATIONAL)\nNS(DBCS | NAT)\n“NUMBER” on page 404\nNONUMBER\nNUM | NONUM\n“QUALIFY” on page 416\nQUALIFY(COMPAT)\nQUA(C | E)\n“SEQUENCE” on page 421\nSEQUENCE\nSEQ | NOSEQ\n“SQL” on page 424\nNOSQL\nNone\n“SQLCCSID” on page 425\nSQLCCSID\nSQLC | NOSQLC\n“SQLIMS” on page 426\nNOSQLIMS\nNone\n“SUPPRESS” on page 429\nSUPPRESS\nSUPP\n“WORD” on page 442\nNOWORD\nWD | NOWD\n“XMLPARSE” on page 442\nXMLPARSE(XMLSS)\nXP(X) | XP(C)\nDate processing\n“INTDATE” on page 389\nINTDATE(ANSI)\nNone\n© Copyright IBM Corp. 1991, 2025\n353"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "FROMCHANNEL(data-value)\nSpecifies the name (1 – 16 characters) of a channel containing data for this", "output": "FROMCHANNEL(data-value)\nSpecifies the name (1 – 16 characters) of a channel containing data for this event. You can specify the\nchannel name DFHTRANSACTION to use the transaction channel.\nFROM(data-area)\nSpecifies a data area containing data for this event.\nFROMLENGTH(data-value)\nSpecifies a fullword binary value that is the length in bytes of the FROM data area.\nConditions\n122 CHANNELERR\nRESP2 values:\n2\nThe channel specified on the FROMCHANNEL option could not be found.\n111 EVENTERR\nRESP2 values:\n6\nThe identifier specified on the EVENT option contains an incorrect character or combination of\ncharacters.\n22 LENGERR\nRESP2 values:\n3\nThe length that you have specified in FROMLENGTH is not greater than zero.\nSIGNOFF\nSign off from a terminal.\nSIGNOFF\nSIGNOFF\nCondition: INVREQ\nThis command is threadsafe.\nDescription\nSIGNOFF enables you to sign off from the terminal or principal facility that you previously signed on to.\nWhen sign-off is complete, the terminal reverts to the security capabilities and operator characteristics\nassociated with the default user for this CICS region. The national language reverts to the national\nlanguage of the default user, if defined, or the national language associated with the definition of the\nterminal.\nWhen this command is executed, CICS immediately recognizes the sign-off and establishes the default\nattributes for the terminal. The transaction (and any associated task-related user exits, function shipping,\nor distributed transaction processing) may have invoked other resource managers (RMs), for example,\nIMS, Db2®, or VSAM. It is unpredictable whether these other RMs recognize the sign-off before the\ntransaction terminates.\nThe default attributes apply for all RMs invoked by subsequent transactions at the terminal.\nConditions\n16 INVREQ\nRESP2 values:\nChapter 2. CICS command summary  491"}
{"instruction": "What are the compiler rules or directives for this?", "input": "are converted in the same way as the other fixed-point numeric items, except for the", "output": "are converted in the same way as the other fixed-point numeric items, except for the"}
{"instruction": "Explain this COBOL concept", "input": "IF statement\nThe IF statement evaluates a condition and provides for alternative actions in the object program,\ndepending on the evaluation.\nFormat\nIF\ncondition-1\nTHEN\nstatement-1\nNEXT SENTENCE\nELSE\nstatement-2\nNEXT SENTENCE\nEND-IF 1\nNotes:\n1 END-IF can be specified with statement-2 or NEXT SENTENCE.\ncondition-1\nCan be any simple or complex condition, as described in “Conditional expressions” on page 274.\nstatement-1, statement-2\nCan be any one of the following options:\n• An imperative statement\n• A conditional statement\n• An imperative statement followed by a conditional statement\nNEXT SENTENCE\nThe NEXT SENTENCE phrase transfers control to an implicit CONTINUE statement immediately\nfollowing the next separator period.\nWhen NEXT SENTENCE is specified with END-IF, control does not pass to the statement following the\nEND-IF. Instead, control passes to the statement after the closest following period.\nEND-IF phrase\nThis explicit scope terminator serves to delimit the scope of the IF statement. END-IF permits a\nconditional IF statement to be nested in another conditional statement. For more information about\nexplicit scope terminators, see “Delimited scope statements” on page 300.\nThe scope of an IF statement can be terminated by any of the following options:\n• An END-IF phrase at the same level of nesting\n• A separator period\n• If nested, by an ELSE phrase associated with an IF statement at a higher level of nesting\nTransferring control\nThe topic describes the actions to take when conditions tested is true or false.\nIf the condition tested is true, one of the following actions takes place:\n• If statement-1 is specified, statement-1 is executed. If statement-1 contains a procedure branching or\nconditional statement, control is transferred according to the rules for that statement. If statement-1\nChapter 28. PROCEDURE DIVISION statements  355", "output": "IF statement\nThe IF statement evaluates a condition and provides for alternative actions in the object program,\ndepending on the evaluation.\nFormat\nIF\ncondition-1\nTHEN\nstatement-1\nNEXT SENTENCE\nELSE\nstatement-2\nNEXT SENTENCE\nEND-IF 1\nNotes:\n1 END-IF can be specified with statement-2 or NEXT SENTENCE.\ncondition-1\nCan be any simple or complex condition, as described in “Conditional expressions” on page 274.\nstatement-1, statement-2\nCan be any one of the following options:\n• An imperative statement\n• A conditional statement\n• An imperative statement followed by a conditional statement\nNEXT SENTENCE\nThe NEXT SENTENCE phrase transfers control to an implicit CONTINUE statement immediately\nfollowing the next separator period.\nWhen NEXT SENTENCE is specified with END-IF, control does not pass to the statement following the\nEND-IF. Instead, control passes to the statement after the closest following period.\nEND-IF phrase\nThis explicit scope terminator serves to delimit the scope of the IF statement. END-IF permits a\nconditional IF statement to be nested in another conditional statement. For more information about\nexplicit scope terminators, see “Delimited scope statements” on page 300.\nThe scope of an IF statement can be terminated by any of the following options:\n• An END-IF phrase at the same level of nesting\n• A separator period\n• If nested, by an ELSE phrase associated with an IF statement at a higher level of nesting\nTransferring control\nThe topic describes the actions to take when conditions tested is true or false.\nIf the condition tested is true, one of the following actions takes place:\n• If statement-1 is specified, statement-1 is executed. If statement-1 contains a procedure branching or\nconditional statement, control is transferred according to the rules for that statement. If statement-1\nChapter 28. PROCEDURE DIVISION statements  355"}
{"instruction": "Explain this COBOL concept", "input": "Table 62. Table of functions (continued)\nFunction name\nArguments\nFunction\ntype\nValue returned\nUUID4\nNone\nX\n36-character alphanumeric string that is a\nversion 4 universally unique identifier (UUID)\nUVALID\nA1, X1, U1,\nor UT1\nI\n0 if A1, X1, U1, or UT1 contains valid Unicode\nUTF-8 or UTF-16 data, or the index of the first\ninvalid element of A1, X1, U1, or UT1\nUWIDTH\nA1, X1, U1,\nor UT1, I2\nI\nWidth in bytes of the I2th UTF-8 or UTF-16\ncharacter of A1, X1, U1, or UT1\nVARIANCE\nN1...\nN\nVariance of arguments\nWHEN-COMPILED\nNone\nX\nDate and time when program was compiled\nYEAR-TO-YYYY\nI1, I2\nI\nExpanded year equivalent (YYYY) of I1\n(windowed year, YY), according to the 100-\nyear interval whose ending year is specified by\nthe sum of I2 and the year at execution time\nChapter 30. Function definitions  525", "output": "Table 62. Table of functions (continued)\nFunction name\nArguments\nFunction\ntype\nValue returned\nUUID4\nNone\nX\n36-character alphanumeric string that is a\nversion 4 universally unique identifier (UUID)\nUVALID\nA1, X1, U1,\nor UT1\nI\n0 if A1, X1, U1, or UT1 contains valid Unicode\nUTF-8 or UTF-16 data, or the index of the first\ninvalid element of A1, X1, U1, or UT1\nUWIDTH\nA1, X1, U1,\nor UT1, I2\nI\nWidth in bytes of the I2th UTF-8 or UTF-16\ncharacter of A1, X1, U1, or UT1\nVARIANCE\nN1...\nN\nVariance of arguments\nWHEN-COMPILED\nNone\nX\nDate and time when program was compiled\nYEAR-TO-YYYY\nI1, I2\nI\nExpanded year equivalent (YYYY) of I1\n(windowed year, YY), according to the 100-\nyear interval whose ending year is specified by\nthe sum of I2 and the year at execution time\nChapter 30. Function definitions  525"}
{"instruction": "What are the compiler rules or directives for this?", "input": "is run asynchronously, the CHECK command could be issued when the requestor", "output": "is run asynchronously, the CHECK command could be issued when the requestor"}
{"instruction": "What is Changes to a COBOL parameter that in COBOL?", "input": "", "output": "Changes to a COBOL parameter that is alphanumeric group item will be reflected in the Java caller.\n732  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference\n\n\nBuilding COBOL native method call stub programs\nThe COBOL native method call stub program, along with any other COBOL stub programs that are\ngenerated by the compiler for the application, must be compiled into a Java native method DLL using\nthe cjbuild tool"}
{"instruction": "Summarize this COBOL documentation section", "input": "RECEIVE (APPC)\nRECEIVE\nCONVID(  name )\nINTO( data-area )\nSET( ptr-ref )\nLENGTH( data-area )\nFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nNOTRUNCATE\nSTATE(  cvda)\nConditions: EOC, INVREQ, LENGERR, NOTALLOC, SIGNAL, TERMERR\n \nDescription\nRECEIVE receives data from the conversation partner in an APPC mapped conversation.\nRECEIVE (LUTYPE2/LUTYPE3)\nReceive data from a 3270-display logical unit (LUTYPE2) or a 3270-printer logical unit (LUTYPE3). \nRECEIVE (LUTYPE2/LUTYPE3)\nRECEIVE\nINTO( data-area )\nSET( ptr-ref )\nLENGTH( data-area )\nFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nASIS\nBUFFER\nNOTRUNCATE\nConditions: EOC, INVREQ, LENGERR, TERMERR\n \nDescription\nRECEIVE receives data from the terminal.\nIf data is to be received, you must specify either the INTO or the SET option. If a RECEIVE is issued purely\nto detect an attention identifier (AID) (and BUFFER has not been specified), you can omit both the INTO\nand SET options.\nRECEIVE (LUTYPE4)\nReceive data from an LUTYPE4 logical unit. \n384  CICS TS for z/OS: API Reference", "output": "RECEIVE (APPC)\nRECEIVE\nCONVID(  name )\nINTO( data-area )\nSET( ptr-ref )\nLENGTH( data-area )\nFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nNOTRUNCATE\nSTATE(  cvda)\nConditions: EOC, INVREQ, LENGERR, NOTALLOC, SIGNAL, TERMERR\n \nDescription\nRECEIVE receives data from the conversation partner in an APPC mapped conversation.\nRECEIVE (LUTYPE2/LUTYPE3)\nReceive data from a 3270-display logical unit (LUTYPE2) or a 3270-printer logical unit (LUTYPE3). \nRECEIVE (LUTYPE2/LUTYPE3)\nRECEIVE\nINTO( data-area )\nSET( ptr-ref )\nLENGTH( data-area )\nFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nASIS\nBUFFER\nNOTRUNCATE\nConditions: EOC, INVREQ, LENGERR, TERMERR\n \nDescription\nRECEIVE receives data from the terminal.\nIf data is to be received, you must specify either the INTO or the SET option. If a RECEIVE is issued purely\nto detect an attention identifier (AID) (and BUFFER has not been specified), you can omit both the INTO\nand SET options.\nRECEIVE (LUTYPE4)\nReceive data from an LUTYPE4 logical unit. \n384  CICS TS for z/OS: API Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Part 7. Intrinsic functions\nAn intrinsic function is a function that performs a mathematical, charac", "output": "Part 7. Intrinsic functions\nAn intrinsic function is a function that performs a mathematical, character, or logical operation. You can\nuse intrinsic functions to make reference to a data item whose value is derived automatically during\nexecution.\nData processing problems often require the use of values that are not directly accessible in the data\nstorage associated with the object program, but instead must be derived through performing operations\non other data. An intrinsic function is a function that performs a mathematical, character, or logical\noperation, and thereby allows you to make reference to a data item whose value is derived automatically\nduring execution.\nThe intrinsic functions can be grouped into six categories, based on the type of service performed:\n• Mathematical\n• Statistical\n• Date/time\n• Financial\n• Character-handling\n• General\nYou can reference a function by specifying its name, along with any required arguments, in a PROCEDURE\nDIVISION statement.\nFunctions are elementary data items, and return alphanumeric character, national character, numeric, or\ninteger values. Functions cannot serve as receiving operands.\n© Copyright IBM Corp. 1991, 2025\n505"}
{"instruction": "What are the compiler rules or directives for this?", "input": "and the HEAP runtime option control whether storage", "output": "and the HEAP runtime option control whether storage"}
{"instruction": "Explain this COBOL concept", "input": "The following example shows the DISPLAY output with the DISPSIGN(COMPAT) option or the\nDISPSIGN(SEP) option specified:\nTable 50. DISPLAY output with the DISPSIGN(COMPAT) option or the DISPSIGN(SEP) option specified:\nData items\nDISPLAY output with the\nDISPSIGN(COMPAT) option\nspecified\nDISPLAY output with\nthe DISPSIGN(SEP) option\nspecified\nUnsigned binary\n111\n111\nPositive binary\n111\n+111\nNegative binary\n11J\n-111\nUnsigned packed-decimal\n222\n222\nPositive packed-decimal\n222\n+222\nNegative packed-decimal\n22K\n-222\nZoned-decimal unsigned\n333\n333\nZoned-decimal trailing positive\n33C\n+333\nZoned-decimal trailing negative\n33L\n-333\nZoned-decimal leading positive\nC33\n+333\nZoned-decimal leading negative\nL33\n-333\nDLL\nUse DLL to instruct the compiler to generate an object module that is enabled for dynamic link library\n(DLL) support. DLL enablement is required if the program will be part of a DLL, will reference DLLs, or if\nthe program contains object-oriented COBOL syntax such as INVOKE statements or class definitions.\nNote: The DLL option can be overridden for particular CALL statements by using the CALLINTERFACE\ndirective.\nDLL option syntax\nNODLL\nDLL\nDefault is: NODLL\nAbbreviations are: None\nLink-edit considerations: COBOL programs that are compiled with the DLL option must be link-edited\nwith the RENT and AMODE 31 link-edit options.\nNODLL instructs the compiler to generate an object module that is not enabled for DLL usage.\nAMODE 64 considerations: When the LP(64) compiler option is in effect, the DLL and NODLL options are\nignored and the default NODLL is effectively set because object files generated using LP(64) are always\nDLL enabled. They can be linked as DLL or non-DLL.\nThe EXPORTALL option is supported. Use this option to export symbols from programs when building\nDLLs.\nChapter 20. COBOL compiler and runtime options  377", "output": "The following example shows the DISPLAY output with the DISPSIGN(COMPAT) option or the\nDISPSIGN(SEP) option specified:\nTable 50. DISPLAY output with the DISPSIGN(COMPAT) option or the DISPSIGN(SEP) option specified:\nData items\nDISPLAY output with the\nDISPSIGN(COMPAT) option\nspecified\nDISPLAY output with\nthe DISPSIGN(SEP) option\nspecified\nUnsigned binary\n111\n111\nPositive binary\n111\n+111\nNegative binary\n11J\n-111\nUnsigned packed-decimal\n222\n222\nPositive packed-decimal\n222\n+222\nNegative packed-decimal\n22K\n-222\nZoned-decimal unsigned\n333\n333\nZoned-decimal trailing positive\n33C\n+333\nZoned-decimal trailing negative\n33L\n-333\nZoned-decimal leading positive\nC33\n+333\nZoned-decimal leading negative\nL33\n-333\nDLL\nUse DLL to instruct the compiler to generate an object module that is enabled for dynamic link library\n(DLL) support. DLL enablement is required if the program will be part of a DLL, will reference DLLs, or if\nthe program contains object-oriented COBOL syntax such as INVOKE statements or class definitions.\nNote: The DLL option can be overridden for particular CALL statements by using the CALLINTERFACE\ndirective.\nDLL option syntax\nNODLL\nDLL\nDefault is: NODLL\nAbbreviations are: None\nLink-edit considerations: COBOL programs that are compiled with the DLL option must be link-edited\nwith the RENT and AMODE 31 link-edit options.\nNODLL instructs the compiler to generate an object module that is not enabled for DLL usage.\nAMODE 64 considerations: When the LP(64) compiler option is in effect, the DLL and NODLL options are\nignored and the default NODLL is effectively set because object files generated using LP(64) are always\nDLL enabled. They can be linked as DLL or non-DLL.\nThe EXPORTALL option is supported. Use this option to export symbols from programs when building\nDLLs.\nChapter 20. COBOL compiler and runtime options  377"}
{"instruction": "Summarize this COBOL documentation section", "input": "Table 136. SYSADATA parse tree record (continued)\nField\nSize\nDescription\n0019\nDEBUGGING\n0020\nSEQUENCE\n0021\nReserved for future use\n0022\nReserved for future use\n0023\nReserved for future use\n0024\nTALLYING\n0025\nReserved for future use\n0026\nON SIZE ERROR\n0027\nON OVERFLOW\n0028\nON ERROR\n0029\nAT END\n0030\nINVALID KEY\n0031\nEND-OF-PAGE\n0032\nUSING\nAppendix G. COBOL SYSADATA file contents  913", "output": "Table 136. SYSADATA parse tree record (continued)\nField\nSize\nDescription\n0019\nDEBUGGING\n0020\nSEQUENCE\n0021\nReserved for future use\n0022\nReserved for future use\n0023\nReserved for future use\n0024\nTALLYING\n0025\nReserved for future use\n0026\nON SIZE ERROR\n0027\nON OVERFLOW\n0028\nON ERROR\n0029\nAT END\n0030\nINVALID KEY\n0031\nEND-OF-PAGE\n0032\nUSING\nAppendix G. COBOL SYSADATA file contents  913"}
{"instruction": "Explain this COBOL concept", "input": "GDS ISSUE SIGNAL\nRequest a change of direction from the sending transaction APPC basic conversation (assembler-\nlanguage and C programs only).\nGDS ISSUE SIGNAL (APPC basic)\nGDS ISSUE SIGNAL\nCONVID(  name )\nCONVDATA(  data-area )\nRETCODE(  data-area )\nSTATE(  cvda)\nDescription\nGDS ISSUE SIGNAL requests a change of direction.\nThe return code is given in RETCODE (see Table 11 on page 212). For a list of return code values, see the\nReturn codes for APPC basic conversations. EXEC CICS conditions are never raised on GDS commands.\nOptions\nIn general, the arguments can be replaced by absolute or relocatable assembler-language expressions.\nCONVDATA(data-area)\nspecifies the 24-byte application data area into which conversation-related information is to be\nmoved. A description of the format of the data area is given in the discussion of CONVDATA fields in\nthe Testing indicators.\nCONVID(name)\nidentifies the conversation to which the command relates. The 4-character name identifies either the\ntoken returned by a previously executed GDS ALLOCATE command, or the token representing the\nprincipal session (returned by a previously executed GDS ASSIGN command).\nRETCODE(data-area)\nspecifies the 6-byte application data area into which return code information (shown in Table 11 on\npage 212) is to be moved.\nSTATE(cvda)\ngets the state of the current conversation. The cvda values returned by CICS are:\n• ALLOCATED \n• CONFFREE \n• CONFRECEIVE \n• CONFSEND \n• FREE \n• PENDFREE \n• PENDRECEIVE \n• RECEIVE \n• ROLLBACK \n• SEND \n• SYNCFREE \n• SYNCRECEIVE \n• SYNCSEND \nChapter 2. CICS command summary  211", "output": "GDS ISSUE SIGNAL\nRequest a change of direction from the sending transaction APPC basic conversation (assembler-\nlanguage and C programs only).\nGDS ISSUE SIGNAL (APPC basic)\nGDS ISSUE SIGNAL\nCONVID(  name )\nCONVDATA(  data-area )\nRETCODE(  data-area )\nSTATE(  cvda)\nDescription\nGDS ISSUE SIGNAL requests a change of direction.\nThe return code is given in RETCODE (see Table 11 on page 212). For a list of return code values, see the\nReturn codes for APPC basic conversations. EXEC CICS conditions are never raised on GDS commands.\nOptions\nIn general, the arguments can be replaced by absolute or relocatable assembler-language expressions.\nCONVDATA(data-area)\nspecifies the 24-byte application data area into which conversation-related information is to be\nmoved. A description of the format of the data area is given in the discussion of CONVDATA fields in\nthe Testing indicators.\nCONVID(name)\nidentifies the conversation to which the command relates. The 4-character name identifies either the\ntoken returned by a previously executed GDS ALLOCATE command, or the token representing the\nprincipal session (returned by a previously executed GDS ASSIGN command).\nRETCODE(data-area)\nspecifies the 6-byte application data area into which return code information (shown in Table 11 on\npage 212) is to be moved.\nSTATE(cvda)\ngets the state of the current conversation. The cvda values returned by CICS are:\n• ALLOCATED \n• CONFFREE \n• CONFRECEIVE \n• CONFSEND \n• FREE \n• PENDFREE \n• PENDRECEIVE \n• RECEIVE \n• ROLLBACK \n• SEND \n• SYNCFREE \n• SYNCRECEIVE \n• SYNCSEND \nChapter 2. CICS command summary  211"}
{"instruction": "What is which in COBOL?", "input": "", "output": "which is only program that is part of this current application, and then you can invoke cjbuild as\nfollows:\ncjbuild -v -i COBPROG app1\nThe -i/--progid option can be specified once for each COBOL program in your application, just like the\nprogram file can contain the name of each COBOL program in your application"}
{"instruction": "What are the compiler rules or directives for this?", "input": "(CBL) statement” on page 288  \n“Specifying compiler options in a batch compilation” on page 292", "output": "(CBL) statement” on page 288  \n“Specifying compiler options in a batch compilation” on page 292"}
{"instruction": "Explain this COBOL concept", "input": "Chapter 26. DATA DIVISION--data description entry\nA data description entry specifies the characteristics of a data item. In the sections that follow, sets of\ndata description entries are called record description entries. The term data description entry refers to\ndata and record description entries.\nData description entries that define independent data items do not make up a record. These entries are\nknown as data item description entries.\nData description entries have three general formats, and all data description entries must end with a\nseparator period.\nFormat 1\nFormat 1 is used for data description entries in all DATA DIVISION sections.\nFormat 1: data description entry\nlevel-number\ndata-name-1\nFILLER\nredefines-clause\nblank-when-zero-clause\ndynamic-length-clause\nexternal-clause\nglobal-clause\ngroup-usage-clause\njustified-clause\noccurs-clause\npicture-clause\nsign-clause\nsynchronized-clause\nusage-clause\nvalue-clause\nvolatile-clause\nThe clauses can be written in any order, with the following exceptions:\n• data-name-1 or FILLER, if specified, must immediately follow the level-number.\n• When the REDEFINES clause is specified, it must immediately follow data-name-1 or FILLER, if either\nis specified. If data-name-1 or FILLER is not specified, the REDEFINES clause must immediately follow\nthe level-number.\nThe level-number in format 1 can be any number in the range 01–49, or 77.\nA space, a comma, or a semicolon must separate clauses.\nFormat 2\nFormat 2 regroups previously defined items.\nFormat 2: renames\n66\ndata-name-1\nrenames-clause.\n© Copyright IBM Corp. 1991, 2025\n197", "output": "Chapter 26. DATA DIVISION--data description entry\nA data description entry specifies the characteristics of a data item. In the sections that follow, sets of\ndata description entries are called record description entries. The term data description entry refers to\ndata and record description entries.\nData description entries that define independent data items do not make up a record. These entries are\nknown as data item description entries.\nData description entries have three general formats, and all data description entries must end with a\nseparator period.\nFormat 1\nFormat 1 is used for data description entries in all DATA DIVISION sections.\nFormat 1: data description entry\nlevel-number\ndata-name-1\nFILLER\nredefines-clause\nblank-when-zero-clause\ndynamic-length-clause\nexternal-clause\nglobal-clause\ngroup-usage-clause\njustified-clause\noccurs-clause\npicture-clause\nsign-clause\nsynchronized-clause\nusage-clause\nvalue-clause\nvolatile-clause\nThe clauses can be written in any order, with the following exceptions:\n• data-name-1 or FILLER, if specified, must immediately follow the level-number.\n• When the REDEFINES clause is specified, it must immediately follow data-name-1 or FILLER, if either\nis specified. If data-name-1 or FILLER is not specified, the REDEFINES clause must immediately follow\nthe level-number.\nThe level-number in format 1 can be any number in the range 01–49, or 77.\nA space, a comma, or a semicolon must separate clauses.\nFormat 2\nFormat 2 regroups previously defined items.\nFormat 2: renames\n66\ndata-name-1\nrenames-clause.\n© Copyright IBM Corp. 1991, 2025\n197"}
{"instruction": "What is suppose you have nested IF statements in which there in COBOL?", "input": "", "output": "suppose you have nested IF statements in which there is action for only one of the\nprocessing choices"}
{"instruction": "Explain this COBOL concept", "input": "Chapter 61. INTEGER-OF-DAY\nThe INTEGER-OF-DAY function converts a date in the Gregorian calendar from Julian date form\n(YYYYDDD) to integer date form.\nThe function type is integer.\nThe function result is a seven-digit integer.\nFormat\nFUNCTION INTEGER-OF-DAY\n(\nargument-1\n)\nargument-1\nMust be an integer of the form YYYYDDD whose value is obtained from the calculation (YYYY * 1000)\n+ DDD, where:\n• YYYY represents the year in the Gregorian calendar. It must be an integer greater than 1600, but not\ngreater than 9999.\n• DDD represents the day of the year. It must be a positive integer less than 367, provided that it is\nvalid for the year specified.\nThe returned value is an integer that is the number of days that the date represented by argument-1\nsucceeds December 31, 1600 in the Gregorian calendar.\nThe INTDATE compiler option affects the starting date for the integer date functions. For details, see\nINTDATE in the Enterprise COBOL Programming Guide.\n© Copyright IBM Corp. 1991, 2025\n587", "output": "Chapter 61. INTEGER-OF-DAY\nThe INTEGER-OF-DAY function converts a date in the Gregorian calendar from Julian date form\n(YYYYDDD) to integer date form.\nThe function type is integer.\nThe function result is a seven-digit integer.\nFormat\nFUNCTION INTEGER-OF-DAY\n(\nargument-1\n)\nargument-1\nMust be an integer of the form YYYYDDD whose value is obtained from the calculation (YYYY * 1000)\n+ DDD, where:\n• YYYY represents the year in the Gregorian calendar. It must be an integer greater than 1600, but not\ngreater than 9999.\n• DDD represents the day of the year. It must be a positive integer less than 367, provided that it is\nvalid for the year specified.\nThe returned value is an integer that is the number of days that the date represented by argument-1\nsucceeds December 31, 1600 in the Gregorian calendar.\nThe INTDATE compiler option affects the starting date for the integer date functions. For details, see\nINTDATE in the Enterprise COBOL Programming Guide.\n© Copyright IBM Corp. 1991, 2025\n587"}
{"instruction": "Summarize this COBOL documentation section", "input": "2\nThe FROMCCSID option was specified without the CHANNEL option, and there is no current\nchannel (because the program that issued the command was not passed one.) FROMCCSID is\nvalid only on PUT CONTAINER commands that specify (explicitly or implicitly) a channel. It is not\nvalid on PUT CONTAINER (BTS) commands.\n4\nThe command was issued outside the scope of a currently-active activity.\n15\nThe ACQPROCESS option was used, but the unit of work that issued the request has not acquired a\nprocess.\n24\nThe ACQACTIVITY option was used, but the unit of work that issued the request has not acquired\nan activity.\n25\nThe PROCESS option was used, but the command was issued outside the scope of a currently-\nactive process.\n17 IOERR\nRESP2 values:\n30\nAn input/output error has occurred on the repository file.\n31\nThe record on the repository file is in use.\n100 LOCKED\nThe request cannot be performed because a retained lock exists against the relevant record on the\nrepository file.\n106 PROCESSBUSY\nRESP2 values:\n13\nThe request could not be satisfied because the process record is locked by another task.\nPUT CONTAINER (CHANNEL)\nPlace data in a named channel container.\nPUT CONTAINER (CHANNEL)\nPUT\nCONTAINER(  data-value )\nCHANNEL(  data-value )\nFROM( data-area )\nFLENGTH(  data-value )\nBIT\nDATATYPE(  cvda)\nCHAR\nFROMCCSID(  data-value )\nFROMCODEPAGE(  data-value )\nAPPEND\nConditions: CCSIDERR, CHANNELERR, CODEPAGEERR, CONTAINERERR, INVREQ, LENGERR\nThis command is threadsafe.\n332  CICS TS for z/OS: API Reference", "output": "2\nThe FROMCCSID option was specified without the CHANNEL option, and there is no current\nchannel (because the program that issued the command was not passed one.) FROMCCSID is\nvalid only on PUT CONTAINER commands that specify (explicitly or implicitly) a channel. It is not\nvalid on PUT CONTAINER (BTS) commands.\n4\nThe command was issued outside the scope of a currently-active activity.\n15\nThe ACQPROCESS option was used, but the unit of work that issued the request has not acquired a\nprocess.\n24\nThe ACQACTIVITY option was used, but the unit of work that issued the request has not acquired\nan activity.\n25\nThe PROCESS option was used, but the command was issued outside the scope of a currently-\nactive process.\n17 IOERR\nRESP2 values:\n30\nAn input/output error has occurred on the repository file.\n31\nThe record on the repository file is in use.\n100 LOCKED\nThe request cannot be performed because a retained lock exists against the relevant record on the\nrepository file.\n106 PROCESSBUSY\nRESP2 values:\n13\nThe request could not be satisfied because the process record is locked by another task.\nPUT CONTAINER (CHANNEL)\nPlace data in a named channel container.\nPUT CONTAINER (CHANNEL)\nPUT\nCONTAINER(  data-value )\nCHANNEL(  data-value )\nFROM( data-area )\nFLENGTH(  data-value )\nBIT\nDATATYPE(  cvda)\nCHAR\nFROMCCSID(  data-value )\nFROMCODEPAGE(  data-value )\nAPPEND\nConditions: CCSIDERR, CHANNELERR, CODEPAGEERR, CONTAINERERR, INVREQ, LENGERR\nThis command is threadsafe.\n332  CICS TS for z/OS: API Reference"}
{"instruction": "What is 12\nThe length specified on the DATALENGTH option in COBOL?", "input": "", "output": "12\nThe length specified on the DATALENGTH option is negative value.\n13\nThe length specified on the DATALENGTH option is greater than the length specified on the\nLENGTH option.\n26\nThe COMMAREA address is zero, but the COMMAREA length is nonzero.\n27\nThe INPUTMSG length is less than 0 or greater than 32767"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "RETRIEVE SUBEVENT\nRetrieve the name of the next sub-event in a BTS composite event's sub-event queue", "output": "RETRIEVE SUBEVENT\nRetrieve the name of the next sub-event in a BTS composite event's sub-event queue.\nRETRIEVE SUBEVENT\nRETRIEVE\nSUBEVENT(  data-area )\nEVENT( data-value )\nEVENTTYPE(  cvda)\nConditions: END, EVENTERR, INVREQ\nDescription\nRETRIEVE SUBEVENT:\n• Retrieves the name of the next sub-event in a BTS composite event's sub-event queue.\n• Resets the retrieved sub-event's fire status to NOTFIRED.\n• Causes the composite event's fire status to be re-evaluated.\nThe firing of a composite event results from the firing of a set of one or more sub-events. The names of\nsub-events that have fired are placed on the composite event's sub-event queue, from which they can be\nretrieved, in sequence, by issuing successive RETRIEVE SUBEVENT commands.\nYou can use this command to discover which sub-event or sub-events caused a composite event to fire.\nNote:\n1. The presence of events on the sub-event queue does not imply that the composite event has fired.\n(Some sub-events in the set required to fire the composite event may still be in NOTFIRED state,\nand not yet on the sub-event queue.) To discover whether a composite event has fired, use the TEST\nEVENT command.\n2. Retrieval is destructive; when the name of a fired sub-event is retrieved, that sub-event cannot be\nretrieved again.\n3. Because it resets the fire status of the sub-event, RETRIEVE SUBEVENT causes the fire status of the\ncomposite event to be re-evaluated.\nOptions\nEVENT(data-value)\nspecifies the name (1–16 characters) of the composite event.\nEVENTTYPE(cvda)\nreturns the type of the sub-event. CVDA values are:\nACTIVITY\nActivity completion.\nINPUT\nInput\nTIMER\nTimer.\nSUBEVENT(data-area)\nreturns the 16-character name of the sub-event at the head of the sub-event queue.\nConditions\n83 END\nRESP2 values:\nChapter 2. CICS command summary  425"}
{"instruction": "Summarize this COBOL documentation section", "input": "– SKIP2\n– SKIP3\n– TITLE\n• Debugging lines, which are source lines that have a D in column 7, if WITH DEBUGGING MODE is not\nspecified\nTable 137. SYSADATA token record\nField\nSize\nDescription\nToken number\nFL4\nThe token number within the source file generated by the compiler,\nstarting at 1. Any copybooks have already been included in the\nsource.\nToken code\nHL2\nThe type of token (user-name, literal, reserved word, and so forth).\nFor reserved words, the compiler reserved-word table values are\nused.\nFor PICTURE strings, the special code 0000 is used.\nFor each piece (other than the last) of a continued token, the\nspecial code 3333 is used.\nOtherwise, the following codes are used:\n0001\nACCEPT\n0002\nADD\n0003\nALTER\n0004\nCALL\n0005\nCANCEL\n0007\nCLOSE\n0009\nCOMPUTE\n0011\nDELETE\n0013\nDISPLAY\n0014\nDIVIDE\n0017\nREADY\n0018\nEND-PERFORM\n0019\nENTER\n0020\nENTRY\n926  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "– SKIP2\n– SKIP3\n– TITLE\n• Debugging lines, which are source lines that have a D in column 7, if WITH DEBUGGING MODE is not\nspecified\nTable 137. SYSADATA token record\nField\nSize\nDescription\nToken number\nFL4\nThe token number within the source file generated by the compiler,\nstarting at 1. Any copybooks have already been included in the\nsource.\nToken code\nHL2\nThe type of token (user-name, literal, reserved word, and so forth).\nFor reserved words, the compiler reserved-word table values are\nused.\nFor PICTURE strings, the special code 0000 is used.\nFor each piece (other than the last) of a continued token, the\nspecial code 3333 is used.\nOtherwise, the following codes are used:\n0001\nACCEPT\n0002\nADD\n0003\nALTER\n0004\nCALL\n0005\nCANCEL\n0007\nCLOSE\n0009\nCOMPUTE\n0011\nDELETE\n0013\nDISPLAY\n0014\nDIVIDE\n0017\nREADY\n0018\nEND-PERFORM\n0019\nENTER\n0020\nENTRY\n926  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "Summarize this COBOL documentation section", "input": "Value CVDA\n1130 COMPRESS\n1131 NOCOMPRESS\n1140 AUTOINSTALL\n1141 CORBASERVER\n1142 DB2CONN\n1143 DB2ENTRY\n1144 DISPATCHER\n1145 DOCTEMPLATE\n1146 ENQUEUE\n1147 JOURNALNAME\n1148 JOURNALNUM\n1149 JVMPOOL\n1150 JVMPROFILE\n1151 JVMPROGRAM\n1152 LSRPOOL\n1153 MONITOR\n1154 MVSTCB\n1155 NODE\n1156 RECOVERY\n1157 REQUESTMODEL\n1158 STATS\n1159 STORAGE\n1160 STREAMNAME\n1161 SUBPOOL\n1162 SYSDUMPCODE\n1163 TABLEMGR\n1164 TASKSUBPOOL\n1166 TCPIPSERVICE\n1168 TEMPLATENAME\n1169 TRANCLASS\n1170 TRANDUMPCODE\n1171 TRANSACTION\n1173 URIMAP\n1174 WEBSERVICE\n1175 MQCONN\nChapter 4. CICS-value data areas used by all commands  765", "output": "Value CVDA\n1130 COMPRESS\n1131 NOCOMPRESS\n1140 AUTOINSTALL\n1141 CORBASERVER\n1142 DB2CONN\n1143 DB2ENTRY\n1144 DISPATCHER\n1145 DOCTEMPLATE\n1146 ENQUEUE\n1147 JOURNALNAME\n1148 JOURNALNUM\n1149 JVMPOOL\n1150 JVMPROFILE\n1151 JVMPROGRAM\n1152 LSRPOOL\n1153 MONITOR\n1154 MVSTCB\n1155 NODE\n1156 RECOVERY\n1157 REQUESTMODEL\n1158 STATS\n1159 STORAGE\n1160 STREAMNAME\n1161 SUBPOOL\n1162 SYSDUMPCODE\n1163 TABLEMGR\n1164 TASKSUBPOOL\n1166 TCPIPSERVICE\n1168 TEMPLATENAME\n1169 TRANCLASS\n1170 TRANDUMPCODE\n1171 TRANSACTION\n1173 URIMAP\n1174 WEBSERVICE\n1175 MQCONN\nChapter 4. CICS-value data areas used by all commands  765"}
{"instruction": "What is An implicit scope terminator in COBOL?", "input": "", "output": "An implicit scope terminator is period (.) that ends the scope of all previous statements not yet ended"}
{"instruction": "Summarize this COBOL documentation section", "input": "(7)\nYou can add the COBJVMINITOPTIONS environment variable as shown to set Java system properties\nfor the JVM. The jzos.merge.sysout=true property can be used to merge both System.out and\nSystem.err to go to DD:SYSOUT.\n(8)\nThe JAVAOUT DD and JAVAERR DD statements are not used if\nZUtil.redirectStandardStreams() works properly, so you can point these to DD DUMMY.\nAbout JZOS\nJava Batch Launcher and Toolkit for z/OS (JZOS) is a set of tools that helps you develop z/OS Java\napplications that run in a traditional batch environment, and that access z/OS system services. For details,\nsee the JZOS Installation and User's Guide.\nChapter 41. Communicating with Java methods  763", "output": "(7)\nYou can add the COBJVMINITOPTIONS environment variable as shown to set Java system properties\nfor the JVM. The jzos.merge.sysout=true property can be used to merge both System.out and\nSystem.err to go to DD:SYSOUT.\n(8)\nThe JAVAOUT DD and JAVAERR DD statements are not used if\nZUtil.redirectStandardStreams() works properly, so you can point these to DD DUMMY.\nAbout JZOS\nJava Batch Launcher and Toolkit for z/OS (JZOS) is a set of tools that helps you develop z/OS Java\napplications that run in a traditional batch environment, and that access z/OS system services. For details,\nsee the JZOS Installation and User's Guide.\nChapter 41. Communicating with Java methods  763"}
{"instruction": "Summarize this COBOL documentation section", "input": "Value CVDA\n271 FOUTPUT\n272 FOPEN\n273 FCLOSE\n274 OK\n275 NOWRITE\n275 READONLY\n276 REMOVE\n277 RECOVERED\n282 AINIT\n283 BINIT\n284 AUTOINIT\n285 NOSWITCH\n286 SWITCHNEXT\n287 SWITCHALL\n288 SHUTDOWN\n289 NOSHUTDOWN\n290 RESET\n291 ADD\n292 DELETE\n293 REUSE\n294 NOREUSE\n300 IPV4\n301 IPV6\n302 HOSTNAME\n303 APPLID\n310 INTSTART\n311 INTSTOP\n312 AUXSTART\n313 AUXPAUSE\n314 AUXSTOP\n317 GTFSTART\n318 GTFSTOP\n319 SYSTEMON\n320 SYSTEMOFF\n321 USERON\n746  CICS TS for z/OS: API Reference", "output": "Value CVDA\n271 FOUTPUT\n272 FOPEN\n273 FCLOSE\n274 OK\n275 NOWRITE\n275 READONLY\n276 REMOVE\n277 RECOVERED\n282 AINIT\n283 BINIT\n284 AUTOINIT\n285 NOSWITCH\n286 SWITCHNEXT\n287 SWITCHALL\n288 SHUTDOWN\n289 NOSHUTDOWN\n290 RESET\n291 ADD\n292 DELETE\n293 REUSE\n294 NOREUSE\n300 IPV4\n301 IPV6\n302 HOSTNAME\n303 APPLID\n310 INTSTART\n311 INTSTOP\n312 AUXSTART\n313 AUXPAUSE\n314 AUXSTOP\n317 GTFSTART\n318 GTFSTOP\n319 SYSTEMON\n320 SYSTEMOFF\n321 USERON\n746  CICS TS for z/OS: API Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 47. Compiler options (continued)\nAspect of your\nprogram\nCompiler option\nDefault\nOption abbrevi", "output": "Table 47. Compiler options (continued)\nAspect of your\nprogram\nCompiler option\nDefault\nOption abbreviations\nVirtual storage\nusage\n“BUFSIZE” on page 365\n4096\nBUF\n“DATA” on page 373\nDATA(31)\nNone\n“DYNAM” on page 380\nNODYNAM\nDYN | NODYN\n“RENT” on page 417\nRENT\nNone\n“RMODE” on page 418\nAUTO\nNone\n“STGOPT” on page 428\nNOSTGOPT\nSO | NOSO\nDebugging and\ndiagnostics\n“DIAGTRUNC” on page 376\nNODIAGTRUNC\nDTR | NODTR\n“DUMP” on page 379\nNODUMP\nDU | NODU\n“FLAG” on page 383\nFLAG(I,I)\nF | NOF\n“FLAGSTD” on page 384\nNOFLAGSTD\nNone\n“INITCHECK” on page 387\nNOINITCHECK\nIC | NOIC\n“LSACHECK” on page 398\nNOLSACHECK\nLSAC | NOLSAC\n“RULES” on page 419\nNORULES\nRULES(ENDP,EVENP,LXPRF,\nSLCKB,OOM) |\nRULES(NOENDP,\nNOEVENP,NOLXPRF,NOSLCKB,\nNOOOM,NOUNRA | NOUNRS)\n“SSRANGE” on page 427\nNOSSRANGE\nSSR(ZLEN | NOZLEN,MSG |\nABD) |\nNOSSR\n“TEST” on page 430\nNOTEST\nNone\nOther\n“ADATA” on page 359\nNOADATA\nNone\n“COPYLOC” on page 370\nNOCOPYLOC\nCPLC\n“EXIT” on page 381\nNOEXIT\nNOEX | EX(INX | NOINX,\nLIBX | NOLIBX, PRTX |\nNOPRTX, ADX | NOADX, MSGX\n| NOMSGX)\n“MDECK” on page 401\nNOMDECK\nNOMD | MD | MD(C | NOC)\n“OPTFILE” on page 410\nNone\nNone\n“SMARTBIN” on page 422\nSMARTBIN when LP(32)\nis in effect.\nSMARTBIN is not\nsupported when LP(64)\nis in effect.\nNone\n“THREAD” on page 434\nNOTHREAD\nNone\n“VSAMOPENFS” on page\n441\nVSAMOPENFS(COMPAT)\nVS(C | S)\nInstallation defaults: The default compiler options that were set up when your compiler was installed\nare in effect for your program unless you override those options. (In some installations, certain compiler\n356  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What is the size of the sending field in COBOL?", "input": "", "output": "the size of the sending field is total\nbyte count of all operands listed, with each DBCS character counted as two bytes, plus the necessary shift\ncodes and spaces for DBCS"}
{"instruction": "Summarize this COBOL documentation section", "input": "13\nClose status invalid.\n14\nInvalid code page combination.\n32\nMedia type invalid.\n41\nThe connection has been closed.\n46\nThe SERVERCONV option is invalid.\n72\nStatus code does not support a message body.\n75\nInvalid send sequence.\n77\nChunk incomplete.\n80\nCHARACTERSET cannot be specified with NOSRVCONVERT.\n81\nHOSTCODEPAGE cannot be specified with NOSRVCONVERT.\n85\nChunking cannot be used with non-HTTP messages.\n86\nChunking cannot be used with HTTP/1.0 clients.\n87\nStatus code not allowed.\n88\nHost code page not allowed.\n89\nPrevious send over this connection failed. No further sends permitted.\n90\nSTATUSCODE and STATUSTEXT options not allowed for second or subsequent chunks.\n91\nCHARACTERSET and CLNTCODEPAGE options not allowed for second or subsequent chunks.\n92\nHOSTCODEPAGE option not allowed for second or subsequent chunks.\n93\nMEDIATYPE option not allowed for second or subsequent chunks.\n94\nCLOSESTATUS option not allowed for second or subsequent chunks.\n95\nSERVERCONV option not allowed for second or subsequent chunks.\n120\nThe CHUNKING option is invalid.\n121\nFROMLENGTH option required.\n122\nFROM option required.\n123\nNo message body specified. Use FROM, DOCTOKEN or CHUNKEND.\n650  CICS TS for z/OS: API Reference", "output": "13\nClose status invalid.\n14\nInvalid code page combination.\n32\nMedia type invalid.\n41\nThe connection has been closed.\n46\nThe SERVERCONV option is invalid.\n72\nStatus code does not support a message body.\n75\nInvalid send sequence.\n77\nChunk incomplete.\n80\nCHARACTERSET cannot be specified with NOSRVCONVERT.\n81\nHOSTCODEPAGE cannot be specified with NOSRVCONVERT.\n85\nChunking cannot be used with non-HTTP messages.\n86\nChunking cannot be used with HTTP/1.0 clients.\n87\nStatus code not allowed.\n88\nHost code page not allowed.\n89\nPrevious send over this connection failed. No further sends permitted.\n90\nSTATUSCODE and STATUSTEXT options not allowed for second or subsequent chunks.\n91\nCHARACTERSET and CLNTCODEPAGE options not allowed for second or subsequent chunks.\n92\nHOSTCODEPAGE option not allowed for second or subsequent chunks.\n93\nMEDIATYPE option not allowed for second or subsequent chunks.\n94\nCLOSESTATUS option not allowed for second or subsequent chunks.\n95\nSERVERCONV option not allowed for second or subsequent chunks.\n120\nThe CHUNKING option is invalid.\n121\nFROMLENGTH option required.\n122\nFROM option required.\n123\nNo message body specified. Use FROM, DOCTOKEN or CHUNKEND.\n650  CICS TS for z/OS: API Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 136. SYSADATA parse tree record (continued)\nField\nSize\nDescription\n \n \nFor file description cl", "output": "Table 136. SYSADATA parse tree record (continued)\nField\nSize\nDescription\n \n \nFor file description clause type:\n0001\nFILE STATUS\n0002\nORGANIZATION\n0003\nACCESS MODE\n0004\nRECORD KEY\n0005\nASSIGN\n0006\nRELATIVE KEY\n0007\nPASSWORD\n0008\nPROCESSING MODE\n0009\nRECORD DELIMITER\n0010\nPADDING CHARACTER\n0011\nBLOCK CONTAINS\n0012\nRECORD CONTAINS\n0013\nLABEL RECORDS\nAppendix G. COBOL SYSADATA file contents  907"}
{"instruction": "Explain this COBOL concept", "input": "Invocation parameters:\nNOTERM\nPROCESS(CBL) statements:\nCBL CURRENCY,FLAG(I,I)\nOptions in effect:  All options are installation defaults unless otherwise noted:\n    NOADATA\n      ADV\n      QUOTE \n      ARITH(COMPAT)\n    NOAWO\n    NOBLOCK0\n      BUFSIZE(4096)\n    . . .  \n      CURRENCY      Process option PROGRAM 1\n    . . .\n      FLAG(I,I)     Process option PROGRAM 1\n    . . .\n    NOTERM          INVOCATION option\n    . . .\nEnd of compilation for program 1\n. . .\nPP 5655-EC6 IBM Enterprise COBOL for z/OS  6.5.0 PXXXXXX  Date 05/31/2024. . .\nPROCESS(CBL) statements:\nCBL APOST\nOptions in effect:\n    NOADATA\n      ADV\n    APOST           Process option PROGRAM 2\n      ARITH(COMPAT)\n    NOAWO\n    NOBLOCK0\n      BUFSIZE(4096)\n    . . .\n    NOCURRENCY      Installation default option for PROGRAM 2\n    . . .\n      FLAG(I)       Installation default option\n    . . .\n    NOTERM          INVOCATION option remains in effect\n    . . .\nEnd of compilation for program 2\nExample: LANGUAGE option in a batch compilation\nThe following example shows the behavior of the LANGUAGE compiler option in a batch environment. The\ndefault installation option is ENGLISH (abbreviated EN), and the invocation option is XX, a nonexistent\nlanguage.\nCBL LANG(JP),FLAG(I,I),APOST  (1)\n    IDENTIFICATION DIVISION.            (2)\n    PROGRAM-ID.  COMPILE1.\n    .  .  .\n    END PROGRAM  COMPILE1. \nCBL LANGUAGE(YY)                        (3)\nCBL LANGUAGE(JP),LANG(!!)   (4)\n    IDENTIFICATION DIVISION.            (2)\n    PROGRAM-ID.  COMPILE2.\n    .  .  .\n    END PROGRAM  COMPILE2.\n    IDENTIFICATION DIVISION.\n    PROGRAM-ID.  COMPILE3.\n    .  .  .\n    END PROGRAM  COMPILE3.\nCBL LANGUAGE(JP),LANGUAGE(YY)           (5)\n    .  .  . \n(1)\nThe installation default is EN. The invocation option was XX, a nonexistent language. EN is the\nlanguage in effect.\nChapter 15. Compiling under z/OS  293", "output": "Invocation parameters:\nNOTERM\nPROCESS(CBL) statements:\nCBL CURRENCY,FLAG(I,I)\nOptions in effect:  All options are installation defaults unless otherwise noted:\n    NOADATA\n      ADV\n      QUOTE \n      ARITH(COMPAT)\n    NOAWO\n    NOBLOCK0\n      BUFSIZE(4096)\n    . . .  \n      CURRENCY      Process option PROGRAM 1\n    . . .\n      FLAG(I,I)     Process option PROGRAM 1\n    . . .\n    NOTERM          INVOCATION option\n    . . .\nEnd of compilation for program 1\n. . .\nPP 5655-EC6 IBM Enterprise COBOL for z/OS  6.5.0 PXXXXXX  Date 05/31/2024. . .\nPROCESS(CBL) statements:\nCBL APOST\nOptions in effect:\n    NOADATA\n      ADV\n    APOST           Process option PROGRAM 2\n      ARITH(COMPAT)\n    NOAWO\n    NOBLOCK0\n      BUFSIZE(4096)\n    . . .\n    NOCURRENCY      Installation default option for PROGRAM 2\n    . . .\n      FLAG(I)       Installation default option\n    . . .\n    NOTERM          INVOCATION option remains in effect\n    . . .\nEnd of compilation for program 2\nExample: LANGUAGE option in a batch compilation\nThe following example shows the behavior of the LANGUAGE compiler option in a batch environment. The\ndefault installation option is ENGLISH (abbreviated EN), and the invocation option is XX, a nonexistent\nlanguage.\nCBL LANG(JP),FLAG(I,I),APOST  (1)\n    IDENTIFICATION DIVISION.            (2)\n    PROGRAM-ID.  COMPILE1.\n    .  .  .\n    END PROGRAM  COMPILE1. \nCBL LANGUAGE(YY)                        (3)\nCBL LANGUAGE(JP),LANG(!!)   (4)\n    IDENTIFICATION DIVISION.            (2)\n    PROGRAM-ID.  COMPILE2.\n    .  .  .\n    END PROGRAM  COMPILE2.\n    IDENTIFICATION DIVISION.\n    PROGRAM-ID.  COMPILE3.\n    .  .  .\n    END PROGRAM  COMPILE3.\nCBL LANGUAGE(JP),LANGUAGE(YY)           (5)\n    .  .  . \n(1)\nThe installation default is EN. The invocation option was XX, a nonexistent language. EN is the\nlanguage in effect.\nChapter 15. Compiling under z/OS  293"}
{"instruction": "Summarize this COBOL documentation section", "input": "5\nThere was an internal error in the code page conversion of a container. This error can occur only\nwhen the target of the PUT is an existing, CICS-created container.\n110 CONTAINERERR\nRESP2 values:\n18\nThe name specified on the CONTAINER option contains an invalid character or combination of\ncharacters.\n16 INVREQ\nRESP2 values:\n1\nThe DATATYPE option was specified without the CHANNEL option, and there is no current channel\n(because the program that issued the command was not passed one.) DATATYPE is valid only on\nPUT CONTAINER commands that specify (explicitly or implicitly) a channel.\n2\nThe FROMCCSID option was specified without the CHANNEL option, and there is no current\nchannel (because the program that issued the command was not passed one.) FROMCCSID is\nvalid only on PUT CONTAINER commands that specify (explicitly or implicitly) a channel.\n4\nThe CHANNEL option was not specified and there is no current channel (because the program that\nissued the command was not passed one).\n30\nYou tried to write to a CICS-defined read only container.\n32\nA CVDA value other than CHAR or BIT was specified for DATATYPE.\n33\nAn attempt was made to change the data-type of an existing container.\n34\nA data-type of BIT is invalid with a CCSID.\n22 LENGERR\nRESP2 values:\n1\nA negative number was specified on the FLENGTH option.\nQUERY CHANNEL\nCount the number of containers that are in a channel.\nQUERY CHANNEL\nQUERY CHANNEL(  data-value )\nCONTAINERCNT(  data-area )\nConditions: CHANNELERR\nThis command is threadsafe.\nDescription\nQUERY CHANNEL counts the number of containers that are in a specified channel.\nYou must specify the CHANNEL option and identify the channel explicitly. You can use the QUERY\nCHANNEL command with any channel, including the transaction channel (DFHTRANSACTION), and\nchannels that CICS created. To find the name of a program's current channel, that is, the channel with\nwhich the program was invoked, use the EXEC CICS ASSIGN CHANNEL command.\nChapter 2. CICS command summary  339", "output": "5\nThere was an internal error in the code page conversion of a container. This error can occur only\nwhen the target of the PUT is an existing, CICS-created container.\n110 CONTAINERERR\nRESP2 values:\n18\nThe name specified on the CONTAINER option contains an invalid character or combination of\ncharacters.\n16 INVREQ\nRESP2 values:\n1\nThe DATATYPE option was specified without the CHANNEL option, and there is no current channel\n(because the program that issued the command was not passed one.) DATATYPE is valid only on\nPUT CONTAINER commands that specify (explicitly or implicitly) a channel.\n2\nThe FROMCCSID option was specified without the CHANNEL option, and there is no current\nchannel (because the program that issued the command was not passed one.) FROMCCSID is\nvalid only on PUT CONTAINER commands that specify (explicitly or implicitly) a channel.\n4\nThe CHANNEL option was not specified and there is no current channel (because the program that\nissued the command was not passed one).\n30\nYou tried to write to a CICS-defined read only container.\n32\nA CVDA value other than CHAR or BIT was specified for DATATYPE.\n33\nAn attempt was made to change the data-type of an existing container.\n34\nA data-type of BIT is invalid with a CCSID.\n22 LENGERR\nRESP2 values:\n1\nA negative number was specified on the FLENGTH option.\nQUERY CHANNEL\nCount the number of containers that are in a channel.\nQUERY CHANNEL\nQUERY CHANNEL(  data-value )\nCONTAINERCNT(  data-area )\nConditions: CHANNELERR\nThis command is threadsafe.\nDescription\nQUERY CHANNEL counts the number of containers that are in a specified channel.\nYou must specify the CHANNEL option and identify the channel explicitly. You can use the QUERY\nCHANNEL command with any channel, including the transaction channel (DFHTRANSACTION), and\nchannels that CICS created. To find the name of a program's current channel, that is, the channel with\nwhich the program was invoked, use the EXEC CICS ASSIGN CHANNEL command.\nChapter 2. CICS command summary  339"}
{"instruction": "Summarize this COBOL documentation section", "input": "RECEIVE (3600-3601)\nRECEIVE\nINTO( data-area )\nSET( ptr-ref )\nLENGTH( data-area )\nFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nNOTRUNCATE\nConditions: EOC, EODS, INBFMH, INVREQ, LENGERR, SIGNAL, TERMERR\n \nDescription\nRECEIVE receives data from the terminal. This form of RECEIVE also applies to the 3630 plant\ncommunication system.\nIf data is to be received, you must specify either the INTO or the SET option. If a RECEIVE is issued purely\nto detect an attention identifier (AID) you can omit both the INTO and SET options. \nRECEIVE (3600-3614)\nReceive data from a 3600 (3614) logical unit. \nRECEIVE (3600-3614)\nRECEIVE\nINTO( data-area )\nSET( ptr-ref )\nLENGTH( data-area )\nFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nNOTRUNCATE\nConditions: INVREQ, LENGERR, TERMERR\n \nDescription\nRECEIVE receives data from the terminal.\nThe data-stream and communication format used between a CICS application program and a 3614 is\ndetermined by the 3614. The application program is therefore device dependent when handling 3614\ncommunication.\nFor further information about designing 3614 application programs for CICS, refer to the IBM\n4700/3600/3630 Guide.\nIf data is to be received, you must specify either the INTO or the SET option. If a RECEIVE is issued purely\nto detect an attention identifier (AID) you can omit both the INTO and SET options.\nChapter 2. CICS command summary  387", "output": "RECEIVE (3600-3601)\nRECEIVE\nINTO( data-area )\nSET( ptr-ref )\nLENGTH( data-area )\nFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nNOTRUNCATE\nConditions: EOC, EODS, INBFMH, INVREQ, LENGERR, SIGNAL, TERMERR\n \nDescription\nRECEIVE receives data from the terminal. This form of RECEIVE also applies to the 3630 plant\ncommunication system.\nIf data is to be received, you must specify either the INTO or the SET option. If a RECEIVE is issued purely\nto detect an attention identifier (AID) you can omit both the INTO and SET options. \nRECEIVE (3600-3614)\nReceive data from a 3600 (3614) logical unit. \nRECEIVE (3600-3614)\nRECEIVE\nINTO( data-area )\nSET( ptr-ref )\nLENGTH( data-area )\nFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nNOTRUNCATE\nConditions: INVREQ, LENGERR, TERMERR\n \nDescription\nRECEIVE receives data from the terminal.\nThe data-stream and communication format used between a CICS application program and a 3614 is\ndetermined by the 3614. The application program is therefore device dependent when handling 3614\ncommunication.\nFor further information about designing 3614 application programs for CICS, refer to the IBM\n4700/3600/3630 Guide.\nIf data is to be received, you must specify either the INTO or the SET option. If a RECEIVE is issued purely\nto detect an attention identifier (AID) you can omit both the INTO and SET options.\nChapter 2. CICS command summary  387"}
{"instruction": "Explain this COBOL concept", "input": "Chapter 6. Reference format\nCOBOL source text must be written in COBOL reference format.\nReference format consists of the following areas in a 72-character line.\nSequence number area\nColumns 1 through 6\nIndicator area\nColumn 7\nArea A\nColumns 8 through 11\nArea B\nColumns 12 through 72\nThis figure illustrates reference format for a COBOL source line.\nIf you want to continue a literal, code a hyphen (-) in the indicator area (column 7) of each continuation\nline. For details about line continuation rules, see “Continuation lines” on page 58.\nThe following topics provide details about these areas:\n• “Sequence number area” on page 55\n• “Indicator area” on page 55\n• “Area A” on page 55\n• “Area B” on page 57\n• “Area A or Area B” on page 59\nSequence number area\nThe sequence number area can be used to label a source statement line. The content of this area can\nconsist of any character in the character set of the computer.\nIndicator area\nUse the indicator area to specify the continuation of words or alphanumeric literals from the previous line\nonto the current line, the treatment of text as documentation, and debugging lines.\nSee “Continuation lines” on page 58, “Comment lines” on page 60, and “Debugging lines” on page\n61.\nThe indicator area can be used for source listing formatting. A slash (/) placed in the indicator column\ncauses the compiler to start a new page for the source listing, and the corresponding source record to be\ntreated as a comment. The effect can be dependent on the LINECOUNT compiler option. For information\nabout the LINECOUNT compiler option, see LINECOUNT in the Enterprise COBOL Programming Guide.\nArea A\nCertain items must begin in Area A.\nThese items are:\n• Division headers\n© Copyright IBM Corp. 1991, 2025\n55", "output": "Chapter 6. Reference format\nCOBOL source text must be written in COBOL reference format.\nReference format consists of the following areas in a 72-character line.\nSequence number area\nColumns 1 through 6\nIndicator area\nColumn 7\nArea A\nColumns 8 through 11\nArea B\nColumns 12 through 72\nThis figure illustrates reference format for a COBOL source line.\nIf you want to continue a literal, code a hyphen (-) in the indicator area (column 7) of each continuation\nline. For details about line continuation rules, see “Continuation lines” on page 58.\nThe following topics provide details about these areas:\n• “Sequence number area” on page 55\n• “Indicator area” on page 55\n• “Area A” on page 55\n• “Area B” on page 57\n• “Area A or Area B” on page 59\nSequence number area\nThe sequence number area can be used to label a source statement line. The content of this area can\nconsist of any character in the character set of the computer.\nIndicator area\nUse the indicator area to specify the continuation of words or alphanumeric literals from the previous line\nonto the current line, the treatment of text as documentation, and debugging lines.\nSee “Continuation lines” on page 58, “Comment lines” on page 60, and “Debugging lines” on page\n61.\nThe indicator area can be used for source listing formatting. A slash (/) placed in the indicator column\ncauses the compiler to start a new page for the source listing, and the corresponding source record to be\ntreated as a comment. The effect can be dependent on the LINECOUNT compiler option. For information\nabout the LINECOUNT compiler option, see LINECOUNT in the Enterprise COBOL Programming Guide.\nArea A\nCertain items must begin in Area A.\nThese items are:\n• Division headers\n© Copyright IBM Corp. 1991, 2025\n55"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Description\nISSUE DISCONNECT disconnects the unit, if DISCREQ=YES is set in the TYPETERM resource de", "output": "Description\nISSUE DISCONNECT disconnects the unit, if DISCREQ=YES is set in the TYPETERM resource definition.\nOptions\nSESSION(name)\nspecifies the symbolic identifier (1–4 characters) of a session TCTTE. This option specifies the\nalternate facility to be disconnected. If this option is omitted, the principal facility for the task is\ndisconnected.\nConditions\n61 NOTALLOC\noccurs if the facility specified in the command is not owned by the application.\nDefault action: terminate the task abnormally.\n81 TERMERR\noccurs for a terminal-related error, such as a session failure.\nA CANCEL TASK request by a user node error program (NEP) may cause this condition if the task has\nan outstanding terminal control request active when the node abnormal condition program handles\nthe session error.\nDefault action: terminate the task abnormally with abend code ATNI.\nISSUE END\nEnd processing of a data set.\nISSUE END\nISSUE END\nDESTID( data-value )\nDESTIDLENG(  data-value )\nSUBADDR(  data-value )\nCONSOLE\nPRINT\nCARD\nWPMEDIA1\nWPMEDIA2\nWPMEDIA3\nWPMEDIA4\nVOLUME(  data-value )\nVOLUMELENG(  data-value )\nConditions: FUNCERR, INVREQ, SELNERR, UNEXPIN\n \nChapter 2. CICS command summary  277"}
{"instruction": "Summarize this COBOL documentation section", "input": "INPUT\nInput\nSYSTEM\nSystem\nTIMER\nTimer.\nFIRESTATUS(cvda)\nindicates the state of the named event. CVDA values are:\nFIRED\nThe event has fired normally.\nNOTFIRED\nThe event has not fired.\nPREDICATE(cvda)\nindicates, if the named event is composite, the Boolean operator applied to its predicate. CVDA values\nare:\nAND\nThe Boolean operator applied to the predicate is AND.\nOR\nThe Boolean operator applied to the predicate is OR.\nTIMER(data-area)\nreturns, if the named event is a timer event, the 16-character name of its associated timer.\nConditions\n83 END\nRESP2 values:\n2\nThere are no more resource definitions of this type.\n112 TOKENERR\nRESP2 values:\n3\nThe browse token is not valid.\nGETNEXT PROCESS\nBrowse all processes of a specified type within the CICS business transaction services system.\nGETNEXT PROCESS\nGETNEXT\nPROCESS(  data-area )\nBROWSETOKEN(  data-value )\nACTIVITYID(  data-area )\nConditions: END, ILLOGIC, IOERR, PROCESSERR, TOKENERR\nDescription\nGETNEXT PROCESS returns the name of the next process of a specified type within the CICS business\ntransaction services system.\nChapter 2. CICS command summary  239", "output": "INPUT\nInput\nSYSTEM\nSystem\nTIMER\nTimer.\nFIRESTATUS(cvda)\nindicates the state of the named event. CVDA values are:\nFIRED\nThe event has fired normally.\nNOTFIRED\nThe event has not fired.\nPREDICATE(cvda)\nindicates, if the named event is composite, the Boolean operator applied to its predicate. CVDA values\nare:\nAND\nThe Boolean operator applied to the predicate is AND.\nOR\nThe Boolean operator applied to the predicate is OR.\nTIMER(data-area)\nreturns, if the named event is a timer event, the 16-character name of its associated timer.\nConditions\n83 END\nRESP2 values:\n2\nThere are no more resource definitions of this type.\n112 TOKENERR\nRESP2 values:\n3\nThe browse token is not valid.\nGETNEXT PROCESS\nBrowse all processes of a specified type within the CICS business transaction services system.\nGETNEXT PROCESS\nGETNEXT\nPROCESS(  data-area )\nBROWSETOKEN(  data-value )\nACTIVITYID(  data-area )\nConditions: END, ILLOGIC, IOERR, PROCESSERR, TOKENERR\nDescription\nGETNEXT PROCESS returns the name of the next process of a specified type within the CICS business\ntransaction services system.\nChapter 2. CICS command summary  239"}
{"instruction": "What is This in COBOL?", "input": "", "output": "This is suboption of the AFTER and AT options"}
{"instruction": "Explain this COBOL concept", "input": "• An out-of-range value is supplied in the PROCLENGTH option.\n• The value that is specified in the PIPLENGTH option is less than 0.\n• The value that is specified in the PIPLENGTH option exceeds the CICS implementation limit of 32\n763.\n• A PIPLIST length element (LL) has a value less than 4.\n• The sum of the length elements (LLs) in the PIPLIST does not equal the value that is specified by\nPIPLENGTH.\nDefault action: terminate the task abnormally.\n61 NOTALLOC\nThis condition occurs if the specified CONVID value does not relate to a conversation owned by the\napplication.\nDefault action: terminate the task abnormally.\n97 PARTNERIDERR\nThis condition occurs if the name specified in the PARTNER option is not recognized by CICS.\nDefault action: terminate the task abnormally.\n81 TERMERR\nThis condition occurs for a session-related error. Any action on that conversation other than a FREE\ncauses an ATCV abend.\nA CANCEL TASK request by a user node error program (NEP) can cause this condition if the task has\nan outstanding terminal control request active when the node abnormal condition program handles\nthe session error.\nDefault action: terminate the task abnormally with abend code ATNI.\nCONVERSE (default)\nCommunicate on standard CICS terminal support.\nCONVERSE (default)\nCONVERSE\nFROM( data-area )\nFROMLENGTH(  data-value )\nFROMFLENGTH(  data-value )\nINTO( data-area )\nSET( ptr-ref )\nTOLENGTH(  data-area )\nTOFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nNOTRUNCATE\nConditions: LENGERR\n   \nDescription\nThis form of the CONVERSE command is used by all CICS-supported z/OS Communications Server\nterminals for which the other CONVERSE descriptions are not appropriate.\nChapter 2. CICS command summary  79", "output": "• An out-of-range value is supplied in the PROCLENGTH option.\n• The value that is specified in the PIPLENGTH option is less than 0.\n• The value that is specified in the PIPLENGTH option exceeds the CICS implementation limit of 32\n763.\n• A PIPLIST length element (LL) has a value less than 4.\n• The sum of the length elements (LLs) in the PIPLIST does not equal the value that is specified by\nPIPLENGTH.\nDefault action: terminate the task abnormally.\n61 NOTALLOC\nThis condition occurs if the specified CONVID value does not relate to a conversation owned by the\napplication.\nDefault action: terminate the task abnormally.\n97 PARTNERIDERR\nThis condition occurs if the name specified in the PARTNER option is not recognized by CICS.\nDefault action: terminate the task abnormally.\n81 TERMERR\nThis condition occurs for a session-related error. Any action on that conversation other than a FREE\ncauses an ATCV abend.\nA CANCEL TASK request by a user node error program (NEP) can cause this condition if the task has\nan outstanding terminal control request active when the node abnormal condition program handles\nthe session error.\nDefault action: terminate the task abnormally with abend code ATNI.\nCONVERSE (default)\nCommunicate on standard CICS terminal support.\nCONVERSE (default)\nCONVERSE\nFROM( data-area )\nFROMLENGTH(  data-value )\nFROMFLENGTH(  data-value )\nINTO( data-area )\nSET( ptr-ref )\nTOLENGTH(  data-area )\nTOFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nNOTRUNCATE\nConditions: LENGERR\n   \nDescription\nThis form of the CONVERSE command is used by all CICS-supported z/OS Communications Server\nterminals for which the other CONVERSE descriptions are not appropriate.\nChapter 2. CICS command summary  79"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 1. Basic COBOL character set. This table lists basic COBOL character set. (continued)\nCharacte", "output": "Table 1. Basic COBOL character set. This table lists basic COBOL character set. (continued)\nCharacter\nMeaning\nUse\nExample\n-\nMinus sign or hyphen\nArithmetic operator\nCOMPUTE WS-\nA = WS-B - \nWS-C.\nEditing character\n01 WS-A \nPIC -9(3).\nContinuation character\n  01 WS-\nVAR  PIC \nX(27) \nVALUE \n-      \n'THIS \nMULTI-LINE \nTEXT'. \nCOBOL word element\n01 WS-A \nPIC 9(3).\n*\nAsterisk\nArithmetic operator\nCOMPUTE WS-\nA = WS-B * \nWS-C.\nEditing character\n01 WS-A \nPIC **9.\nComment character\n* THIS IS \nCOMMENT \nLINE. \n/\nForward slash or solidus\nArithmetic operator\nCOMPUTE WS-\nA = WS-B / \nWS-C.\nEditing character\n01 WS-DATE \nPIC \n99/99/99.\nContinuation character\n/01 WS-\nVAR  PIC \nX(27) \nVALUE \n/     \n'THIS \nMULTI-LINE \nTEXT'. \n=\nEqual sign\nAssignment character\nCOMPUTE WS-\nA = WS-B / \nWS-C.\nRelation character\nIF WS-A = \n10\n4  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What is the\nreturned value in COBOL?", "input": "", "output": "the\nreturned value is position of the first\ncharacter in error.\n• Otherwise, the returned value is (FUNCTION\nLENGTH (argument-1) + 1)"}
{"instruction": "Explain this COBOL concept", "input": "SEND (LUTYPE2/LUTYPE3)\nWrite data to a 3270-display logical unit (LUTYPE2) or a 3270-printer logical unit (LUTYPE3).\nSEND (LUTYPE2/LUTYPE3)\nSEND\nFROM( data-area )\nLENGTH( data-value )\nFLENGTH(  data-value )\nWAIT\nINVITE\nLAST\nERASE\nDEFAULT\nALTERNATE\nCTLCHAR(  data-value )\nSTRFIELD\nDEFRESP\nConditions: INVREQ, LENGERR, TERMERR\nDescription\nThe SEND command writes data to a terminal.\nSEND (LUTYPE4)\nWrite data to a LUTYPE4 logical unit. \nSEND (LUTYPE4)\nSEND\nFROM( data-area )\nLENGTH( data-value )\nFLENGTH(  data-value )\nWAIT\nINVITE\nLAST\nCNOTCOMPL\nDEFRESP\nFMH\nConditions: INVREQ, IGREQCD, LENGERR, SIGNAL, TERMERR\n \nDescription\nSEND writes data to a terminal.\nSEND (LUTYPE6.1)\nSend data on an LUTYPE6.1 conversation. \nChapter 2. CICS command summary  447", "output": "SEND (LUTYPE2/LUTYPE3)\nWrite data to a 3270-display logical unit (LUTYPE2) or a 3270-printer logical unit (LUTYPE3).\nSEND (LUTYPE2/LUTYPE3)\nSEND\nFROM( data-area )\nLENGTH( data-value )\nFLENGTH(  data-value )\nWAIT\nINVITE\nLAST\nERASE\nDEFAULT\nALTERNATE\nCTLCHAR(  data-value )\nSTRFIELD\nDEFRESP\nConditions: INVREQ, LENGERR, TERMERR\nDescription\nThe SEND command writes data to a terminal.\nSEND (LUTYPE4)\nWrite data to a LUTYPE4 logical unit. \nSEND (LUTYPE4)\nSEND\nFROM( data-area )\nLENGTH( data-value )\nFLENGTH(  data-value )\nWAIT\nINVITE\nLAST\nCNOTCOMPL\nDEFRESP\nFMH\nConditions: INVREQ, IGREQCD, LENGERR, SIGNAL, TERMERR\n \nDescription\nSEND writes data to a terminal.\nSEND (LUTYPE6.1)\nSend data on an LUTYPE6.1 conversation. \nChapter 2. CICS command summary  447"}
{"instruction": "Explain this COBOL concept", "input": "Related tasks   \n“Preparing to run IGYTCARA” on page 976 \nRelated references   \n“Input data for IGYTCARA” on page 974  \n“Report produced by IGYTCARA” on page 975  \n“Language elements and concepts that are illustrated” on page 987 \nInput data for IGYTCARA\nAs input to the program, the company collected information from interested employees, coded the\ninformation, and produced an input file. Here is an example of the format of the input file (spaces between\nfields are left out, as they would be in your input file) with an explanation of each item.\n1. Transaction code\n2. Shift\n3. Home code\n4. Work code\n5. Commuter name\n974  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "Related tasks   \n“Preparing to run IGYTCARA” on page 976 \nRelated references   \n“Input data for IGYTCARA” on page 974  \n“Report produced by IGYTCARA” on page 975  \n“Language elements and concepts that are illustrated” on page 987 \nInput data for IGYTCARA\nAs input to the program, the company collected information from interested employees, coded the\ninformation, and produced an input file. Here is an example of the format of the input file (spaces between\nfields are left out, as they would be in your input file) with an explanation of each item.\n1. Transaction code\n2. Shift\n3. Home code\n4. Work code\n5. Commuter name\n974  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "Summarize this COBOL documentation section", "input": "Issue this command, before a second RUN command, when a process needs to be retried. When the\nprocess is re-run, the root activity is sent a DFHINITIAL event.\nTo be eligible to be reset, a process must:\n1. Have been acquired in the current unit of work—that is, it must be the currently-acquired process.\n2. Be in one of the following modes:\n• COMPLETE. This is the usual case. Perhaps the process has completed abnormally, and needs to be\nreset before being retried.\n• INITIAL. The process has not yet been run.\nOptions\nACQPROCESS\nspecifies that the process that is currently acquired by the requestor is to be reset.\nConditions\n16 INVREQ\nRESP2 values:\n15\nThe unit of work that issued the request has not acquired a process.\n17 IOERR\nRESP2 values:\n29\nThe repository file is unavailable.\n30\nAn input/output error has occurred on the repository file.\n100 LOCKED\nThe request cannot be performed because a retained lock exists against the relevant record on the\nrepository file.\n70 NOTAUTH\nRESP2 values:\n101\nThe user associated with the issuing task is not authorized to reset the process.\n106 PROCESSBUSY\nRESP2 values:\n13\nThe request timed out. It may be that another task using this process-record has been prevented\nfrom ending.\n108 PROCESSERR\nRESP2 values:\n14\nThe process to be reset is not in COMPLETE or INITIAL mode.\nRESET ACTIVITY\nReset a BTS activity to its initial state.\nChapter 2. CICS command summary  413", "output": "Issue this command, before a second RUN command, when a process needs to be retried. When the\nprocess is re-run, the root activity is sent a DFHINITIAL event.\nTo be eligible to be reset, a process must:\n1. Have been acquired in the current unit of work—that is, it must be the currently-acquired process.\n2. Be in one of the following modes:\n• COMPLETE. This is the usual case. Perhaps the process has completed abnormally, and needs to be\nreset before being retried.\n• INITIAL. The process has not yet been run.\nOptions\nACQPROCESS\nspecifies that the process that is currently acquired by the requestor is to be reset.\nConditions\n16 INVREQ\nRESP2 values:\n15\nThe unit of work that issued the request has not acquired a process.\n17 IOERR\nRESP2 values:\n29\nThe repository file is unavailable.\n30\nAn input/output error has occurred on the repository file.\n100 LOCKED\nThe request cannot be performed because a retained lock exists against the relevant record on the\nrepository file.\n70 NOTAUTH\nRESP2 values:\n101\nThe user associated with the issuing task is not authorized to reset the process.\n106 PROCESSBUSY\nRESP2 values:\n13\nThe request timed out. It may be that another task using this process-record has been prevented\nfrom ending.\n108 PROCESSERR\nRESP2 values:\n14\nThe process to be reset is not in COMPLETE or INITIAL mode.\nRESET ACTIVITY\nReset a BTS activity to its initial state.\nChapter 2. CICS command summary  413"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Chapter 88. SECONDS-PAST-MIDNIGHT\nThe SECONDS-PAST-MIDNIGHT function returns a value in standard num", "output": "Chapter 88. SECONDS-PAST-MIDNIGHT\nThe SECONDS-PAST-MIDNIGHT function returns a value in standard numeric time form that represents\nthe current local time of day provided by the system on which the function is evaluated.\nThe function type is numeric.\nFormat\nFUNCTION SECONDS-PAST-MIDNIGHT\nThe SECONDS-PAST-MIDNIGHT function has no parameters.\nReturned values\nThe returned value is in standard numeric time form that represents the current local time of the day\nprovided by the system on which the function is evaluated, expressed in seconds past midnight. The\nprecision is indicated by the z/OS operating environment and the precision of the user's data type.\nExample\nIf the current time in the z/OS operating environment is 05:14:27.812479168304, the returned value\nwould be as close to 18867.812479168304 as the z/OS operating environment is capable of providing.\n© Copyright IBM Corp. 1991, 2025\n641"}
{"instruction": "What is the syntax for this COBOL construct?", "input": "in the XML specification and follows some additional rules such as proper use", "output": "in the XML specification and follows some additional rules such as proper use"}
{"instruction": "Summarize this COBOL documentation section", "input": "Table 73. Returned values of the USUPPLEMENTARY function\nargument-1\nUnicode encoding\nUTF-8 encoding\nReturned values of the\nUSUPPLEMENTARY function\nB = \nU+00E4 + U21DE4 + U+004B\n(precomposed form, \nlatin small letter a with diaeresis + \nlatin capital letter K)\nx'C3A4F0A1B7A44B'\n(\n)\nUSUPPLEMENTARY (B) returns 3\nU+0061 + U+0308 + U21DE4 + U+004B\n(canonical decomposition, \nlatin small letter a + combining diaeresis + \nlatin capital letter K)\nx'61CC88F0A1B7A44B'\n(\n)\nUSUPPLEMENTARY (B) returns 4\n678  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "Table 73. Returned values of the USUPPLEMENTARY function\nargument-1\nUnicode encoding\nUTF-8 encoding\nReturned values of the\nUSUPPLEMENTARY function\nB = \nU+00E4 + U21DE4 + U+004B\n(precomposed form, \nlatin small letter a with diaeresis + \nlatin capital letter K)\nx'C3A4F0A1B7A44B'\n(\n)\nUSUPPLEMENTARY (B) returns 3\nU+0061 + U+0308 + U21DE4 + U+004B\n(canonical decomposition, \nlatin small letter a + combining diaeresis + \nlatin capital letter K)\nx'61CC88F0A1B7A44B'\n(\n)\nUSUPPLEMENTARY (B) returns 4\n678  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What is the syntax for this COBOL construct?", "input": "for Java interoperability\n• Process character data that is encoded in a CCSID that is different from the default CCSID assumed by", "output": "for Java interoperability\n• Process character data that is encoded in a CCSID that is different from the default CCSID assumed by"}
{"instruction": "Explain this COBOL concept", "input": "Issue this command, before a second RUN command, when a process needs to be retried. When the\nprocess is re-run, the root activity is sent a DFHINITIAL event.\nTo be eligible to be reset, a process must:\n1. Have been acquired in the current unit of work—that is, it must be the currently-acquired process.\n2. Be in one of the following modes:\n• COMPLETE. This is the usual case. Perhaps the process has completed abnormally, and needs to be\nreset before being retried.\n• INITIAL. The process has not yet been run.\nOptions\nACQPROCESS\nspecifies that the process that is currently acquired by the requestor is to be reset.\nConditions\n16 INVREQ\nRESP2 values:\n15\nThe unit of work that issued the request has not acquired a process.\n17 IOERR\nRESP2 values:\n29\nThe repository file is unavailable.\n30\nAn input/output error has occurred on the repository file.\n100 LOCKED\nThe request cannot be performed because a retained lock exists against the relevant record on the\nrepository file.\n70 NOTAUTH\nRESP2 values:\n101\nThe user associated with the issuing task is not authorized to reset the process.\n106 PROCESSBUSY\nRESP2 values:\n13\nThe request timed out. It may be that another task using this process-record has been prevented\nfrom ending.\n108 PROCESSERR\nRESP2 values:\n14\nThe process to be reset is not in COMPLETE or INITIAL mode.\nRESET ACTIVITY\nReset a BTS activity to its initial state.\nChapter 2. CICS command summary  413", "output": "Issue this command, before a second RUN command, when a process needs to be retried. When the\nprocess is re-run, the root activity is sent a DFHINITIAL event.\nTo be eligible to be reset, a process must:\n1. Have been acquired in the current unit of work—that is, it must be the currently-acquired process.\n2. Be in one of the following modes:\n• COMPLETE. This is the usual case. Perhaps the process has completed abnormally, and needs to be\nreset before being retried.\n• INITIAL. The process has not yet been run.\nOptions\nACQPROCESS\nspecifies that the process that is currently acquired by the requestor is to be reset.\nConditions\n16 INVREQ\nRESP2 values:\n15\nThe unit of work that issued the request has not acquired a process.\n17 IOERR\nRESP2 values:\n29\nThe repository file is unavailable.\n30\nAn input/output error has occurred on the repository file.\n100 LOCKED\nThe request cannot be performed because a retained lock exists against the relevant record on the\nrepository file.\n70 NOTAUTH\nRESP2 values:\n101\nThe user associated with the issuing task is not authorized to reset the process.\n106 PROCESSBUSY\nRESP2 values:\n13\nThe request timed out. It may be that another task using this process-record has been prevented\nfrom ending.\n108 PROCESSERR\nRESP2 values:\n14\nThe process to be reset is not in COMPLETE or INITIAL mode.\nRESET ACTIVITY\nReset a BTS activity to its initial state.\nChapter 2. CICS command summary  413"}
{"instruction": "What are the compiler rules or directives for this?", "input": "or CBL statement. If you do so, the statements must follow one", "output": "or CBL statement. If you do so, the statements must follow one"}
{"instruction": "What are the compiler rules or directives for this?", "input": "or activity was suspended, the latter is reattached for all these events.", "output": "or activity was suspended, the latter is reattached for all these events."}
{"instruction": "Summarize this COBOL documentation section", "input": "11\nThe specified USERID is not known to the external security manager.\n12\nThe specified USERID is revoked.\nREAD\nRead a record from a file.\nREAD\nREAD\nFILE( filename )\nUNCOMMITTED\nCONSISTENT\nREPEATABLE\nUPDATE\nTOKEN(  data-area )\nINTO( data-area )\nSET( ptr-ref )\nRIDFLD( data-area )\nKEYLENGTH(  data-value )\nGENERIC\nSYSID(  systemname )\nLENGTH( data-area )\nLENGTH( data-area )\nDEBKEY\nDEBREC\nRBA\nRRN\nXRBA\nEQUAL\nGTEQ\nNOSUSPEND\nConditions: DISABLED, DUPKEY, FILENOTFOUND, ILLOGIC, INVREQ, IOERR, ISCINVREQ, LENGERR,\nLOADING, LOCKED, NOSPACE, NOTAUTH, NOTFND, NOTOPEN, RECORDBUSY, SYSIDERR\nThis command is threadsafe if the file to which it refers is:\n• Defined as remote and the command is function shipped over an IPIC connection to a remote CICS\nregion.\n• Defined as a local VSAM file, a VSAM RLS file, or a coupling facility data table.\nThis command is not threadsafe if the file to which it refers is:\n• Defined as remote and the command is function shipped over a non-IPIC connection.\n• Defined as NSR.\n• Defined as a shared data table or BDAM file.\nChapter 2. CICS command summary  347", "output": "11\nThe specified USERID is not known to the external security manager.\n12\nThe specified USERID is revoked.\nREAD\nRead a record from a file.\nREAD\nREAD\nFILE( filename )\nUNCOMMITTED\nCONSISTENT\nREPEATABLE\nUPDATE\nTOKEN(  data-area )\nINTO( data-area )\nSET( ptr-ref )\nRIDFLD( data-area )\nKEYLENGTH(  data-value )\nGENERIC\nSYSID(  systemname )\nLENGTH( data-area )\nLENGTH( data-area )\nDEBKEY\nDEBREC\nRBA\nRRN\nXRBA\nEQUAL\nGTEQ\nNOSUSPEND\nConditions: DISABLED, DUPKEY, FILENOTFOUND, ILLOGIC, INVREQ, IOERR, ISCINVREQ, LENGERR,\nLOADING, LOCKED, NOSPACE, NOTAUTH, NOTFND, NOTOPEN, RECORDBUSY, SYSIDERR\nThis command is threadsafe if the file to which it refers is:\n• Defined as remote and the command is function shipped over an IPIC connection to a remote CICS\nregion.\n• Defined as a local VSAM file, a VSAM RLS file, or a coupling facility data table.\nThis command is not threadsafe if the file to which it refers is:\n• Defined as remote and the command is function shipped over a non-IPIC connection.\n• Defined as NSR.\n• Defined as a shared data table or BDAM file.\nChapter 2. CICS command summary  347"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "specified before program arguments. This behavior is consistent with other Language Environment high", "output": "specified before program arguments. This behavior is consistent with other Language Environment high-\nlevel languages. The example below shows the JCL for invoking a COBOL main program with program\nargument '20190901' and runtime option POSIX(ON):\n//GOSTEP  EXEC  PGM=COBMAIN,PARM=’POSIX(ON) / 20190901’\n352  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Appendix I. Accessing JCL parameters\nYou can pass a parameter string from JCL to a COBOL program usi", "output": "Appendix I. Accessing JCL parameters\nYou can pass a parameter string from JCL to a COBOL program using the PARM= keyword of the EXEC\nstatement. You can access these parameters either by standard COBOL coding, or by calling the CEE3PR2\nLanguage Environment callable service.\nUsing COBOL coding\nYou must define the LINKAGE SECTION record (level-01) that is to receive the user_parameter data\npassed by the PARM string, taking into account the halfword parameter list length field that is inserted in\nfront of the string by the system.\nThe program can test this field length for nonzero to verify that PARM-string data has in fact been passed.\nFor example:\nLINKAGE SECTION.\n01 PARMDATA.\n    05 STRINGLEN PIC 9(4) USAGE COMP.\n    05 STRINGPARM PIC X(80).\nPROCEDURE DIVISION USING PARMDATA.\n    IF STRINGLEN > 0 . . .\nFor more information, see “Coding the LINKAGE SECTION” on page 593.\nUsing CEE3PR2\nYou must define parameters to the CEE3PR2 callable service, without the need to add parameters to your\nPROCEDURE DIVISION USING statement.\nWORKING-STORAGE SECTION.\n01 PARMLEN PIC S9(9) BINARY.\n01 PARMSTR.\n   02 STR1-LENGTH PIC S9(4) BINARY.\n   02 STR1-STRING.\n      03 STR1-CHAR PIC X\n                   OCCURS 0 TO 256 TIMES\n                   DEPENDING ON STR1-LENGTH. \n. . .\n   CALL \"CEE3PR2\" USING PARMLEN,PARMSTR, FC.\nFor more information about the CEE3PR2 callable service, see CEE3PR2 in the Language Environment\nProgramming Reference.\nRelated tasks  \n“Accessing main program parameters under z/OS” on page 602 \n© Copyright IBM Corp. 1991, 2025\n993"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 47. Compiler options (continued)\nAspect of your\nprogram\nCompiler option\nDefault\nOption abbrevi", "output": "Table 47. Compiler options (continued)\nAspect of your\nprogram\nCompiler option\nDefault\nOption abbreviations\nMaps and listings\nCONDCOMP\nCONDCOMP(NOSKIPSRC) CC(SKIPS | NOSKIPS)\n“LANGUAGE” on page 395\nLANGUAGE(ENGLISH)\nLANG(EN | UE | JA | JP)\n“LINECOUNT” on page 395\nLINECOUNT(60)\nLC\n“LIST” on page 396\nNOLIST\nNone\n“MAP” on page 399\nNOMAP\nNone\n“OFFSET” on page 409\nNOOFFSET\nOFF | NOOFF\n“SOURCE” on page 423\nSOURCE\nS | NOS\n“SPACE” on page 424\nSPACE(1)\nNone\n“TERMINAL” on page 429\nNOTERMINAL\nTERM | NOTERM\n“VBREF” on page 438\nNOVBREF\nNone\n“XREF” on page 443\nXREF(FULL)\nX | NOX\nObject deck\ngeneration\n“COMPILE” on page 369\nNOCOMPILE(S)\nC | NOC\n“COPYRIGHT” on page 371\nNOCOPYRIGHT\nCPYR | NOCPYR\n“DECK” on page 374\nNODECK\nD | NOD\n“NAME” on page 402\nNONAME, or\nNAME(NOALIAS) if only\nNAME is specified\nNone\n“OBJECT” on page 409\nOBJECT\nOBJ | NOOBJ\n“PGMNAME” on page 414\nPGMNAME(COMPAT)\nPGMN(CO | LU | LM)\n“SERVICE” on page 421\nNOSERVICE\nSERV | NOSERV\n354  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What is the returned value in COBOL?", "input": "", "output": "the returned value is greatest integer less than or equal to the value of argument-1"}
{"instruction": "Summarize this COBOL documentation section", "input": "Chapter 40. COMBINED-DATETIME\nThe COMBINED-DATETIME function combines a date in integer date form and a time in standard numeric\ntime form into a single numeric item from which both date and time components can be derived.\nThe function type is numeric.\nFormat\nFUNCTION COMBINED-DATETIME\n(\nargument-1\nargument-2\n)\nargument-1\nMust be in integer date form. For details, see “Integer date form” on page 513.\nA value in integer date form is a positive integer that represents a number of days succeeding 31\nDecember 1600, in the Gregorian calendar. It is based on a starting date of Monday, 1 January 1601\nand integer date 1 represents Monday, 1 January 1601.\nThe INTDATE compiler option affects the starting date for the integer date functions. For details, see\nINTDATE in the Enterprise COBOL Programming Guide.\nargument-2\nMust be in standard numeric time form. For details, see “Standard numeric time form” on page 514.\nA value in standard numeric time form is a numeric value representing seconds past midnight.\nThe returned value is determined by arithmetic expression argument-1 + (argument-2/100000). The date\noccupies the integer part of the returned value and the time is represented in the fractional part of the\nreturned value.\nThe INTDATE compiler option affects the starting date for the integer date functions. For details, see\nINTDATE in the Enterprise COBOL Programming Guide.\nExample\nGiven the integer date form value \"143951\", which represents the date 15 February 1995,\nand the standard numeric time form value \"18867.812479168304\", which represents the time\n\"05:14:27.812479168304\", the returned value would be exactly \"143951.1886781247\" with the\nARITH(COMPAT) compiler option in effect and exactly \"143951.18867812479168304\" with the\nARITH(EXTEND) compiler option in effect.\n© Copyright IBM Corp. 1991, 2025\n545", "output": "Chapter 40. COMBINED-DATETIME\nThe COMBINED-DATETIME function combines a date in integer date form and a time in standard numeric\ntime form into a single numeric item from which both date and time components can be derived.\nThe function type is numeric.\nFormat\nFUNCTION COMBINED-DATETIME\n(\nargument-1\nargument-2\n)\nargument-1\nMust be in integer date form. For details, see “Integer date form” on page 513.\nA value in integer date form is a positive integer that represents a number of days succeeding 31\nDecember 1600, in the Gregorian calendar. It is based on a starting date of Monday, 1 January 1601\nand integer date 1 represents Monday, 1 January 1601.\nThe INTDATE compiler option affects the starting date for the integer date functions. For details, see\nINTDATE in the Enterprise COBOL Programming Guide.\nargument-2\nMust be in standard numeric time form. For details, see “Standard numeric time form” on page 514.\nA value in standard numeric time form is a numeric value representing seconds past midnight.\nThe returned value is determined by arithmetic expression argument-1 + (argument-2/100000). The date\noccupies the integer part of the returned value and the time is represented in the fractional part of the\nreturned value.\nThe INTDATE compiler option affects the starting date for the integer date functions. For details, see\nINTDATE in the Enterprise COBOL Programming Guide.\nExample\nGiven the integer date form value \"143951\", which represents the date 15 February 1995,\nand the standard numeric time form value \"18867.812479168304\", which represents the time\n\"05:14:27.812479168304\", the returned value would be exactly \"143951.1886781247\" with the\nARITH(COMPAT) compiler option in effect and exactly \"143951.18867812479168304\" with the\nARITH(EXTEND) compiler option in effect.\n© Copyright IBM Corp. 1991, 2025\n545"}
{"instruction": "What is This in COBOL?", "input": "", "output": "This is number assigned to the dump in this run of CICS, starting at 0001 for the first dump, and\nincremented by 1 with each dump taken"}
{"instruction": "Summarize this COBOL documentation section", "input": "HANDLE AID\nHandle attention identifiers (AIDs).\nHANDLE AID\nHANDLE AID\nANYKEY\n( label )\nCLEAR\n( label )\nCLRPARTN\n( label )\nENTER\n( label )\nLIGHTPEN\n( label )\nOPERID\n( label )\nPA1-PA3\n( label )\nPF1-PF24\n( label )\nTRIGGER\n( label )\nCondition: INVREQ\nThis command is threadsafe.\nDescription\nYou can use the HANDLE AID command to specify the label to which control is to be passed when an AID\nis received from a display device. Control is passed after the input command is completed; that is, after\nany data received in addition to the AID has been passed to the application program.\nRestriction: This command is supported only in COBOL, PL/I, and assembler language applications (but\nnot AMODE(64) assembler language applications). It is not supported in all other supported high level\nlanguages.\nTo ignore an AID, issue a HANDLE AID command that specifies the associated option without a label. This\ndeactivates the effect of that option in any previously-issued HANDLE AID command.\nIf no HANDLE AID commands are in effect, that is, none have been issued or all have been canceled,\ncontrol returns to the application program at the instruction immediately following the input command.\nLook in EIBAID to determine which key was pressed.\nYou can specify the following options:\n• ANYKEY (any PA key, any PF key, or the CLEAR key, but not ENTER)\n• CLEAR (for the key of that name)\n• CLRPARTN (for the key of that name)\n248  CICS TS for z/OS: API Reference", "output": "HANDLE AID\nHandle attention identifiers (AIDs).\nHANDLE AID\nHANDLE AID\nANYKEY\n( label )\nCLEAR\n( label )\nCLRPARTN\n( label )\nENTER\n( label )\nLIGHTPEN\n( label )\nOPERID\n( label )\nPA1-PA3\n( label )\nPF1-PF24\n( label )\nTRIGGER\n( label )\nCondition: INVREQ\nThis command is threadsafe.\nDescription\nYou can use the HANDLE AID command to specify the label to which control is to be passed when an AID\nis received from a display device. Control is passed after the input command is completed; that is, after\nany data received in addition to the AID has been passed to the application program.\nRestriction: This command is supported only in COBOL, PL/I, and assembler language applications (but\nnot AMODE(64) assembler language applications). It is not supported in all other supported high level\nlanguages.\nTo ignore an AID, issue a HANDLE AID command that specifies the associated option without a label. This\ndeactivates the effect of that option in any previously-issued HANDLE AID command.\nIf no HANDLE AID commands are in effect, that is, none have been issued or all have been canceled,\ncontrol returns to the application program at the instruction immediately following the input command.\nLook in EIBAID to determine which key was pressed.\nYou can specify the following options:\n• ANYKEY (any PA key, any PF key, or the CLEAR key, but not ENTER)\n• CLEAR (for the key of that name)\n• CLRPARTN (for the key of that name)\n248  CICS TS for z/OS: API Reference"}
{"instruction": "What is Here in COBOL?", "input": "", "output": "Here is table showing the names for the AID"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "01  num  pic 9(4).\n PROCEDURE DIVISION.\n     move numb to num.\n     if numb = 0\n        move 1 to fa", "output": "01  num  pic 9(4).\n PROCEDURE DIVISION.\n     move numb to num.\n     if numb = 0\n        move 1 to fact\n     else\n        subtract 1 from numb\n        call 'factorial'\n        multiply num by fact\n     end-if.\n     display num '! = ' fact.\n     goback.\n End Program factorial.\nThe program produces the following output:\n0000! = 00000001\n0001! = 00000001\n0002! = 00000002\n0003! = 00000006\n0004! = 00000024\n0005! = 00000120\nThe following tables show the changing values of the data items in LOCAL-STORAGE and WORKING-\nSTORAGE in the successive recursive calls of the program, and in the ensuing gobacks. During the\ngobacks, fact progressively accumulates the value of 5! (five factorial).\nRecursive calls\nValue for num in\nLOCAL-STORAGE\nValue for numb in\nWORKING-STORAGE\nValue for fact in\nWORKING-STORAGE\nMain\n5\n5\n0\n1\n4\n4\n0\n2\n3\n3\n0\n3\n2\n2\n0\n4\n1\n1\n0\n5\n0\n0\n0\n \nGobacks\nValue for num in\nLOCAL-STORAGE\nValue for numb in\nWORKING-STORAGE\nValue for fact in\nWORKING-STORAGE\n5\n0\n0\n1\n4\n1\n0\n1\n3\n2\n0\n2\n2\n3\n0\n6\n1\n4\n0\n24\nMain\n5\n0\n120\nRelated concepts   \n“Comparison of WORKING-STORAGE and LOCAL-STORAGE” on page 14 \nChapter 1. Structuring your program  15"}
{"instruction": "What is CLASS clause\nThe CLASS clause provides a in COBOL?", "input": "", "output": "CLASS clause\nThe CLASS clause provides a is for relating a name to the specified set of characters listed in that\nclause"}
{"instruction": "Explain this COBOL concept", "input": "Table 84. EBCDIC collating sequence (continued)\nOrdinal\nnumber\nSymbol\nMeaning\nDecimal\nrepresentation\nHex representation\n. . .\n \n \n \n \n108\n,\nComma\n107\n6B\n109\n%\nPercent sign\n108\n6C\n110\n_\nUnderscore\n109\n6D\n111\n>\nGreater than sign\n110\n6E\n112\n?\nQuestion mark\n111\n6F\n. . .\n \n \n \n \n122\n`\nGrave accent\n121\n79\n123\n:\nColon\n122\n7A\n124\n#\nNumber sign, pound sign\n123\n7B\n125\n@\nAt sign\n124\n7C\n126\n'\nApostrophe, prime sign\n125\n7D\n127\n=\nEqual sign\n126\n7E\n128\n\"\nQuotation marks\n127\n7F\n. . .\n \n \n \n \n130\na\n \n129\n81\n131\nb\n \n130\n82\n132\nc\n \n131\n83\n133\nd\n \n132\n84\n134\ne\n \n133\n85\n135\nf\n \n134\n86\n136\ng\n \n135\n87\n137\nh\n \n136\n88\n138\ni\n \n137\n89\n. . .\n \n \n \n \n146\nj\n \n145\n91\n147\nk\n \n146\n92\n148\nl\n \n147\n93\n149\nm\n \n148\n94\n150\nn\n \n149\n95\n151\no\n \n150\n96\n152\np\n \n151\n97\n153\nq\n \n152\n98\n154\nr\n \n153\n99\n762  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "Table 84. EBCDIC collating sequence (continued)\nOrdinal\nnumber\nSymbol\nMeaning\nDecimal\nrepresentation\nHex representation\n. . .\n \n \n \n \n108\n,\nComma\n107\n6B\n109\n%\nPercent sign\n108\n6C\n110\n_\nUnderscore\n109\n6D\n111\n>\nGreater than sign\n110\n6E\n112\n?\nQuestion mark\n111\n6F\n. . .\n \n \n \n \n122\n`\nGrave accent\n121\n79\n123\n:\nColon\n122\n7A\n124\n#\nNumber sign, pound sign\n123\n7B\n125\n@\nAt sign\n124\n7C\n126\n'\nApostrophe, prime sign\n125\n7D\n127\n=\nEqual sign\n126\n7E\n128\n\"\nQuotation marks\n127\n7F\n. . .\n \n \n \n \n130\na\n \n129\n81\n131\nb\n \n130\n82\n132\nc\n \n131\n83\n133\nd\n \n132\n84\n134\ne\n \n133\n85\n135\nf\n \n134\n86\n136\ng\n \n135\n87\n137\nh\n \n136\n88\n138\ni\n \n137\n89\n. . .\n \n \n \n \n146\nj\n \n145\n91\n147\nk\n \n146\n92\n148\nl\n \n147\n93\n149\nm\n \n148\n94\n150\nn\n \n149\n95\n151\no\n \n150\n96\n152\np\n \n151\n97\n153\nq\n \n152\n98\n154\nr\n \n153\n99\n762  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What is the syntax for this COBOL construct?", "input": "and semantics of COBOL language features are the same between LP(64) and", "output": "and semantics of COBOL language features are the same between LP(64) and"}
{"instruction": "Summarize this COBOL documentation section", "input": "and the \"IBM Software Products and Software-as-a-Service Privacy Statement\" at http://www.ibm.com/\nsoftware/info/product-privacy.\nTrademarks\nIBM, the IBM logo, and ibm.com® are trademarks or registered trademarks of International Business\nMachines Corp., registered in many jurisdictions worldwide. Other product and service names might be\ntrademarks of IBM or other companies. A current list of IBM trademarks is available on the Web at\n“Copyright and trademark information” at www.ibm.com/legal/copytrade.shtml.\nIntel is a registered trademark of Intel Corporation or its subsidiaries in the United States and other\ncountries.\nJava and all Java-based trademarks and logos are trademarks or registered trademarks of Oracle and/or\nits affiliates.\nMicrosoft and Windows are trademarks of Microsoft Corporation in the United States, other countries, or\nboth.\nUNIX is a registered trademark of The Open Group in the United States and other countries.\nOther product and service names might be trademarks of IBM or other companies.\nNotices  999", "output": "and the \"IBM Software Products and Software-as-a-Service Privacy Statement\" at http://www.ibm.com/\nsoftware/info/product-privacy.\nTrademarks\nIBM, the IBM logo, and ibm.com® are trademarks or registered trademarks of International Business\nMachines Corp., registered in many jurisdictions worldwide. Other product and service names might be\ntrademarks of IBM or other companies. A current list of IBM trademarks is available on the Web at\n“Copyright and trademark information” at www.ibm.com/legal/copytrade.shtml.\nIntel is a registered trademark of Intel Corporation or its subsidiaries in the United States and other\ncountries.\nJava and all Java-based trademarks and logos are trademarks or registered trademarks of Oracle and/or\nits affiliates.\nMicrosoft and Windows are trademarks of Microsoft Corporation in the United States, other countries, or\nboth.\nUNIX is a registered trademark of The Open Group in the United States and other countries.\nOther product and service names might be trademarks of IBM or other companies.\nNotices  999"}
{"instruction": "Explain this COBOL concept", "input": "Chapter 80. ORD-MIN\nThe ORD-MIN function returns a value that is the ordinal position in the argument list of the argument that\ncontains the minimum value.\nThe function type is integer.\nFormat\nFUNCTION ORD-MIN\n(\nargument-1\n)\nargument-1\nMust be class alphabetic, alphanumeric, national, or numeric.\nAll arguments must be of the same class, except that a combination of alphabetic and alphanumeric\narguments is allowed.\nThe returned value is the ordinal number that corresponds to the position of the argument-1 having the\nleast value in the argument-1 series.\nThe comparisons used to determine the least-valued argument-1 are made according to the rules for\nsimple conditions. For more information, see “Conditional expressions” on page 274.\nIf more than one argument-1 has the same least value, the number returned corresponds to the position\nof the leftmost argument-1 having that value.\n© Copyright IBM Corp. 1991, 2025\n625", "output": "Chapter 80. ORD-MIN\nThe ORD-MIN function returns a value that is the ordinal position in the argument list of the argument that\ncontains the minimum value.\nThe function type is integer.\nFormat\nFUNCTION ORD-MIN\n(\nargument-1\n)\nargument-1\nMust be class alphabetic, alphanumeric, national, or numeric.\nAll arguments must be of the same class, except that a combination of alphabetic and alphanumeric\narguments is allowed.\nThe returned value is the ordinal number that corresponds to the position of the argument-1 having the\nleast value in the argument-1 series.\nThe comparisons used to determine the least-valued argument-1 are made according to the rules for\nsimple conditions. For more information, see “Conditional expressions” on page 274.\nIf more than one argument-1 has the same least value, the number returned corresponds to the position\nof the leftmost argument-1 having that value.\n© Copyright IBM Corp. 1991, 2025\n625"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 86. Reserved words (continued)\nWord\nReserved\nStandard only\nPotential\nreserved words\nADD\nX\n \n \n", "output": "Table 86. Reserved words (continued)\nWord\nReserved\nStandard only\nPotential\nreserved words\nADD\nX\n \n \nADDRESS\nX\n \n \nADVANCING\nX\n \n \nAFTER\nX\n \n \nALIGNED\n \n \nX\nALL\nX\n \n \nALLOCATE\nX \n \nALPHABET\nX\n \n \nALPHABETIC\nX\n \n \nALPHABETIC-LOWER\nX\n \n \nALPHABETIC-UPPER\nX\n \n \nALPHANUMERIC\nX\n \n \nALPHANUMERIC-EDITED\nX\n \n \nALSO\nX\n \n \nALTER\nX\n \n \nALTERNATE\nX\n \n \nAND\nX\n \n \nANY\nX\n \n \nANYCASE\n \n \nX\nAPPLY\nX\n \n \nARE\nX\n \n \nAREA\nX\n \n \nAREAS\nX\n \n \nASCENDING\nX\n \n \nASSIGN\nX\n \n \nAT\nX\n \n \nAUTHOR\nX\n \n \nB-AND\n \n \nX\nB-NOT\n \n \nX\nB-OR\n \n \nX\nB-XOR\n \n \nX\nBASED\n \n \nX\nBASIS\nX\n \n \nBEFORE\nX\n \n \n772  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Special insertion editing\nThis type of editing is valid for either numeric-edited items or external ", "output": "Special insertion editing\nThis type of editing is valid for either numeric-edited items or external floating-point items.\nThe period (.) is the special insertion symbol; it also represents the actual decimal point for alignment\npurposes. \nNote: If the DECIMAL-POINT IS COMMA clause is specified, then a comma will be used in place of the\nperiod.\nThe period insertion symbol is counted in the size of the item, and represents the position within the item\nwhere the actual decimal point is inserted.\nEither the actual decimal point or the symbol V as the assumed decimal point, but not both, must be\nspecified in one PICTURE character-string.\nFor example:\nPICTURE\nValue of data\nEdited result\n        999.99       \n          1.234      \n        001.23       \n        999.99       \n         12.34       \n        012.34       \n        999.99       \n        123.45       \n        123.45       \n        999.99       \n       1234.5        \n        234.50       \n       +999.99E+99   \n      12345          \n       +123.45E+02   \nFixed insertion editing\nFixed insertion editing is valid only for numeric-edited items.\nThe following insertion symbols are used:\n• cs\n• + - CR DB (editing-sign control symbols)\nIn fixed insertion editing, only one currency symbol and one editing-sign control symbol can be specified\nin a PICTURE character-string.\nUnless it is preceded by a + or - symbol, the currency symbol must be the first character in the character-\nstring.\nWhen either + or - is used as a symbol, it must be the first or last character in the character-string.\nWhen CR or DB is used as a symbol, it must occupy the rightmost two character positions in the\ncharacter-string. If these two character positions contain the symbols CR or DB, the uppercase letters\nare the insertion characters.\nEditing sign control symbols produce results that depend on the value of the data item, as shown in the\nfollowing table:\nChapter 26. DATA DIVISION--data description entry  225"}
{"instruction": "What are the compiler rules or directives for this?", "input": "of setting sort criteria that is described in this topic relates to the format 1 SORT", "output": "of setting sort criteria that is described in this topic relates to the format 1 SORT"}
{"instruction": "What is 5 Language Reference\n\n\nSequential files\nThe NEXT RECORD in COBOL?", "input": "", "output": "5 Language Reference\n\n\nSequential files\nThe NEXT RECORD is next record in a logical sequence of records"}
{"instruction": "What are the compiler rules or directives for this?", "input": "or CBL statement.\n• Code an asterisk (*) in column 1 to cause a line to be treated as a comment.\n• Optionally code sequence numbers in columns 73 through 80; those columns are ignored.", "output": "or CBL statement.\n• Code an asterisk (*) in column 1 to cause a line to be treated as a comment.\n• Optionally code sequence numbers in columns 73 through 80; those columns are ignored."}
{"instruction": "Summarize this COBOL documentation section", "input": "• ISSUE ENDFILE\n• ISSUE ENDOUTPUT\n• ISSUE EODS\n• ISSUE ERASEAUP\n• ISSUE LOAD\n• ISSUE PASS\n• ISSUE PRINT\n• ISSUE RESET\n• ISSUE SIGNAL (LUTYPE6.1)\n• POINT\n• RECEIVE (APPC)\n• RECEIVE (LUTYPE2/LUTYPE3)\n• RECEIVE (LUTYPE4)\n• RECEIVE (LUTYPE6.1)\n• RECEIVE (MRO)\n• “RECEIVE (non-z/OS Communications Server default)” on page 393\n• “RECEIVE: non-z/OSCommunications Server options” on page 396\n• “RECEIVE (z/OS Communications Server default)” on page 383\n• “RECEIVE (z/OS Communications Server default)” on page 383\n• RECEIVE (2260)\n• RECEIVE (2980)\n• RECEIVE (3270 logical)\n• “RECEIVE (3600 pipeline)” on page 386\n• RECEIVE (3600-3601)\n• RECEIVE (3600-3614)\n• RECEIVE (3650)\n• RECEIVE (3767)\n• RECEIVE (3770)\n• RECEIVE (3790 full-function or inquiry)\n• RECEIVE (3790 3270-display)\n• SEND (APPC)\n• SEND (LUTYPE2/LUTYPE3)\n• SEND (LUTYPE4)\n• SEND (LUTYPE6.1)\n• SEND (MRO)\n• “SEND (non-z/OS Communications Server default)” on page 459\n• “SEND: non-z/OS Communications Server options” on page 460\n• SEND (SCS)\n• “SEND (z/OS Communications Server default)” on page 446\n• “SEND: z/OS Communications Server options” on page 455\n• SEND (2260)\n• SEND (2980)\n• SEND (3270 logical)\nChapter 2. CICS command summary  23", "output": "• ISSUE ENDFILE\n• ISSUE ENDOUTPUT\n• ISSUE EODS\n• ISSUE ERASEAUP\n• ISSUE LOAD\n• ISSUE PASS\n• ISSUE PRINT\n• ISSUE RESET\n• ISSUE SIGNAL (LUTYPE6.1)\n• POINT\n• RECEIVE (APPC)\n• RECEIVE (LUTYPE2/LUTYPE3)\n• RECEIVE (LUTYPE4)\n• RECEIVE (LUTYPE6.1)\n• RECEIVE (MRO)\n• “RECEIVE (non-z/OS Communications Server default)” on page 393\n• “RECEIVE: non-z/OSCommunications Server options” on page 396\n• “RECEIVE (z/OS Communications Server default)” on page 383\n• “RECEIVE (z/OS Communications Server default)” on page 383\n• RECEIVE (2260)\n• RECEIVE (2980)\n• RECEIVE (3270 logical)\n• “RECEIVE (3600 pipeline)” on page 386\n• RECEIVE (3600-3601)\n• RECEIVE (3600-3614)\n• RECEIVE (3650)\n• RECEIVE (3767)\n• RECEIVE (3770)\n• RECEIVE (3790 full-function or inquiry)\n• RECEIVE (3790 3270-display)\n• SEND (APPC)\n• SEND (LUTYPE2/LUTYPE3)\n• SEND (LUTYPE4)\n• SEND (LUTYPE6.1)\n• SEND (MRO)\n• “SEND (non-z/OS Communications Server default)” on page 459\n• “SEND: non-z/OS Communications Server options” on page 460\n• SEND (SCS)\n• “SEND (z/OS Communications Server default)” on page 446\n• “SEND: z/OS Communications Server options” on page 455\n• SEND (2260)\n• SEND (2980)\n• SEND (3270 logical)\nChapter 2. CICS command summary  23"}
{"instruction": "What is name in COBOL?", "input": "", "output": "name is name of an alphanumeric group item"}
{"instruction": "What are the compiler rules or directives for this?", "input": "the record from the local-storage item\n  . . .\n  CLOSE fn", "output": "the record from the local-storage item\n  . . .\n  CLOSE fn"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "SUBTRACT statement\nThe SUBTRACT statement subtracts one numeric item, or the sum of two or more nume", "output": "SUBTRACT statement\nThe SUBTRACT statement subtracts one numeric item, or the sum of two or more numeric items, from\none or more numeric items, and stores the result.\nFormat 1: SUBTRACT statement\nSUBTRACT\nidentifier-1\nliteral-1\nFROM\nidentifier-2\nROUNDED\nON\nSIZE ERROR\nimperative-statement-1\nNOT\nON\nSIZE ERROR\nimperative-statement-2\nEND-SUBTRACT\nAll identifiers or literals preceding the keyword FROM are added together and their sum is subtracted\nfrom and stored immediately in identifier-2. This process is repeated for each successive occurrence of\nidentifier-2, in the left-to-right order in which identifier-2 is specified.\n472  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 136. SYSADATA parse tree record (continued)\nField\nSize\nDescription\n0019\nDEBUGGING\n0020\nSEQUENC", "output": "Table 136. SYSADATA parse tree record (continued)\nField\nSize\nDescription\n0019\nDEBUGGING\n0020\nSEQUENCE\n0021\nReserved for future use\n0022\nReserved for future use\n0023\nReserved for future use\n0024\nTALLYING\n0025\nReserved for future use\n0026\nON SIZE ERROR\n0027\nON OVERFLOW\n0028\nON ERROR\n0029\nAT END\n0030\nINVALID KEY\n0031\nEND-OF-PAGE\n0032\nUSING\nAppendix G. COBOL SYSADATA file contents  913"}
{"instruction": "Explain this COBOL concept", "input": "Table 53. Permissible statements for indexed and relative files\nFile access\nmode\nStatement\nInput open\nmode\nOutput open\nmode\nI-O open\nmode\nExtend open\nmode\nSequential\nREAD\nX\n \nX\n \nWRITE\n \nX\n \nX\nREWRITE\n \n \nX\n \nSTART\nX\n \nX\n \nDELETE\n \n \nX\n \nRandom\nREAD\nX\n \nX\n \nWRITE\n \nX\nX\n \nREWRITE\n \n \nX\n \nSTART\n \n \n \n \nDELETE\n \n \nX\n \nDynamic\nREAD\nX\n \nX\n \nWRITE\n \nX\nX\n \nREWRITE\n \n \nX\n \nSTART\nX\n \nX\n \nDELETE\n \n \nX\n \nIn the following table, an 'X' indicates that the specified statement can be used with the open mode given\nat the top of the column.\nTable 54. Permissible statements for line-sequential files\nStatement\nInput open mode\nOutput open mode I-O open mode\nExtend open mode\nREAD\nX\n \n \n \nWRITE\n \nX\n \nX\nREWRITE\n \n \n \n \n1. A file can be opened for INPUT, OUTPUT, I-O, or EXTEND (sequential and line-sequential files only) in\nthe same program. After the first OPEN statement execution for a given file, each subsequent OPEN\nstatement execution must be preceded by a successful CLOSE file statement execution without the\nREEL or UNIT phrase (for QSAM files only), or the LOCK phrase.\n2. If the FILE STATUS clause is specified in the file-control entry, the associated file status key is updated\nwhen the OPEN statement is executed.\n3. If an OPEN statement is executed for a file that is already open, the EXCEPTION/ERROR procedure (if\nspecified) for this file is run.\nPERFORM statement\nThe PERFORM statement transfers control explicitly to one or more procedures and implicitly returns\ncontrol to the next executable statement after execution of the specified procedures is completed. The\n422  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "Table 53. Permissible statements for indexed and relative files\nFile access\nmode\nStatement\nInput open\nmode\nOutput open\nmode\nI-O open\nmode\nExtend open\nmode\nSequential\nREAD\nX\n \nX\n \nWRITE\n \nX\n \nX\nREWRITE\n \n \nX\n \nSTART\nX\n \nX\n \nDELETE\n \n \nX\n \nRandom\nREAD\nX\n \nX\n \nWRITE\n \nX\nX\n \nREWRITE\n \n \nX\n \nSTART\n \n \n \n \nDELETE\n \n \nX\n \nDynamic\nREAD\nX\n \nX\n \nWRITE\n \nX\nX\n \nREWRITE\n \n \nX\n \nSTART\nX\n \nX\n \nDELETE\n \n \nX\n \nIn the following table, an 'X' indicates that the specified statement can be used with the open mode given\nat the top of the column.\nTable 54. Permissible statements for line-sequential files\nStatement\nInput open mode\nOutput open mode I-O open mode\nExtend open mode\nREAD\nX\n \n \n \nWRITE\n \nX\n \nX\nREWRITE\n \n \n \n \n1. A file can be opened for INPUT, OUTPUT, I-O, or EXTEND (sequential and line-sequential files only) in\nthe same program. After the first OPEN statement execution for a given file, each subsequent OPEN\nstatement execution must be preceded by a successful CLOSE file statement execution without the\nREEL or UNIT phrase (for QSAM files only), or the LOCK phrase.\n2. If the FILE STATUS clause is specified in the file-control entry, the associated file status key is updated\nwhen the OPEN statement is executed.\n3. If an OPEN statement is executed for a file that is already open, the EXCEPTION/ERROR procedure (if\nspecified) for this file is run.\nPERFORM statement\nThe PERFORM statement transfers control explicitly to one or more procedures and implicitly returns\ncontrol to the next executable statement after execution of the specified procedures is completed. The\n422  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What is The returned value in COBOL?", "input": "", "output": "The returned value is approximation of the arctangent of argument-1 and is greater than -Pi/2 and less\nthan +Pi/2.\n© Copyright IBM Corp. 1991, 2025\n535\n\n\n536  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference\n\n\nChapter 36"}
{"instruction": "What is the resource in program B in COBOL?", "input": "", "output": "the resource in program B is referenced resource.\n• If the name is not declared in program B, the referenced resource is:\n– The resource in program A if the name is declared in program A\n– The resource in the containing program if the name is declared in the program that contains\nprogram A\nThis rule is applied to further containing programs until a valid resource is found"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Description\nWEB ENDBROWSE FORMFIELD terminates the browse of a set of name-value pairs in an HTML fo", "output": "Description\nWEB ENDBROWSE FORMFIELD terminates the browse of a set of name-value pairs in an HTML form. The\nform is part of the body of an HTTP request being processed by the current CICS task. No information is\nreturned on the ENDBROWSE.\nConditions\n16 INVREQ\nRESP2 values are:\n1\nThe command is being issued in a non-CICS Web support application.\n3\nThe command is being issued for a non-HTTP request.\n4\nThe command is being issued before a WEB STARTBROWSE command is issued.\nWEB ENDBROWSE HTTPHEADER\nSignal the end of an HTTP header browse.\nWEB ENDBROWSE HTTPHEADER\nWEB\nENDBROWSE\nHTTPHEADER\nSESSTOKEN(  data-value )\nConditions: INVREQ, NOTOPEN\nThis command is threadsafe.\nDescription\nWEB ENDBROWSE HTTPHEADER terminates the browse. No information is returned on the ENDBROWSE.\nThe SESSTOKEN option is required if the HTTP header information is part of a response sent to CICS as an\nHTTP client.\nOptions\nSESSTOKEN(data-value)\nFor CICS as an HTTP client, this option is required. It specifies the session token, an 8-byte binary\nvalue that uniquely identifies a connection between CICS and a server. This value is returned by a\nWEB OPEN command for CICS as an HTTP client. Session tokens explains the use of the session\ntoken.\nConditions\n16 INVREQ\nRESP2 values are:\n1\nThe command is being issued in a non-CICS Web support application.\n3\nThe command is being issued for a non-HTTP request.\n4\nThe command is being issued before a WEB STARTBROWSE command is issued.\nChapter 2. CICS command summary  607"}
{"instruction": "Summarize this COBOL documentation section", "input": "RECEIVE (3650)\nReceive data from 3650 logical units. \nRECEIVE (3650)\nRECEIVE\nINTO( data-area )\nSET( ptr-ref )\nLENGTH( data-area )\nFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nNOTRUNCATE\nConditions: EOC, EODS, INBFMH, INVREQ, LENGERR, TERMERR\n \nDescription\nRECEIVE receives data from the terminal. This form of RECEIVE also applies to the following 3650\ndevices:\n• Interpreter logical unit\n• Host conversational (3270) logical unit\n• Host conversational (3653) logical unit\n• 3650/3680 command processor logical unit\nIf data is to be received, you must specify either the INTO or the SET option. If a RECEIVE is issued purely\nto detect an attention identifier (AID) you can omit both the INTO and SET options.\nRECEIVE (3767)\nReceive data from a 3767 interactive logical unit. \nRECEIVE (3767)\nRECEIVE\nINTO( data-area )\nSET( ptr-ref )\nLENGTH( data-area )\nFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nNOTRUNCATE\nConditions: EOC, INVREQ, LENGERR, SIGNAL, TERMERR\n \nDescription\nRECEIVE receives data from the terminal. This form of RECEIVE also applies to the 3770 interactive\nlogical unit.\n388  CICS TS for z/OS: API Reference", "output": "RECEIVE (3650)\nReceive data from 3650 logical units. \nRECEIVE (3650)\nRECEIVE\nINTO( data-area )\nSET( ptr-ref )\nLENGTH( data-area )\nFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nNOTRUNCATE\nConditions: EOC, EODS, INBFMH, INVREQ, LENGERR, TERMERR\n \nDescription\nRECEIVE receives data from the terminal. This form of RECEIVE also applies to the following 3650\ndevices:\n• Interpreter logical unit\n• Host conversational (3270) logical unit\n• Host conversational (3653) logical unit\n• 3650/3680 command processor logical unit\nIf data is to be received, you must specify either the INTO or the SET option. If a RECEIVE is issued purely\nto detect an attention identifier (AID) you can omit both the INTO and SET options.\nRECEIVE (3767)\nReceive data from a 3767 interactive logical unit. \nRECEIVE (3767)\nRECEIVE\nINTO( data-area )\nSET( ptr-ref )\nLENGTH( data-area )\nFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nNOTRUNCATE\nConditions: EOC, INVREQ, LENGERR, SIGNAL, TERMERR\n \nDescription\nRECEIVE receives data from the terminal. This form of RECEIVE also applies to the 3770 interactive\nlogical unit.\n388  CICS TS for z/OS: API Reference"}
{"instruction": "Summarize this COBOL documentation section", "input": "• 3270 logical unit\n• 3600 pipeline logical unit\n• 3600(3601) logical unit\n• 3600(3614) logical unit\n• 3630 plant communication system\n• 3650 interpreter logical unit\n• 3650 host conversational (3270) logical unit\n• 3650 host conversational (3653) logical unit\n• 3650(3680) host command processor logical unit\n• 3767/3770 interactive logical unit\n• 3770 batch logical unit\n• 3790 logical units\nConditions\nFor most terminal and logical unit types, ISSUE DISCONNECT raises no conditions. Exceptions are:\n24 SIGNAL\noccurs only for an ISSUE DISCONNECT for LUTYPE4, 3600(3601), 3767 interactive, 3770 batch, and\n3790 full-function logical units.\nIt occurs when an inbound SIGNAL data-flow control command is received from a logical unit or\nsession. EIBSIG is always set when an inbound signal is received.\nDefault action: ignore the condition.\n81 TERMERR\noccurs only for an ISSUE DISCONNECT for LUTYPE4 logical units.\nIt occurs for a terminal-related error, such as a session failure. This condition applies to SNA-\nconnected LUs only. Because of the asynchronous nature of this condition, the application program\nshould check, using SEND CONFIRM or SYNCPOINT, to make sure any errors still outstanding have\nbeen resolved before it relinquishes control. If you want to handle this condition, you must first issue\na FREE command to free the session. If you do not do this, an INVREQ condition occurs, plus an ATCV\nabend if you do not handle this condition.\nA CANCEL TASK request by a user node error program (NEP) may cause this condition if the task has\nan outstanding terminal control request active when the node abnormal condition program handles\nthe session error.\nDefault action: terminate the task abnormally with abend code ATNI.\nISSUE DISCONNECT (LUTYPE6.1)\nDisconnect an LUTYPE6.1 logical unit.\nISSUE DISCONNECT (LUTYPE6.1)\nISSUE DISCONNECT\nSESSION(  name )\nConditions: NOTALLOC, TERMERR\n \n276  CICS TS for z/OS: API Reference", "output": "• 3270 logical unit\n• 3600 pipeline logical unit\n• 3600(3601) logical unit\n• 3600(3614) logical unit\n• 3630 plant communication system\n• 3650 interpreter logical unit\n• 3650 host conversational (3270) logical unit\n• 3650 host conversational (3653) logical unit\n• 3650(3680) host command processor logical unit\n• 3767/3770 interactive logical unit\n• 3770 batch logical unit\n• 3790 logical units\nConditions\nFor most terminal and logical unit types, ISSUE DISCONNECT raises no conditions. Exceptions are:\n24 SIGNAL\noccurs only for an ISSUE DISCONNECT for LUTYPE4, 3600(3601), 3767 interactive, 3770 batch, and\n3790 full-function logical units.\nIt occurs when an inbound SIGNAL data-flow control command is received from a logical unit or\nsession. EIBSIG is always set when an inbound signal is received.\nDefault action: ignore the condition.\n81 TERMERR\noccurs only for an ISSUE DISCONNECT for LUTYPE4 logical units.\nIt occurs for a terminal-related error, such as a session failure. This condition applies to SNA-\nconnected LUs only. Because of the asynchronous nature of this condition, the application program\nshould check, using SEND CONFIRM or SYNCPOINT, to make sure any errors still outstanding have\nbeen resolved before it relinquishes control. If you want to handle this condition, you must first issue\na FREE command to free the session. If you do not do this, an INVREQ condition occurs, plus an ATCV\nabend if you do not handle this condition.\nA CANCEL TASK request by a user node error program (NEP) may cause this condition if the task has\nan outstanding terminal control request active when the node abnormal condition program handles\nthe session error.\nDefault action: terminate the task abnormally with abend code ATNI.\nISSUE DISCONNECT (LUTYPE6.1)\nDisconnect an LUTYPE6.1 logical unit.\nISSUE DISCONNECT (LUTYPE6.1)\nISSUE DISCONNECT\nSESSION(  name )\nConditions: NOTALLOC, TERMERR\n \n276  CICS TS for z/OS: API Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 136. SYSADATA parse tree record (continued)\nField\nSize\nDescription\n \n \n0033\nBEFORE\n0034\nAFTER\n", "output": "Table 136. SYSADATA parse tree record (continued)\nField\nSize\nDescription\n \n \n0033\nBEFORE\n0034\nAFTER\n0035\nEXCEPTION\n0036\nCORRESPONDING\n0037\nReserved for future use\n0038\nRETURNING\n0039\nGIVING\n0040\nTHROUGH\n0041\nKEY\n0042\nDELIMITER\n0043\nPOINTER\n0044\nCOUNT\n0045\nMETHOD\n0046\nPROGRAM\n0047\nINPUT\n0048\nOUTPUT\n0049\nI-O\n0050\nEXTEND\n0051\nRELOAD\n0052\nASCENDING\n0053\nDESCENDING\n914  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "Explain this COBOL concept", "input": "Table 46. Options and descriptions (continued)\nOptions\nDescriptions\n--mode <PURE31|PURE64|MIX_31_64>\n-m <PURE31|PURE64|MIX_31_64>\n(DEPRECATED)\nJava/COBOL interoperability mode.\nSpecify PURE31 for AMODE 31 COBOL/31-bit Java\napplication.\nSpecify PURE64 for AMODE 64 COBOL/64-bit Java\napplication.\nSpecify MIX_31_64 for AMODE 31 COBOL/64-bit\nJava application.\nNote: You must build COBOL files with\nJAVAIOP(JAVA64) option for MIX_31_64 mode\napplications.\nDefault: PURE31\nNote: This option is no longer required for\ncjbuild. The mode is now automatically deduced\nfrom the stub files. Although you can still specify\nit, the value will be ignored unless it conflicts with\nthe deduced mode, in which case an error message\nwill be issued.\n--pkgname <package-name>\n-p <package-name>\nName of package with which these native methods\nwill be associated. Each application should have its\nown package name.\nFor example:\ncom.acme.COBOL.myapp1\nThree classes will be created as part of this\npackage:\n     com.acme.COBOL.myapp1.cobol\n     com.acme.COBOL.myapp1.progs\n     com.acme.COBOL.myapp1.strg\nDefault: enterprise.COBOL\n--verbose\n-v\nVerbose output. Shows compile/link commands\nexecuted.\nDefault: N/A\n--version\nPrints cjbuild version information.\nRelated tasks   \nChapter 18, “Compiling, linking, and running non-OO COBOL applications that interoperate with Java,” on \npage 315  \n“Example: COBPROD application - building and running” on page 321 \nRelated references   \nJAVA-CALLABLE (Enterprise COBOL for z/OS Language Reference)    \nJAVA-SHAREABLE (Enterprise COBOL for z/OS Language Reference)\nCALL statement (Enterprise COBOL for z/OS Language Reference)\nChapter 18. Compiling, linking, and running non-OO COBOL applications that interoperate with Java  347", "output": "Table 46. Options and descriptions (continued)\nOptions\nDescriptions\n--mode <PURE31|PURE64|MIX_31_64>\n-m <PURE31|PURE64|MIX_31_64>\n(DEPRECATED)\nJava/COBOL interoperability mode.\nSpecify PURE31 for AMODE 31 COBOL/31-bit Java\napplication.\nSpecify PURE64 for AMODE 64 COBOL/64-bit Java\napplication.\nSpecify MIX_31_64 for AMODE 31 COBOL/64-bit\nJava application.\nNote: You must build COBOL files with\nJAVAIOP(JAVA64) option for MIX_31_64 mode\napplications.\nDefault: PURE31\nNote: This option is no longer required for\ncjbuild. The mode is now automatically deduced\nfrom the stub files. Although you can still specify\nit, the value will be ignored unless it conflicts with\nthe deduced mode, in which case an error message\nwill be issued.\n--pkgname <package-name>\n-p <package-name>\nName of package with which these native methods\nwill be associated. Each application should have its\nown package name.\nFor example:\ncom.acme.COBOL.myapp1\nThree classes will be created as part of this\npackage:\n     com.acme.COBOL.myapp1.cobol\n     com.acme.COBOL.myapp1.progs\n     com.acme.COBOL.myapp1.strg\nDefault: enterprise.COBOL\n--verbose\n-v\nVerbose output. Shows compile/link commands\nexecuted.\nDefault: N/A\n--version\nPrints cjbuild version information.\nRelated tasks   \nChapter 18, “Compiling, linking, and running non-OO COBOL applications that interoperate with Java,” on \npage 315  \n“Example: COBPROD application - building and running” on page 321 \nRelated references   \nJAVA-CALLABLE (Enterprise COBOL for z/OS Language Reference)    \nJAVA-SHAREABLE (Enterprise COBOL for z/OS Language Reference)\nCALL statement (Enterprise COBOL for z/OS Language Reference)\nChapter 18. Compiling, linking, and running non-OO COBOL applications that interoperate with Java  347"}
{"instruction": "Explain this COBOL concept", "input": "29\nThe repository file is unavailable.\n30\nAn input/output error has occurred on the repository file.\n16 INVREQ\nRESP2 values:\n1\nThere is no current activity within the scope of this task.\n17 IOERR\nRESP2 values:\n30\nAn input/output error has occurred on the repository file.\n70 NOTAUTH\nRESP2 values:\n101\nThe user associated with the issuing task is not authorized to access this resource in the way\nrequested.\nSTARTBROWSE PROCESS\nStart a browse of all processes of a specified type within the CICS business transaction services system.\nSTARTBROWSE PROCESS\nSTARTBROWSE\nPROCESS\nPROCESSTYPE(  data-value )\nBROWSETOKEN(  data-area )\nConditions: IOERR, NOTAUTH, PROCESSERR\nDescription\nSTARTBROWSE PROCESS initializes a browse token which can be used to identify each process of a\nspecified type within the CICS business transaction services system.\nWhen you add a process to the BTS system, you use the PROCESSTYPE option of the DEFINE PROCESS\ncommand to categorize it. You specify the name of a PROCESSTYPE resource definition, which in turn\nnames a CICS file definition that maps to a physical VSAM data set (the repository) on which details of the\nprocess and its constituent activities will be stored. (Records for multiple process-types can be stored on\nthe same repository data set.)\nThe STARTBROWSE PROCESS command enables you to start a browse of processes of a specified type.\nOptions\nBROWSETOKEN(data-area)\nspecifies a fullword binary data area, into which CICS will place the browse token.\nPROCESSTYPE(data-value)\nspecifies the process-type (1–8 characters) of the processes to be browsed.\nConditions\n17 IOERR\nRESP2 values:\n29\nThe repository file is unavailable.\nChapter 2. CICS command summary  549", "output": "29\nThe repository file is unavailable.\n30\nAn input/output error has occurred on the repository file.\n16 INVREQ\nRESP2 values:\n1\nThere is no current activity within the scope of this task.\n17 IOERR\nRESP2 values:\n30\nAn input/output error has occurred on the repository file.\n70 NOTAUTH\nRESP2 values:\n101\nThe user associated with the issuing task is not authorized to access this resource in the way\nrequested.\nSTARTBROWSE PROCESS\nStart a browse of all processes of a specified type within the CICS business transaction services system.\nSTARTBROWSE PROCESS\nSTARTBROWSE\nPROCESS\nPROCESSTYPE(  data-value )\nBROWSETOKEN(  data-area )\nConditions: IOERR, NOTAUTH, PROCESSERR\nDescription\nSTARTBROWSE PROCESS initializes a browse token which can be used to identify each process of a\nspecified type within the CICS business transaction services system.\nWhen you add a process to the BTS system, you use the PROCESSTYPE option of the DEFINE PROCESS\ncommand to categorize it. You specify the name of a PROCESSTYPE resource definition, which in turn\nnames a CICS file definition that maps to a physical VSAM data set (the repository) on which details of the\nprocess and its constituent activities will be stored. (Records for multiple process-types can be stored on\nthe same repository data set.)\nThe STARTBROWSE PROCESS command enables you to start a browse of processes of a specified type.\nOptions\nBROWSETOKEN(data-area)\nspecifies a fullword binary data area, into which CICS will place the browse token.\nPROCESSTYPE(data-value)\nspecifies the process-type (1–8 characters) of the processes to be browsed.\nConditions\n17 IOERR\nRESP2 values:\n29\nThe repository file is unavailable.\nChapter 2. CICS command summary  549"}
{"instruction": "What is PERFORM procedure integration in COBOL?", "input": "", "output": "PERFORM procedure integration is process whereby a PERFORM statement is replaced by its\nperformed procedures"}
{"instruction": "Explain this COBOL concept", "input": "5\nA CONTAINER specified in the web service binding file could not be located.\n6\nThe specified URIMAP could not be located.\n124 TIMEDOUT\nRESP2 values:\n1\nAn expected timeout has occurred. When the message exchange pattern specifies an optional\nerror response, and an error response is not returned from the remote web service, the timeout is\nacceptable.\n2\nAn unexpected timeout has occurred. A response was expected from the remote web service, but\nnone was received.\n62\nAn unexpected timeout has occurred on socket receive.\nINVOKE WEBSERVICE\nCall a service from a CICS application. This command is a synonym of the INVOKE SERVICE command\nand is provided for compatibility with existing web service requester applications. Use INVOKE SERVICE\nfor any new web service applications.\nDescription\nFor details of the INVOKE SERVICE command, see “INVOKE SERVICE” on page 263.\nISSUE ABEND\nAbend the mapped conversation with an APPC partner. \nISSUE ABEND (APPC)\nISSUE ABEND\nCONVID(  name )\nSTATE(  cvda)\nConditions: INVREQ, NOTALLOC, TERMERR\n \nDescription\nISSUE ABEND abnormally ends the conversation. The partner transaction sees the TERMERR condition.\nOptions\nCONVID(name)\nidentifies the conversation to be abended. The 4-character name identifies either the symbolic\nidentifier returned by a previously executed ALLOCATE command in EIBRSRCE in the EIB, or the\nsymbolic identifier representing the principal facility (returned by a previously executed ASSIGN\ncommand).\nFor compatibility with earlier releases, SESSION is accepted as a synonym for CONVID. New programs\nshould use CONVID.\nIf both CONVID and SESSION are omitted, the principal facility is assumed.\n268  CICS TS for z/OS: API Reference", "output": "5\nA CONTAINER specified in the web service binding file could not be located.\n6\nThe specified URIMAP could not be located.\n124 TIMEDOUT\nRESP2 values:\n1\nAn expected timeout has occurred. When the message exchange pattern specifies an optional\nerror response, and an error response is not returned from the remote web service, the timeout is\nacceptable.\n2\nAn unexpected timeout has occurred. A response was expected from the remote web service, but\nnone was received.\n62\nAn unexpected timeout has occurred on socket receive.\nINVOKE WEBSERVICE\nCall a service from a CICS application. This command is a synonym of the INVOKE SERVICE command\nand is provided for compatibility with existing web service requester applications. Use INVOKE SERVICE\nfor any new web service applications.\nDescription\nFor details of the INVOKE SERVICE command, see “INVOKE SERVICE” on page 263.\nISSUE ABEND\nAbend the mapped conversation with an APPC partner. \nISSUE ABEND (APPC)\nISSUE ABEND\nCONVID(  name )\nSTATE(  cvda)\nConditions: INVREQ, NOTALLOC, TERMERR\n \nDescription\nISSUE ABEND abnormally ends the conversation. The partner transaction sees the TERMERR condition.\nOptions\nCONVID(name)\nidentifies the conversation to be abended. The 4-character name identifies either the symbolic\nidentifier returned by a previously executed ALLOCATE command in EIBRSRCE in the EIB, or the\nsymbolic identifier representing the principal facility (returned by a previously executed ASSIGN\ncommand).\nFor compatibility with earlier releases, SESSION is accepted as a synonym for CONVID. New programs\nshould use CONVID.\nIf both CONVID and SESSION are omitted, the principal facility is assumed.\n268  CICS TS for z/OS: API Reference"}
{"instruction": "Explain this COBOL concept", "input": "Description\nEXTRACT ATTRIBUTES (MRO) extracts conversation state information for MRO conversations.\nOptions\nCONVID(name)\nidentifies the conversation to which the command relates. The 4-character name identifies either the\ntoken returned by a previously executed ALLOCATE command in EIBRSRCE in the EIB, or the token\nrepresenting the principal session (returned by a previously executed ASSIGN command).\nSESSION(name)\nspecifies the symbolic identifier (1–4 characters) of a session TCTTE. This option specifies the\nalternate facility to be used.\nIf both this option and CONVID are omitted, the principal facility for the task is used.\nSTATE(cvda)\ngets the state of the transaction program. The cvda values returned by CICS are:\n• ALLOCATED \n• FREE \n• PENDFREE \n• RECEIVE \n• ROLLBACK \n• SEND \n• SYNCFREE \n• SYNCRECEIVE \n• SYNCSEND \nConditions\n16 INVREQ\nRESP2 values:\n200\nA distributed program link server application explicitly, or implicitly by default, specified the\nfunction-shipping session (its principal facility) on the CONVID option.\nalso occurs (RESP2 not set) in any of the following situations:\n• An incorrect command has been issued for the terminal or LU in use.\nDefault action: terminate the task abnormally.\n61 NOTALLOC\noccurs if the facility specified in the command is not owned by the application.\nDefault action: terminate the task abnormally.\nEXTRACT CERTIFICATE\nObtain information from the client certificate received over a TCP/IP service that specified client\nauthentication.\n166  CICS TS for z/OS: API Reference", "output": "Description\nEXTRACT ATTRIBUTES (MRO) extracts conversation state information for MRO conversations.\nOptions\nCONVID(name)\nidentifies the conversation to which the command relates. The 4-character name identifies either the\ntoken returned by a previously executed ALLOCATE command in EIBRSRCE in the EIB, or the token\nrepresenting the principal session (returned by a previously executed ASSIGN command).\nSESSION(name)\nspecifies the symbolic identifier (1–4 characters) of a session TCTTE. This option specifies the\nalternate facility to be used.\nIf both this option and CONVID are omitted, the principal facility for the task is used.\nSTATE(cvda)\ngets the state of the transaction program. The cvda values returned by CICS are:\n• ALLOCATED \n• FREE \n• PENDFREE \n• RECEIVE \n• ROLLBACK \n• SEND \n• SYNCFREE \n• SYNCRECEIVE \n• SYNCSEND \nConditions\n16 INVREQ\nRESP2 values:\n200\nA distributed program link server application explicitly, or implicitly by default, specified the\nfunction-shipping session (its principal facility) on the CONVID option.\nalso occurs (RESP2 not set) in any of the following situations:\n• An incorrect command has been issued for the terminal or LU in use.\nDefault action: terminate the task abnormally.\n61 NOTALLOC\noccurs if the facility specified in the command is not owned by the application.\nDefault action: terminate the task abnormally.\nEXTRACT CERTIFICATE\nObtain information from the client certificate received over a TCP/IP service that specified client\nauthentication.\n166  CICS TS for z/OS: API Reference"}
{"instruction": "Summarize this COBOL documentation section", "input": "SEND TEXT Standard BMS\nFROM( data-area )\nLENGTH( data-value )\nCURSOR(  data-value )\nFORMFEED\nERASE\nDEFAULT\nALTERNATE\nPRINT\nFREEKB\nALARM\nNLEOM\nFMHPARM(  name )\nOUTPARTN(  name )\nACTPARTN(  name )\nLDC( name )\nMSR( data-value )\nSEND TEXT Full BMS\nTERMINAL\nSET( ptr-ref )\nPAGING\nTERMINAL\nWAIT\nLAST\nREQID( name )\nHEADER( data-area )\nTRAILER(  data-area )\nJUSTIFY(  data-value )\nJUSFIRST\nJUSLAST\nACCUM\nHONEOM\nL40\nL64\nL80\nConditions: IGREQCD, IGREQID, INVLDC, INVPARTN, INVREQ, LENGERR, RETPAGE, TSIOERR, WRBRK\n \nDescription\nSEND TEXT sends text data without mapping. The text is split into lines of the same width as the terminal,\nsuch that words are not broken across line boundaries. If the text exceeds a page, it is split into pages\nthat fit on the terminal with application-defined headers and trailers.\nWhen using the SEND TEXT command with any of the ALARM, FREEKB, FRSET, HONEOM, L40, L64, L80,\nor PRINT options, see DFHMDI options, CTRL for a description of the option priority.\nOptions\n480  CICS TS for z/OS: API Reference", "output": "SEND TEXT Standard BMS\nFROM( data-area )\nLENGTH( data-value )\nCURSOR(  data-value )\nFORMFEED\nERASE\nDEFAULT\nALTERNATE\nPRINT\nFREEKB\nALARM\nNLEOM\nFMHPARM(  name )\nOUTPARTN(  name )\nACTPARTN(  name )\nLDC( name )\nMSR( data-value )\nSEND TEXT Full BMS\nTERMINAL\nSET( ptr-ref )\nPAGING\nTERMINAL\nWAIT\nLAST\nREQID( name )\nHEADER( data-area )\nTRAILER(  data-area )\nJUSTIFY(  data-value )\nJUSFIRST\nJUSLAST\nACCUM\nHONEOM\nL40\nL64\nL80\nConditions: IGREQCD, IGREQID, INVLDC, INVPARTN, INVREQ, LENGERR, RETPAGE, TSIOERR, WRBRK\n \nDescription\nSEND TEXT sends text data without mapping. The text is split into lines of the same width as the terminal,\nsuch that words are not broken across line boundaries. If the text exceeds a page, it is split into pages\nthat fit on the terminal with application-defined headers and trailers.\nWhen using the SEND TEXT command with any of the ALARM, FREEKB, FRSET, HONEOM, L40, L64, L80,\nor PRINT options, see DFHMDI options, CTRL for a description of the option priority.\nOptions\n480  CICS TS for z/OS: API Reference"}
{"instruction": "Summarize this COBOL documentation section", "input": "The sequence of data elements (from left to right) is:\nTwo digits for the year\nTwo digits for the month\nTwo digits for the day\nThus 27 April 2003 is expressed as 030427.\nDATE YYYYMMDD\nHas the implicit PICTURE 9(8).\nThe sequence of data elements (from left to right) is:\nFour digits for the year\nTwo digits for the month\nTwo digits for the day\nThus 27 April 2003 is expressed as 20030427.\nDAY\nHas the implicit PICTURE 9(5).\nThe sequence of data elements (from left to right) is:\nTwo digits for the year\nThree digits for the day\nThus 27 April 2003 is expressed as 03117.\nDAY YYYYDDD\nHas the implicit PICTURE 9(7).\nThe sequence of data elements (from left to right) is:\nFour digits for the year\nThree digits for the day\nThus 27 April 2003 is expressed as 2003117.\nDAY-OF-WEEK\nHas the implicit PICTURE 9(1).\nThe single data element represents the day of the week according to the following values:\n1 represents Monday           5 represents Friday\n2 represents Tuesday          6 represents Saturday\n3 represents Wednesday        7 represents Sunday\n4 represents Thursday\nThus Wednesday is expressed as 3.\nTIME\nHas the implicit PICTURE 9(8).\nThe sequence of data elements (from left to right) is:\nTwo digits for hour of day\nTwo digits for minute of hour\nTwo digits for second of minute\nTwo digits for hundredths of second\nThus 2:41 PM is expressed as 14410000.\n316  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "The sequence of data elements (from left to right) is:\nTwo digits for the year\nTwo digits for the month\nTwo digits for the day\nThus 27 April 2003 is expressed as 030427.\nDATE YYYYMMDD\nHas the implicit PICTURE 9(8).\nThe sequence of data elements (from left to right) is:\nFour digits for the year\nTwo digits for the month\nTwo digits for the day\nThus 27 April 2003 is expressed as 20030427.\nDAY\nHas the implicit PICTURE 9(5).\nThe sequence of data elements (from left to right) is:\nTwo digits for the year\nThree digits for the day\nThus 27 April 2003 is expressed as 03117.\nDAY YYYYDDD\nHas the implicit PICTURE 9(7).\nThe sequence of data elements (from left to right) is:\nFour digits for the year\nThree digits for the day\nThus 27 April 2003 is expressed as 2003117.\nDAY-OF-WEEK\nHas the implicit PICTURE 9(1).\nThe single data element represents the day of the week according to the following values:\n1 represents Monday           5 represents Friday\n2 represents Tuesday          6 represents Saturday\n3 represents Wednesday        7 represents Sunday\n4 represents Thursday\nThus Wednesday is expressed as 3.\nTIME\nHas the implicit PICTURE 9(8).\nThe sequence of data elements (from left to right) is:\nTwo digits for hour of day\nTwo digits for minute of hour\nTwo digits for second of minute\nTwo digits for hundredths of second\nThus 2:41 PM is expressed as 14410000.\n316  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What is Include the USING phrase in the CALL statement only if there in COBOL?", "input": "", "output": "Include the USING phrase in the CALL statement only if there is USING phrase in the PROCEDURE\nDIVISION header or the ENTRY statement through which the called program is run"}
{"instruction": "Summarize this COBOL documentation section", "input": "Table 131. SYSADATA job identification record (continued)\nField\nSize\nDescription\n1. Where the number of input files would exceed the record size for the associated data file, the record\nis continued on the next record. The current number of input files (for that record) is stored in the\nrecord, and the record is written to the associated data file. The next record contains the rest of the\ninput files. The count of the number of input files is a count for the current record.\nADATA identification record: X'0001'\nThe following table shows the contents of the ADATA identification record.\nTable 132. ADATA identification record\nField\nSize\nDescription\nTime (binary)\nXL8\nUniversal Time (UT) as a binary number of microseconds\nsince midnight Greenwich Mean Time, with the low-order bit\nrepresenting 1 microsecond. This time can be used as a time-zone-\nindependent time stamp.\nCCSID1\nXL2\nCoded Character Set Identifier\nCharacter-set flags\nXL1\nX'80'\nEBCDIC (IBM-037)\nX'40'\nASCII (IBM-1252)\nCode-page name length\nXL2\nLength of the code-page name that follows\nCode-page name\nCL(n)\nName of the code page\n1. The appropriate CCS flag will always be set. If the CCSID is set to nonzero, the code-page name\nlength will be zero. If the CCSID is set to zero, the code-page name length will be nonzero and the\ncode-page name will be present.\nCompilation unit start | end record: X'0002'\nThe following table shows the contents of the compilation unit start|end record.\nTable 133. SYSADATA compilation unit start | end record\nField\nSize\nDescription\nType\nHL2\nCompilation unit type, which is one of the following options:\nX'0000'\nStart compilation unit\nX'0001'\nEnd compilation unit\nReserved\nCL2\nReserved for future use\nReserved\nFL4\nReserved for future use\n884  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "Table 131. SYSADATA job identification record (continued)\nField\nSize\nDescription\n1. Where the number of input files would exceed the record size for the associated data file, the record\nis continued on the next record. The current number of input files (for that record) is stored in the\nrecord, and the record is written to the associated data file. The next record contains the rest of the\ninput files. The count of the number of input files is a count for the current record.\nADATA identification record: X'0001'\nThe following table shows the contents of the ADATA identification record.\nTable 132. ADATA identification record\nField\nSize\nDescription\nTime (binary)\nXL8\nUniversal Time (UT) as a binary number of microseconds\nsince midnight Greenwich Mean Time, with the low-order bit\nrepresenting 1 microsecond. This time can be used as a time-zone-\nindependent time stamp.\nCCSID1\nXL2\nCoded Character Set Identifier\nCharacter-set flags\nXL1\nX'80'\nEBCDIC (IBM-037)\nX'40'\nASCII (IBM-1252)\nCode-page name length\nXL2\nLength of the code-page name that follows\nCode-page name\nCL(n)\nName of the code page\n1. The appropriate CCS flag will always be set. If the CCSID is set to nonzero, the code-page name\nlength will be zero. If the CCSID is set to zero, the code-page name length will be nonzero and the\ncode-page name will be present.\nCompilation unit start | end record: X'0002'\nThe following table shows the contents of the compilation unit start|end record.\nTable 133. SYSADATA compilation unit start | end record\nField\nSize\nDescription\nType\nHL2\nCompilation unit type, which is one of the following options:\nX'0000'\nStart compilation unit\nX'0001'\nEnd compilation unit\nReserved\nCL2\nReserved for future use\nReserved\nFL4\nReserved for future use\n884  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 80. Java-compatible array COBOL types (continued)\nArray COBOL Data Types\nJava Data Types\n01 fl", "output": "Table 80. Java-compatible array COBOL types (continued)\nArray COBOL Data Types\nJava Data Types\n01 float-list.\n   03 f1 pic comp-1 occurs m times.\nfloat[m]\n01 double-list.\n   03 d1 pic comp-2 occurs m times.\ndouble[m]\n01 bool-list.\n   03 b1 pic x occurs m times.\n      88 flag-false value x'00'.\n      88 flag-true value x'01'.\nboolean[m]\n01 dec-list.\n   03 n1 pic s9(m)[v9(n))] display/comp-3 \noccurs j times.\nBigDecimal[j]1\n01 alpha-list.\n   03 s1 pic x(m) occurs n times.\nwhere m>1.\nString[n]1\n01 nat-list.\n   03 n1 pic n(m) occurs n times.\nString[n]1\n01 utf8-list.\n   03 u1 pic u(m) occurs m times.\nString[m]1\nTable 81. Java-compatible alphanumeric group COBOL types\nAlphanumeric Group COBOL Data Types\nJava Data Types\nAny alphanumeric group item that does not satisfy\nthe definition of a Java-compatible array type is\nconsidered to map to a Java byte array (byte[]) and\nit is the Java application's responsibility to both\nread and set the byte array appropriately based on\nthe corresponding COBOL group definition.\nbyte[]\nNote: 1When these objects are used as arguments, any changes to the corresponding data in COBOL will\nnot be reflected on the Java side of the application.\nAlphanumeric groups\nAn alphanumeric group item in COBOL that does not satisfy the definition of one of the Java-compatible\narray types can still be used as an argument in a call to a static Java method and as a parameter in a\nCOBOL program that is callable from Java.\nWhen the group is used as a parameter in a Java callable program, it is assumed that the data being\npassed from Java to the parameter is a byte array object (byte[]), and it is the responsibility of the calling\nJava method to set up the data in the corresponding byte array to match the byte layout of the receiving\nChapter 114. Compiler directives  737"}
{"instruction": "Summarize this COBOL documentation section", "input": "Chapter 35. Web Services interface\nCOBOL can provide or request Web Services, using architectures based on SOAP (Simple Object Access\nProtocol) or REST (REpresentational State Transfer). Data in the interface to such services is typically\nrepresented in JSON (JavaScript Object Notation) or XML (eXtensible Markup Language). The following\ninformation describes COBOL and other facilities that can be used to generate and consume JSON and\nXML.\nProcessing JSON input\nYou can process JSON text input in a COBOL program by using the JSON PARSE statement. The statement\nidentifies the source data item containing the JSON text, and the receiving data item that is populated by\nthe parser.\nIn addition, the z/OS Client Web Enablement Toolkit enables applications to participate in the client/\nserver space by providing a built-in z/OS JSON parser (provided with z/OS 2.2, or z/OS 2.1 with the\nPTF for APAR OA46575 installed) to consume JSON text from any source. Be aware that this parser\nsupports JSON texts in EBCDIC codepage 1047 only, thus JSON text received by the application in\nanother encoding format must first be converted to EBCDIC 1047 before it can be input into the parser.\nFor details, see the description of the z/OS JSON parser in z/OS MVS Programming: Callable Services for\nHigh-Level Languages.\nRelated tasks   \nChapter 36, “Processing JSON input ,” on page 635\nChapter 37, “Producing JSON output ,” on page 645\nChapter 38, “Processing XML input,” on page 649\nChapter 39, “Producing XML output,” on page 689\n© Copyright IBM Corp. 1991, 2025\n633", "output": "Chapter 35. Web Services interface\nCOBOL can provide or request Web Services, using architectures based on SOAP (Simple Object Access\nProtocol) or REST (REpresentational State Transfer). Data in the interface to such services is typically\nrepresented in JSON (JavaScript Object Notation) or XML (eXtensible Markup Language). The following\ninformation describes COBOL and other facilities that can be used to generate and consume JSON and\nXML.\nProcessing JSON input\nYou can process JSON text input in a COBOL program by using the JSON PARSE statement. The statement\nidentifies the source data item containing the JSON text, and the receiving data item that is populated by\nthe parser.\nIn addition, the z/OS Client Web Enablement Toolkit enables applications to participate in the client/\nserver space by providing a built-in z/OS JSON parser (provided with z/OS 2.2, or z/OS 2.1 with the\nPTF for APAR OA46575 installed) to consume JSON text from any source. Be aware that this parser\nsupports JSON texts in EBCDIC codepage 1047 only, thus JSON text received by the application in\nanother encoding format must first be converted to EBCDIC 1047 before it can be input into the parser.\nFor details, see the description of the z/OS JSON parser in z/OS MVS Programming: Callable Services for\nHigh-Level Languages.\nRelated tasks   \nChapter 36, “Processing JSON input ,” on page 635\nChapter 37, “Producing JSON output ,” on page 645\nChapter 38, “Processing XML input,” on page 649\nChapter 39, “Producing XML output,” on page 689\n© Copyright IBM Corp. 1991, 2025\n633"}
{"instruction": "Explain this COBOL concept", "input": "Comparison of commonly used terms\nTo better understand the terms used throughout the IBM z/OS Language Environment and IBM Enterprise\nCOBOL for z/OS information, and to understand which terms are meant to be equivalent, see the following\ntable.\nLanguage Environment term\nEnterprise COBOL equivalent\nAggregate\nGroup item\nArray\nA table created using the OCCURS clause\nArray element\nTable element\nEnclave\nRun unit\nExternal data\nWORKING-STORAGE data defined using the EXTERNAL clause\nLocal data\nAny non-EXTERNAL data item\nPass parameters directly, by value\nBY VALUE\nPass parameters indirectly, by reference\nBY REFERENCE\nPass parameters indirectly, by value\nBY CONTENT\nRoutine\nProgram\nScalar\nElementary item\nHow to read syntax diagrams\nUse the following description to read the syntax diagrams in this information.\n• Read the syntax diagrams from left to right, from top to bottom, following the path of the line.\nThe ►►─── symbol indicates the beginning of a syntax diagram.\nThe ───► symbol indicates that the syntax diagram is continued on the next line.\nThe ►─── symbol indicates that the syntax diagram is continued from the previous line.\nThe ───►◄ symbol indicates the end of a syntax diagram.\nDiagrams of syntactical units other than complete statements start with the ►─── symbol and end with\nthe ───► symbol.\n• Required items appear on the horizontal line (the main path):\nrequired_item\n• Optional items appear below the main path:\nrequired_item\noptional_item\n• If you can choose from two or more items, they appear vertically, in a stack. If you must choose one of\nthe items, one item of the stack appears on the main path:\nPreface  xxxi", "output": "Comparison of commonly used terms\nTo better understand the terms used throughout the IBM z/OS Language Environment and IBM Enterprise\nCOBOL for z/OS information, and to understand which terms are meant to be equivalent, see the following\ntable.\nLanguage Environment term\nEnterprise COBOL equivalent\nAggregate\nGroup item\nArray\nA table created using the OCCURS clause\nArray element\nTable element\nEnclave\nRun unit\nExternal data\nWORKING-STORAGE data defined using the EXTERNAL clause\nLocal data\nAny non-EXTERNAL data item\nPass parameters directly, by value\nBY VALUE\nPass parameters indirectly, by reference\nBY REFERENCE\nPass parameters indirectly, by value\nBY CONTENT\nRoutine\nProgram\nScalar\nElementary item\nHow to read syntax diagrams\nUse the following description to read the syntax diagrams in this information.\n• Read the syntax diagrams from left to right, from top to bottom, following the path of the line.\nThe ►►─── symbol indicates the beginning of a syntax diagram.\nThe ───► symbol indicates that the syntax diagram is continued on the next line.\nThe ►─── symbol indicates that the syntax diagram is continued from the previous line.\nThe ───►◄ symbol indicates the end of a syntax diagram.\nDiagrams of syntactical units other than complete statements start with the ►─── symbol and end with\nthe ───► symbol.\n• Required items appear on the horizontal line (the main path):\nrequired_item\n• Optional items appear below the main path:\nrequired_item\noptional_item\n• If you can choose from two or more items, they appear vertically, in a stack. If you must choose one of\nthe items, one item of the stack appears on the main path:\nPreface  xxxi"}
{"instruction": "What is that in COBOL?", "input": "", "output": "that is reference to an object of class java.lang.Object.\n(This SET statement is legal because java.lang.String is a subclass of java.lang.Object.) The client then\npasses anObj as the argument to M.\n . ."}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "The DATA(24) option is discarded when LP(64) is in effect. Data items in WORKING-STORAGE SECTION\nare", "output": "The DATA(24) option is discarded when LP(64) is in effect. Data items in WORKING-STORAGE SECTION\nare allocated above the bar. Data items in LOCAL section are allocated on the Language Environment\nstack, which is also above the bar.\nAFP and HGPR\nThese two options control the compiler’s register usage and are discarded by the compiler when LP(64)\nis in effect. The generated code is guaranteed to work in the Language Environment, and can call or be\ncalled by other Language Environment AMODE 64 high-level languages. User application cannot control\nregister usage of the COBOL compiler.\n“CICS” on page 366, “SQL” on page 424, SQLIMS, “SQLCCSID” on page 425, “THREAD” on\npage 434\nThese options are discarded in LP(64). In addition, the output of the SQL precompiler is not compatible\nwith AMODE 64.\nRuntime options\nThe following COBOL only runtime options are supported in LP(64):\n• AIXBLD\n• CBLQDA\n• DEBUG\n• SIMVRD\n• UPSI\nThe following runtime options are not supported:\n• ALL31\nThis option is meaningful only in AMODE 31.\n• CBLOPTS\n• CBLPSHPOP\nThis option applies only for OS VS program under CICS.\n• MSGFILE\nThis option is not supported by the Language Environment in AMODE 64.\n• RTEREUS\nThis option supports COBOL runtime reuse environment using a legacy design, and is not supported in\nLP(64). To establish a reusable runtime environment, use the LE preinitialization environment feature.\nRelated references   \n    “LP” on page 397\n \nOther AMODE 64 considerations\nWhen you compile the programs to be AMODE 64, you should be aware that some compiler features are\nnot supported.\nNote the following features when you compile programs with LP(64):\nALTER statement\nThe ALTER statement encourages the usage of unstructured programming practice. The EVALUATE\nstatement provides the same functions and should be used instead.\nGO TO. statement\nNot supported in LP(64).\nChapter 27. Developing AMODE 64 programs  561"}
{"instruction": "What are the compiler rules or directives for this?", "input": "Conditions: INVREQ, IOERR, LOCKED, NOTAUTH, PROCESSBUSY, PROCESSERR", "output": "Conditions: INVREQ, IOERR, LOCKED, NOTAUTH, PROCESSBUSY, PROCESSERR"}
{"instruction": "Summarize this COBOL documentation section", "input": "Format 3: line-sequential file description entry\nFD\nfile-name-1\nIS\nEXTERNAL\nIS\nGLOBAL\nRECORD\nCONTAINS\ninteger-3\nCHARACTERS\nclause 1\nDEPENDING\nON\ndata-name-1\n.\nclause 1\nIS\nVARYING\nIN\nSIZE\nFROM\ninteger-6\nTO\ninteger-7\nCHARACTERS\n186  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "Format 3: line-sequential file description entry\nFD\nfile-name-1\nIS\nEXTERNAL\nIS\nGLOBAL\nRECORD\nCONTAINS\ninteger-3\nCHARACTERS\nclause 1\nDEPENDING\nON\ndata-name-1\n.\nclause 1\nIS\nVARYING\nIN\nSIZE\nFROM\ninteger-6\nTO\ninteger-7\nCHARACTERS\n186  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What are the compiler rules or directives for this?", "input": "the XML text fragments in national data items. (The UTF-16 encoding in national data items greatly", "output": "the XML text fragments in national data items. (The UTF-16 encoding in national data items greatly"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "DBCS\nUsing DBCS causes the compiler to recognize X'0E' (SO) and X'0F' (SI) as shift codes for the do", "output": "DBCS\nUsing DBCS causes the compiler to recognize X'0E' (SO) and X'0F' (SI) as shift codes for the double-\nbyte portion of an alphanumeric literal.\nDBCS option syntax\nDBCS\nNODBCS\nDefault is: DBCS\nAbbreviations are: None\nWith DBCS in effect, the double-byte portion of the literal is syntax-checked and the literal remains\ncategory alphanumeric.\nRelated references   \n“Conflicting compiler options” on page 358 \nDECK\nUse DECK to produce object code in the form of 80-column records. If you use the DECK option, be certain\nthat SYSPUNCH is defined in your JCL for compilation.\nDECK option syntax\nNODECK\nDECK\nDefault is: NODECK\nAbbreviations are: D | NOD\nRelated tasks   \n“Creating object code (SYSLIN or SYSPUNCH)” on page 285 \nDEFINE\nUse the DEFINE compiler option to assign a literal value to a compilation variable that is defined in\nthe program by using the DEFINE directive with the PARAMETER phrase. The literal value provided for\nthe compilation variable in the DEFINE option is sometimes referred to as a \"parameter value\" for the\ncorresponding compilation variable. Compilation variables can be used within any of the conditional\ncompilation directives, including DEFINE, EVALUATE, and IF. When a conditional compilation variable\nappears in a conditional compilation directive, it is treated as a symbolic reference to the literal value it\ncurrently represents.\nThe DEFINE compiler option provides a way for you to assign values to compilation variables from outside\nthe program source. If that is not needed, it is sufficient to use the DEFINE directive within program\nsource to define compilation variables.\n374  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What are the compiler rules or directives for this?", "input": "when:\n• This INLINE directive appears before the definition of the procedure name", "output": "when:\n• This INLINE directive appears before the definition of the procedure name"}
{"instruction": "What are the compiler rules or directives for this?", "input": "is in effect or the JAVAIOP(...,JAVA64,...) compiler option is in effect,", "output": "is in effect or the JAVAIOP(...,JAVA64,...) compiler option is in effect,"}
{"instruction": "What are the compiler rules or directives for this?", "input": "QUALIFY(EXTEND) is in effect, and if there is only one fully qualified name that", "output": "QUALIFY(EXTEND) is in effect, and if there is only one fully qualified name that"}
{"instruction": "Summarize this COBOL documentation section", "input": "70 NOTAUTH\nRESP2 values:\n101\nThe user associated with the issuing task is not authorized to access the file associated with the\nBTS repository data set on which details of the process are to be stored.\n102\nThe user associated with the issuing task is not authorized as a surrogate of the defined userid\nspecified on the USERID option.\n108 PROCESSERR\nRESP2 values:\n2\nThe process name specified on the PROCESS option is already in use on the BTS repository data\nset associated with the PROCESSTYPE option.\n9\nThe process-type specified on the PROCESSTYPE option could not be found.\n16\nThe process name specified on the PROCESS option contains an invalid character or characters.\n28 TRANSIDERR\nThe transaction identifier specified on the TRANSID option is not defined to CICS.\nDEFINE TIMER\nDefine a BTS timer.\nDEFINE TIMER\nDEFINE\nTIMER(  data-value )\nEVENT( data-value )\nAFTER\nDAYS( data-value )\nHOURS( data-value )\nMINUTES( data-value )\nSECONDS(  data-value )\nAT\nHOURS( data-value )\nMINUTES( data-value )\nSECONDS(  data-value )\ntoday\nON\nON options\nON options\nYEAR( data-value )\nMONTH( data-value )\nDAYOFMONTH(  data-value )\nDAYOFYEAR(  data-value )\nConditions: EVENTERR, INVREQ, TIMERERR\nDescription\nDEFINE TIMER defines a BTS timer that will expire after a specified interval, or at a specified time\nand date. When a timer is defined, an associated event is also defined, in the event pool of the current\nChapter 2. CICS command summary  109", "output": "70 NOTAUTH\nRESP2 values:\n101\nThe user associated with the issuing task is not authorized to access the file associated with the\nBTS repository data set on which details of the process are to be stored.\n102\nThe user associated with the issuing task is not authorized as a surrogate of the defined userid\nspecified on the USERID option.\n108 PROCESSERR\nRESP2 values:\n2\nThe process name specified on the PROCESS option is already in use on the BTS repository data\nset associated with the PROCESSTYPE option.\n9\nThe process-type specified on the PROCESSTYPE option could not be found.\n16\nThe process name specified on the PROCESS option contains an invalid character or characters.\n28 TRANSIDERR\nThe transaction identifier specified on the TRANSID option is not defined to CICS.\nDEFINE TIMER\nDefine a BTS timer.\nDEFINE TIMER\nDEFINE\nTIMER(  data-value )\nEVENT( data-value )\nAFTER\nDAYS( data-value )\nHOURS( data-value )\nMINUTES( data-value )\nSECONDS(  data-value )\nAT\nHOURS( data-value )\nMINUTES( data-value )\nSECONDS(  data-value )\ntoday\nON\nON options\nON options\nYEAR( data-value )\nMONTH( data-value )\nDAYOFMONTH(  data-value )\nDAYOFYEAR(  data-value )\nConditions: EVENTERR, INVREQ, TIMERERR\nDescription\nDEFINE TIMER defines a BTS timer that will expire after a specified interval, or at a specified time\nand date. When a timer is defined, an associated event is also defined, in the event pool of the current\nChapter 2. CICS command summary  109"}
{"instruction": "What is This in COBOL?", "input": "", "output": "This is output value returned by file control to the requesting task, for use in associating a subsequent\nREWRITE or DELETE (or UNLOCK) request with the record returned on this READNEXT command"}
{"instruction": "Explain this COBOL concept", "input": "RECEIVE (APPC)\nRECEIVE\nCONVID(  name )\nINTO( data-area )\nSET( ptr-ref )\nLENGTH( data-area )\nFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nNOTRUNCATE\nSTATE(  cvda)\nConditions: EOC, INVREQ, LENGERR, NOTALLOC, SIGNAL, TERMERR\n \nDescription\nRECEIVE receives data from the conversation partner in an APPC mapped conversation.\nRECEIVE (LUTYPE2/LUTYPE3)\nReceive data from a 3270-display logical unit (LUTYPE2) or a 3270-printer logical unit (LUTYPE3). \nRECEIVE (LUTYPE2/LUTYPE3)\nRECEIVE\nINTO( data-area )\nSET( ptr-ref )\nLENGTH( data-area )\nFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nASIS\nBUFFER\nNOTRUNCATE\nConditions: EOC, INVREQ, LENGERR, TERMERR\n \nDescription\nRECEIVE receives data from the terminal.\nIf data is to be received, you must specify either the INTO or the SET option. If a RECEIVE is issued purely\nto detect an attention identifier (AID) (and BUFFER has not been specified), you can omit both the INTO\nand SET options.\nRECEIVE (LUTYPE4)\nReceive data from an LUTYPE4 logical unit. \n384  CICS TS for z/OS: API Reference", "output": "RECEIVE (APPC)\nRECEIVE\nCONVID(  name )\nINTO( data-area )\nSET( ptr-ref )\nLENGTH( data-area )\nFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nNOTRUNCATE\nSTATE(  cvda)\nConditions: EOC, INVREQ, LENGERR, NOTALLOC, SIGNAL, TERMERR\n \nDescription\nRECEIVE receives data from the conversation partner in an APPC mapped conversation.\nRECEIVE (LUTYPE2/LUTYPE3)\nReceive data from a 3270-display logical unit (LUTYPE2) or a 3270-printer logical unit (LUTYPE3). \nRECEIVE (LUTYPE2/LUTYPE3)\nRECEIVE\nINTO( data-area )\nSET( ptr-ref )\nLENGTH( data-area )\nFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nASIS\nBUFFER\nNOTRUNCATE\nConditions: EOC, INVREQ, LENGERR, TERMERR\n \nDescription\nRECEIVE receives data from the terminal.\nIf data is to be received, you must specify either the INTO or the SET option. If a RECEIVE is issued purely\nto detect an attention identifier (AID) (and BUFFER has not been specified), you can omit both the INTO\nand SET options.\nRECEIVE (LUTYPE4)\nReceive data from an LUTYPE4 logical unit. \n384  CICS TS for z/OS: API Reference"}
{"instruction": "What are the compiler rules or directives for this?", "input": "is in effect; USAGE NATIONAL is the default when the NSYMBOL(NATIONAL) compiler", "output": "is in effect; USAGE NATIONAL is the default when the NSYMBOL(NATIONAL) compiler"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "8. The last stated subject is inserted in place of the missing subject.\n9. The last stated relationa", "output": "8. The last stated subject is inserted in place of the missing subject.\n9. The last stated relational operator is inserted in place of the missing relational operator.\n10. Insertion of the omitted subject or relational operator ends when:\na. Another simple condition is encountered.\nb. A condition-name is encountered.\nc. A right parenthesis is encountered that matches a left parenthesis that appears to the left of the\nsubject.\n11. In any consecutive sequence of relation conditions, you can use both abbreviated relation conditions\nthat contain parentheses and those that do not.\n12. Consecutive logical NOT operators cancel each other and result in an S-level message. Note,\nhowever, that an abbreviated combined relation condition can contain two consecutive NOT\noperators when the second NOT is part of a relational operator. For example, you can abbreviate\nthe first condition as the second condition listed below.\nA = B and not A not = C\nA = B and not not = C\nThe following table summarizes the rules for forming an abbreviated combined relation condition.\nTable 30. Abbreviated combined conditions: permissible element sequences\nCombined\ncondition\nelement\nLeft- most\nWhen not leftmost, can be\nimmediately preceded by:\nRight-\nmost\nWhen not rightmost, can be\nimmediately followed by:\nSubject\nYes\nNOT\n(\nNo\nRelational operator\nObject\nNo\nRelational operator\nAND\nOR\nNOT\n(\nYes\nAND\nOR\n)\nRelational\noperator\nNo\nSubject\nAND\nOR\nNOT\nNo\nObject\n(\nAND\nOR\nNo\nObject\n)\nNo\nObject\nRelational operator\nNOT\n(\nNOT\nYes\nAND\nOR\n(\nNo\nSubject\nObject\nRelational operator\n(\nChapter 27. Procedure division structure  295"}
{"instruction": "What is the syntax for this COBOL construct?", "input": "rules for single-byte characters in the literal follow the rules for basic alphanumeric", "output": "rules for single-byte characters in the literal follow the rules for basic alphanumeric"}
{"instruction": "What is c89 in COBOL?", "input": "", "output": "c89 is shell\ninterface to the linker (the z/OS program management binder)"}
{"instruction": "What is a reference to that\nname from an instance method in COBOL?", "input": "", "output": "a reference to that\nname from an instance method is reference to the resource in the object DATA DIVISION"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "• RR_PROGRAM_STATE_CHECK, shown as abend code ASP2\n• RR_BACKED_OUT_OUTCOME_PENDING, RR_BACKED_OUT\n• ", "output": "• RR_PROGRAM_STATE_CHECK, shown as abend code ASP2\n• RR_BACKED_OUT_OUTCOME_PENDING, RR_BACKED_OUT\n• RR_BACKED_OUT_OUTCOME MIXED, RR_BACKED_OUT\nSRRBACK\nThe SAA Resource Recovery backout call SRRBACK (equivalent to EXEC CICS SYNCPOINT ROLLBACK) has\nthe following return codes:\n• RR_OK\n• RR_COMMITTED_OUTCOME_PENDING\n• RR_COMMITTED_OUTCOME_MIXED\nBecause of the restriction, all these are replaced by RR_OK.\n778  CICS TS for z/OS: API Reference"}
{"instruction": "Explain this COBOL concept", "input": "INPUT\nInput\nSYSTEM\nSystem\nTIMER\nTimer.\nFIRESTATUS(cvda)\nindicates the state of the named event. CVDA values are:\nFIRED\nThe event has fired normally.\nNOTFIRED\nThe event has not fired.\nPREDICATE(cvda)\nindicates, if the named event is composite, the Boolean operator applied to its predicate. CVDA values\nare:\nAND\nThe Boolean operator applied to the predicate is AND.\nOR\nThe Boolean operator applied to the predicate is OR.\nTIMER(data-area)\nreturns, if the named event is a timer event, the 16-character name of its associated timer.\nConditions\n83 END\nRESP2 values:\n2\nThere are no more resource definitions of this type.\n112 TOKENERR\nRESP2 values:\n3\nThe browse token is not valid.\nGETNEXT PROCESS\nBrowse all processes of a specified type within the CICS business transaction services system.\nGETNEXT PROCESS\nGETNEXT\nPROCESS(  data-area )\nBROWSETOKEN(  data-value )\nACTIVITYID(  data-area )\nConditions: END, ILLOGIC, IOERR, PROCESSERR, TOKENERR\nDescription\nGETNEXT PROCESS returns the name of the next process of a specified type within the CICS business\ntransaction services system.\nChapter 2. CICS command summary  239", "output": "INPUT\nInput\nSYSTEM\nSystem\nTIMER\nTimer.\nFIRESTATUS(cvda)\nindicates the state of the named event. CVDA values are:\nFIRED\nThe event has fired normally.\nNOTFIRED\nThe event has not fired.\nPREDICATE(cvda)\nindicates, if the named event is composite, the Boolean operator applied to its predicate. CVDA values\nare:\nAND\nThe Boolean operator applied to the predicate is AND.\nOR\nThe Boolean operator applied to the predicate is OR.\nTIMER(data-area)\nreturns, if the named event is a timer event, the 16-character name of its associated timer.\nConditions\n83 END\nRESP2 values:\n2\nThere are no more resource definitions of this type.\n112 TOKENERR\nRESP2 values:\n3\nThe browse token is not valid.\nGETNEXT PROCESS\nBrowse all processes of a specified type within the CICS business transaction services system.\nGETNEXT PROCESS\nGETNEXT\nPROCESS(  data-area )\nBROWSETOKEN(  data-value )\nACTIVITYID(  data-area )\nConditions: END, ILLOGIC, IOERR, PROCESSERR, TOKENERR\nDescription\nGETNEXT PROCESS returns the name of the next process of a specified type within the CICS business\ntransaction services system.\nChapter 2. CICS command summary  239"}
{"instruction": "What is If the sending item in COBOL?", "input": "", "output": "If the sending item is national decimal integer item, the sending data is converted to usage DISPLAY\nand treated as though it were moved to a temporary data item of category alphanumeric with the same\nnumber of character positions as the sending item"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Options\nACTIVITYID(data-value)\nspecifies the identifier (1–52 characters) of the activity which the ", "output": "Options\nACTIVITYID(data-value)\nspecifies the identifier (1–52 characters) of the activity which the data-container is associated with.\nIf both this and the process options are omitted, the current activity is assumed.\nCONTAINER(data-value)\nspecifies the name (1–16 characters) of the data-container being inquired upon.\nDATALENGTH(data-area)\nreturns the fullword length of the data contained in the named data-container.\nPROCESS(data-value)\nspecifies the name (1–36 characters) of the process which the data-container is associated with.\nIf both this and the ACTIVITYID option are omitted, the current activity is assumed.\nPROCESSTYPE(data-value)\nspecifies the process-type (1–8 characters) of the process named in the PROCESS option.\nSET(data-area)\nreturns a pointer to the contents of the data-container.\nConditions\n109 ACTIVITYERR\nRESP2 values:\n2\nThe activity indicated by the ACTIVITYID option could not be found.\n3\nBecause neither the ACTIVITYID nor the PROCESS options were specified, an inquiry on the\ncurrent activity was implied—but there is no current activity associated with the request.\n29\nThe repository file is unavailable.\n30\nAn input/output error has occurred on the repository file.\n110 CONTAINERERR\nRESP2 values:\n1\nThe container specified on the CONTAINER option could not be found.\n17 IOERR\nRESP2 values:\n30\nAn input/output error has occurred on the repository file.\n70 NOTAUTH\nRESP2 values:\n101\nThe user associated with the issuing task is not authorized to access this resource in the way\nrequested.\n108 PROCESSERR\nRESP2 values:\n2\nThe process-type specified on the PROCESSTYPE option could not be found.\n4\nThe process specified on the PROCESS option could not be found.\nChapter 2. CICS command summary  255"}
{"instruction": "Explain this COBOL concept", "input": "Chapter 65. LOG\nThe LOG function returns a numeric value that approximates the logarithm to the base e (natural log) of\nthe argument specified.\nThe function type is numeric.\nFormat\nFUNCTION LOG\n(\nargument-1\n)\nargument-1\nMust be class numeric. The value of argument-1 must be greater than zero.\nThe returned value is the approximation of the logarithm to the base e of argument-1.\n© Copyright IBM Corp. 1991, 2025\n595", "output": "Chapter 65. LOG\nThe LOG function returns a numeric value that approximates the logarithm to the base e (natural log) of\nthe argument specified.\nThe function type is numeric.\nFormat\nFUNCTION LOG\n(\nargument-1\n)\nargument-1\nMust be class numeric. The value of argument-1 must be greater than zero.\nThe returned value is the approximation of the logarithm to the base e of argument-1.\n© Copyright IBM Corp. 1991, 2025\n595"}
{"instruction": "Summarize this COBOL documentation section", "input": "Example: compiling and linking a COBOL class definition under z/OS UNIX\nThis example illustrates the commands that you use and the files that are produced when you compile\nand link a COBOL class definition, Manager.cbl, using z/OS UNIX shell commands.\nThe class file Manager.class and the DLL module libManager.so are the executable components of\nthe application, and are generated in the current working directory.\nRunning OO applications under z/OS UNIX\nIt is recommended that you run object-oriented COBOL applications as z/OS UNIX applications. You must\ndo so if an application begins with a Java program or the main factory method of a COBOL class.\nSpecify the directory that contains the DLLs for the COBOL classes in the LIBPATH environment variable.\nSpecify the directory paths for the Java class files that are associated with the COBOL classes in the\nCLASSPATH environment variable as follows:\n• For classes that are not part of a package, end the class path with the directory that contains the .class\nfiles.\n• For classes that are part of a package, end the class path with the directory that contains the \"root\"\npackage (the first package in the full package name).\n• For a .jar file that contains .class files, end the class path with the name of the .jar file.\nSeparate multiple path entries with colons.\nNote: If the CLASSPATH environment variable contains the filename wildcard (*), the wildcard cannot be\nexpanded in the case where the JVM is initialized by the COBOL runtime.\nRelated tasks   \n“Running OO applications that start with a main method” on page 308  \n“Running OO applications that start with a COBOL program” on page 308  \n“Running J2EE COBOL clients” on page 308  \nChapter 26, “Running COBOL programs under z/OS UNIX,” on page 551  \n“Setting and accessing environment variables” on page 552  \nChapter 40, “Writing object-oriented programs,” on page 705  \n“Structuring OO applications” on page 741\nChapter 17. Compiling, linking, and running OO applications  307", "output": "Example: compiling and linking a COBOL class definition under z/OS UNIX\nThis example illustrates the commands that you use and the files that are produced when you compile\nand link a COBOL class definition, Manager.cbl, using z/OS UNIX shell commands.\nThe class file Manager.class and the DLL module libManager.so are the executable components of\nthe application, and are generated in the current working directory.\nRunning OO applications under z/OS UNIX\nIt is recommended that you run object-oriented COBOL applications as z/OS UNIX applications. You must\ndo so if an application begins with a Java program or the main factory method of a COBOL class.\nSpecify the directory that contains the DLLs for the COBOL classes in the LIBPATH environment variable.\nSpecify the directory paths for the Java class files that are associated with the COBOL classes in the\nCLASSPATH environment variable as follows:\n• For classes that are not part of a package, end the class path with the directory that contains the .class\nfiles.\n• For classes that are part of a package, end the class path with the directory that contains the \"root\"\npackage (the first package in the full package name).\n• For a .jar file that contains .class files, end the class path with the name of the .jar file.\nSeparate multiple path entries with colons.\nNote: If the CLASSPATH environment variable contains the filename wildcard (*), the wildcard cannot be\nexpanded in the case where the JVM is initialized by the COBOL runtime.\nRelated tasks   \n“Running OO applications that start with a main method” on page 308  \n“Running OO applications that start with a COBOL program” on page 308  \n“Running J2EE COBOL clients” on page 308  \nChapter 26, “Running COBOL programs under z/OS UNIX,” on page 551  \n“Setting and accessing environment variables” on page 552  \nChapter 40, “Writing object-oriented programs,” on page 705  \n“Structuring OO applications” on page 741\nChapter 17. Compiling, linking, and running OO applications  307"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Numeric sequence\n209 ISCMMCONV\n210 LUCMODGRP\n211 LUCSESS\nCVDAs and numeric values in numeric sequenc", "output": "Numeric sequence\n209 ISCMMCONV\n210 LUCMODGRP\n211 LUCSESS\nCVDAs and numeric values in numeric sequence\nValue CVDA\n1 IGNORE\n1 NOTAPPLIC\n2 BDAM\n2 IMMEDIATE\n3 EVENTUAL\n3 VSAM\n4 REMOTE\n5 ESDS\n6 KSDS\n7 RRDS\n8 KEYED\n9 NOTKEYED\n10 BASE\n11 CRITICAL\n11 PATH\n12 FIXED\n13 VARIABLE\n14 UNDEFINED\n15 NOTSUPPORTED\n16 BLOCKED\n17 UNBLOCKED\n18 OPEN\n19 CLOSED\n20 OPENING\n21 CLOSING\n22 CLOSEREQUEST\n23 ENABLED\n24 DISABLED\n25 DISABLING\nChapter 4. CICS-value data areas used by all commands  739"}
{"instruction": "What is the DATA1 variable in COBOL?", "input": "", "output": "the DATA1 variable is area used as defined by the MCT user EMP definition.\n• If the MCT user EMP definition contains an MLTCNT option, the DATA1 variable is an area with the\naddress of a series of adjacent fullwords containing the values to be added to the user count fields\ndefined in the MCT user EMP definition.\n• If the MCT user EMP definition contains a MOVE option, the DATA1 variable is an area with the\naddress of the character string to be moved"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Also occurs (RESP2 not set) in any of the following situations:\n• An internal error occurred during ", "output": "Also occurs (RESP2 not set) in any of the following situations:\n• An internal error occurred during SPOOLOPEN processing that has forced the request to fail.\n96 OUTDESCRERR\noccurs in any of the following situations:\n• The macro OUTADD or OUTDEL (invoked as a result of the OUTDESCR specification) failed.\nRESP2 gives the reason code from the OUTADD or OUTDEL macro. See the z/OS MVS Programming:\nAssembler Services Guide for descriptions of codes.\n88 SPOLBUSY\nRESP2 values:\n4\nInterface already in use by another task.\n8\nInterface already in use by current task.\nAlso occurs in the following situation:\n• The JES/input single thread within the JES interface was not available.\n86 STRELERR\noccurs in the following situation:\n• A FREEMAIN has failed within the JES interface subtask (DFHPSPSS).\nRESP2 gives the FREEMAIN register 15 return code.\nSPOOLREAD\nThe SPOOLREAD command obtains the next record from the system spooler.\nSPOOLREAD\nSPOOLREAD\nTOKEN(  data-area )\nINTO( data-area )\nMAXFLENGTH(  data-value )\nTOFLENGTH(  data-area )\nNOHANDLE\nRESP\nRESP2\nConditions: ALLOCERR, ENDFILE, ILLOGIC, INVREQ, LENGERR, NOSPOOL, NOSTG, NOTFND, NOTOPEN,\nSPOLBUSY, SPOLERR, STRELERR\nOptions\nINTO(data-area)\nspecifies the data area for the variable-length data. It is a receiver field.\nMAXFLENGTH(data-value)\nspecifies, as a fullword binary variable, the maximum length of data transferred. This is set by the user\non input. The limit of length is 32 760 bytes. This is the maximum size of the CICS buffer used to read\na record.\nTOFLENGTH(data-area)\nspecifies, as a fullword binary variable, the length of the data that is transferred. This is set by CICS on\ninput. It is optional and, if it is omitted, you are not notified of the actual length of the data received.\nTOKEN(data-area)\nspecifies the 8-character CICS-allocated token used to identify a report.\n516  CICS TS for z/OS: API Reference"}
{"instruction": "Explain this COBOL concept", "input": "SECERROR\nThe child task failed to attach due to a security error. ABCODE is blank.\nNOSUSPEND\nSpecifies that the command will return immediately without waiting for any remaining child tasks to\ncomplete. If at least one of the unfetched children is completed, the command will return with a\nnormal response.\nTIMEOUT(data-value)\nSpecifies a fullword binary data-value which is the maximum time in milliseconds that the command\nwill wait for any remaining child tasks to complete before the command returns. The maximum value\nis 40800000 milliseconds. If TIMEOUT is not specified, or the specified value is zero, the command is\nnot timed out.\nConditions\n113 NOTFINISHED\nRESP2 values:\n52\nNOSUSPEND was specified, but there were no completed children to fetch when the command was\nrun.\n53\nNo children have completed within the interval specified by the TIMEOUT option.\n13 NOTFND\nRESP2 values:\n1\nNo unfetched children were found.\n16 INVREQ\nRESP2 values:\n52\nThe parent has no children.\n241\nTIMEOUT value is not valid.\nFETCH CHILD\nThe EXEC CICS FETCH CHILD command is used by a parent task to inquire on the status of a specific\nchild task, and returns the status of the specified child task.\nFETCH CHILD\nFETCH\nCHILD( data-value )\nCHANNEL(  data-area )\nCOMPSTATUS(  cvda)\nABCODE(  data-area )\nNOSUSPEND\nTIMEOUT(  data-value )\nConditions: INVREQ, NOTFINISHED\nThis command is threadsafe.\nDescription\nEXEC CICS FETCH CHILD is used by a parent task to inquire on the status of a specific child task, which\nis identified by the child token. FETCH CHILD will return when the child task is completed.\n182  CICS TS for z/OS: API Reference", "output": "SECERROR\nThe child task failed to attach due to a security error. ABCODE is blank.\nNOSUSPEND\nSpecifies that the command will return immediately without waiting for any remaining child tasks to\ncomplete. If at least one of the unfetched children is completed, the command will return with a\nnormal response.\nTIMEOUT(data-value)\nSpecifies a fullword binary data-value which is the maximum time in milliseconds that the command\nwill wait for any remaining child tasks to complete before the command returns. The maximum value\nis 40800000 milliseconds. If TIMEOUT is not specified, or the specified value is zero, the command is\nnot timed out.\nConditions\n113 NOTFINISHED\nRESP2 values:\n52\nNOSUSPEND was specified, but there were no completed children to fetch when the command was\nrun.\n53\nNo children have completed within the interval specified by the TIMEOUT option.\n13 NOTFND\nRESP2 values:\n1\nNo unfetched children were found.\n16 INVREQ\nRESP2 values:\n52\nThe parent has no children.\n241\nTIMEOUT value is not valid.\nFETCH CHILD\nThe EXEC CICS FETCH CHILD command is used by a parent task to inquire on the status of a specific\nchild task, and returns the status of the specified child task.\nFETCH CHILD\nFETCH\nCHILD( data-value )\nCHANNEL(  data-area )\nCOMPSTATUS(  cvda)\nABCODE(  data-area )\nNOSUSPEND\nTIMEOUT(  data-value )\nConditions: INVREQ, NOTFINISHED\nThis command is threadsafe.\nDescription\nEXEC CICS FETCH CHILD is used by a parent task to inquire on the status of a specific child task, which\nis identified by the child token. FETCH CHILD will return when the child task is completed.\n182  CICS TS for z/OS: API Reference"}
{"instruction": "What is or in COBOL?", "input": "", "output": "or is function-identifier, the subscript, reference-modifier, or function is evaluated each time the\ncondition is tested"}
{"instruction": "What are the compiler rules or directives for this?", "input": "is in effect, at least one symbol N. A DBCS data item has", "output": "is in effect, at least one symbol N. A DBCS data item has"}
{"instruction": "What is if this in COBOL?", "input": "", "output": "if this is first time it is to be run, or if it has been reset by a RESET ACTIVITY command—\nCICS sends it the DFHINITIAL system event"}
{"instruction": "Summarize this COBOL documentation section", "input": "Conditions\n16 INVREQ\nRESP2 values:\n1\nThe command is issued in a non-CICS Web support application.\n2\nA WEB SEND command has not been issued..\n13 NOTFND\nRESP2 values:\n1\nDocument is not available as the last WEB SEND specified DOCSTATUS(DOCDELETE) or the last\nWEB SEND was not a SEND for a document with ACTION(EVENTUAL).\nWEB SEND (Server)\nSend an HTTP response, or a non-HTTP message.\nWEB SEND\nWEB\nSEND\nDOCTOKEN(  data-value )\nNODOCDELETE\nDOCDELETE\nDOCSTATUS(  cvda)\nFROM( data-area )\nFROMLENGTH(  data-value )\nCHUNKNO\nCHUNKYES\nCHUNKEND\nCHUNKING(  cvda)\nHOSTCODEPAGE(  data-value )\nCONTAINER(  data-value )\nCHANNEL(  data-value )\nMEDIATYPE(  data-value )\nSRVCONVERT\nNOSRVCONVERT\nSERVERCONV(  cvda)\nCHARACTERSET(  data-value )\nSTATUSCODE(  data-value )\nSTATUSTEXT(  data-area )\nSTATUSLEN(  data-value )\nLENGTH( data-value )\nIMMEDIATE\nEVENTUAL\nACTION(  cvda)\nNOCLOSE\nCLOSE\nCLOSESTATUS(  cvda)\nConditions: CHANNELERR, CONTAINERERR, IOERR, INVREQ, LENGERR, NOTFND\nThis command is threadsafe.\n644  CICS TS for z/OS: API Reference", "output": "Conditions\n16 INVREQ\nRESP2 values:\n1\nThe command is issued in a non-CICS Web support application.\n2\nA WEB SEND command has not been issued..\n13 NOTFND\nRESP2 values:\n1\nDocument is not available as the last WEB SEND specified DOCSTATUS(DOCDELETE) or the last\nWEB SEND was not a SEND for a document with ACTION(EVENTUAL).\nWEB SEND (Server)\nSend an HTTP response, or a non-HTTP message.\nWEB SEND\nWEB\nSEND\nDOCTOKEN(  data-value )\nNODOCDELETE\nDOCDELETE\nDOCSTATUS(  cvda)\nFROM( data-area )\nFROMLENGTH(  data-value )\nCHUNKNO\nCHUNKYES\nCHUNKEND\nCHUNKING(  cvda)\nHOSTCODEPAGE(  data-value )\nCONTAINER(  data-value )\nCHANNEL(  data-value )\nMEDIATYPE(  data-value )\nSRVCONVERT\nNOSRVCONVERT\nSERVERCONV(  cvda)\nCHARACTERSET(  data-value )\nSTATUSCODE(  data-value )\nSTATUSTEXT(  data-area )\nSTATUSLEN(  data-value )\nLENGTH( data-value )\nIMMEDIATE\nEVENTUAL\nACTION(  cvda)\nNOCLOSE\nCLOSE\nCLOSESTATUS(  cvda)\nConditions: CHANNELERR, CONTAINERERR, IOERR, INVREQ, LENGERR, NOTFND\nThis command is threadsafe.\n644  CICS TS for z/OS: API Reference"}
{"instruction": "Summarize this COBOL documentation section", "input": "CVDA\nValue\nNODE\n1155\nNODEBUG\n1083\nNODEJSAPP\n1215\nNODISCREQ\n445\nNODOCDELETE\n296\nNODUALCASE\n404\nNOEMPTYREQ\n32\nNOEVENT\n335\nNOEXCEPT\n333\nNOEXCTL\n49\nNOEXIT\n917\nNOEXITTRACE\n363\nNOEXTENDEDDS\n406\nNOFMH\n503\nNOFMHPARM\n386\nNOFORCE\n1054\nNOFORMATEDF\n607\nNOFORMFEED\n408\nNOHFORM\n410\nNOHILIGHT\n414\nNOHOLD\n164\nNOIDNTY\n329\nNOINCONVERT\n745\nNOISOLATE\n657\nNOJVM\n1081\nNOKATAKANA\n416\nNOKEEP\n787\nNOLIGHTPEN\n418\nNOLOAD\n835\nNOLOG\n55\nNOLOGREPLICA\n1199\nNOLOSTLOCKS\n710\nNOMDT\n507\nNOMSGJRNL\n531\nNOMSRCONTROL\n420\nChapter 4. CICS-value data areas used by all commands  721", "output": "CVDA\nValue\nNODE\n1155\nNODEBUG\n1083\nNODEJSAPP\n1215\nNODISCREQ\n445\nNODOCDELETE\n296\nNODUALCASE\n404\nNOEMPTYREQ\n32\nNOEVENT\n335\nNOEXCEPT\n333\nNOEXCTL\n49\nNOEXIT\n917\nNOEXITTRACE\n363\nNOEXTENDEDDS\n406\nNOFMH\n503\nNOFMHPARM\n386\nNOFORCE\n1054\nNOFORMATEDF\n607\nNOFORMFEED\n408\nNOHFORM\n410\nNOHILIGHT\n414\nNOHOLD\n164\nNOIDNTY\n329\nNOINCONVERT\n745\nNOISOLATE\n657\nNOJVM\n1081\nNOKATAKANA\n416\nNOKEEP\n787\nNOLIGHTPEN\n418\nNOLOAD\n835\nNOLOG\n55\nNOLOGREPLICA\n1199\nNOLOSTLOCKS\n710\nNOMDT\n507\nNOMSGJRNL\n531\nNOMSRCONTROL\n420\nChapter 4. CICS-value data areas used by all commands  721"}
{"instruction": "Summarize this COBOL documentation section", "input": "Table 86. Reserved words (continued)\nWord\nReserved\nStandard only\nPotential\nreserved words\nCOMMA\nX\n \n \nCOMMON\nX\n \n \nCOMMUNICATION\n \nX\n \nCOMP\nX\n \n \nCOMP-1\nX\n \n \nCOMP-2\nX\n \n \nCOMP-3\nX\n \n \nCOMP-4\nX\n \n \nCOMP-5\nX\n \n \nCOMPUTATIONAL\nX\n \n \nCOMPUTATIONAL-1\nX\n \n \nCOMPUTATIONAL-2\nX\n \n \nCOMPUTATIONAL-3\nX\n \n \nCOMPUTATIONAL-4\nX\n \n \nCOMPUTATIONAL-5\nX\n \n \nCOMPUTE\nX\n \n \nCONDITION\n \n \nX\nCONFIGURATION\nX\n \n \nCONSTANT\n \n \nX\nCONTAINS\nX\n \n \nCONTENT\nX\n \n \nCONTINUE\nX\n \n \nCONTROL\n \nX\n \nCONTROLS\n \nX\n \nCONVERTING\nX\n \n \nCOPY\nX\n \n \nCORR\nX\n \n \nCORRESPONDING\nX\n \n \nCOUNT\nX\n \n \nCRT\n \n \nX\nCURRENCY\nX\n \n \nCURSOR\n \n \nX\nDATA\nX\n \n \nDATA-POINTER\n \n \nX\n774  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "Table 86. Reserved words (continued)\nWord\nReserved\nStandard only\nPotential\nreserved words\nCOMMA\nX\n \n \nCOMMON\nX\n \n \nCOMMUNICATION\n \nX\n \nCOMP\nX\n \n \nCOMP-1\nX\n \n \nCOMP-2\nX\n \n \nCOMP-3\nX\n \n \nCOMP-4\nX\n \n \nCOMP-5\nX\n \n \nCOMPUTATIONAL\nX\n \n \nCOMPUTATIONAL-1\nX\n \n \nCOMPUTATIONAL-2\nX\n \n \nCOMPUTATIONAL-3\nX\n \n \nCOMPUTATIONAL-4\nX\n \n \nCOMPUTATIONAL-5\nX\n \n \nCOMPUTE\nX\n \n \nCONDITION\n \n \nX\nCONFIGURATION\nX\n \n \nCONSTANT\n \n \nX\nCONTAINS\nX\n \n \nCONTENT\nX\n \n \nCONTINUE\nX\n \n \nCONTROL\n \nX\n \nCONTROLS\n \nX\n \nCONVERTING\nX\n \n \nCOPY\nX\n \n \nCORR\nX\n \n \nCORRESPONDING\nX\n \n \nCOUNT\nX\n \n \nCRT\n \n \nX\nCURRENCY\nX\n \n \nCURSOR\n \n \nX\nDATA\nX\n \n \nDATA-POINTER\n \n \nX\n774  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "Summarize this COBOL documentation section", "input": "• Level-01 group items if none of their subordinate items are referenced\n• Unreferenced special registers\nNote: The STGOPT option is ignored for data items that have the VOLATILE clause. For details, see\nVOLATILE clause in the Enterprise COBOL for z/OS Language Reference.\nThe compiler will not generate code to initialize discarded data items to the values in their VALUE clauses.\nIn addition, with STGOPT, data items in the LOCAL-STORAGE SECTION can be reordered in memory to\noptimize performance.\nWhen NOSTGOPT is in effect, the storage for all data items, including unreferenced data items, is allocated\nby the compiler, data items are never reordered to improve performance, and all data items defined with a\nVALUE clause are guaranteed to be initialized, even if they are unreferenced.\nYou can also use the RULES(UNREF | NOUNREFALL | NOUNREFSOURCE) option to control whether to\nissue warning messages for unreferenced data items. For details, see “RULES” on page 419.\nSUPPRESS\nUse the NOSUPPRESS option to ignore the SUPPRESS phrase of all COPY statements in a program so that\ncopybook information can appear in the listing. The copybook information can be used by debuggers,\ntools, and so on, without users needing to modify their source code.\nSUPPRESS option syntax\nSUPPRESS\nNOSUPPRESS\nDefault is: SUPPRESS\nAbbreviations are: SUPP | NOSUPP\nNOSUPPRESS\nIgnores the SUPPRESS phrase of COPY statements.\nSUPPRESS\nEnables the SUPPRESS phrase of COPY statements.\nTERMINAL\nUse TERMINAL to send progress and diagnostic messages to the SYSTERM ddname.\nTERMINAL option syntax\nNOTERMINAL\nTERMINAL\nDefault is: NOTERMINAL\nAbbreviations are: TERM | NOTERM\nUse NOTERMINAL if you do not want this additional output.\nChapter 20. COBOL compiler and runtime options  429", "output": "• Level-01 group items if none of their subordinate items are referenced\n• Unreferenced special registers\nNote: The STGOPT option is ignored for data items that have the VOLATILE clause. For details, see\nVOLATILE clause in the Enterprise COBOL for z/OS Language Reference.\nThe compiler will not generate code to initialize discarded data items to the values in their VALUE clauses.\nIn addition, with STGOPT, data items in the LOCAL-STORAGE SECTION can be reordered in memory to\noptimize performance.\nWhen NOSTGOPT is in effect, the storage for all data items, including unreferenced data items, is allocated\nby the compiler, data items are never reordered to improve performance, and all data items defined with a\nVALUE clause are guaranteed to be initialized, even if they are unreferenced.\nYou can also use the RULES(UNREF | NOUNREFALL | NOUNREFSOURCE) option to control whether to\nissue warning messages for unreferenced data items. For details, see “RULES” on page 419.\nSUPPRESS\nUse the NOSUPPRESS option to ignore the SUPPRESS phrase of all COPY statements in a program so that\ncopybook information can appear in the listing. The copybook information can be used by debuggers,\ntools, and so on, without users needing to modify their source code.\nSUPPRESS option syntax\nSUPPRESS\nNOSUPPRESS\nDefault is: SUPPRESS\nAbbreviations are: SUPP | NOSUPP\nNOSUPPRESS\nIgnores the SUPPRESS phrase of COPY statements.\nSUPPRESS\nEnables the SUPPRESS phrase of COPY statements.\nTERMINAL\nUse TERMINAL to send progress and diagnostic messages to the SYSTERM ddname.\nTERMINAL option syntax\nNOTERMINAL\nTERMINAL\nDefault is: NOTERMINAL\nAbbreviations are: TERM | NOTERM\nUse NOTERMINAL if you do not want this additional output.\nChapter 20. COBOL compiler and runtime options  429"}
{"instruction": "Summarize this COBOL documentation section", "input": "The mechanism used to determine which program to call is as follows:\n• If one of two programs that have the same name as that specified in the CALL statement is directly\ncontained within the program that includes the CALL statement, that program is called.\n• If one of two programs that have the same name as that specified in the CALL statement possesses the\nCOMMON attribute and is directly contained within another program that directly or indirectly contains\nthe program that includes the CALL statement, that common program is called unless the calling\nprogram is contained within that common program.\n• Otherwise, the separately compiled program is called.\nThe following rules apply to referencing a program-name of a program that is contained within another\nprogram. For this discussion, Program-A contains Program-B and Program-C; Program-C contains\nProgram-D and Program-F; and Program-D contains Program-E.\nIf Program-D does not possess the COMMON attribute, then Program-D can be referenced only by the\nprogram that directly contains Program-D, that is, Program-C.\nIf Program-D does possess the COMMON attribute, then Program-D can be referenced by Program-C\n(because Program-C contains Program-D) and by any programs contained in Program-C except for\nprograms contained in Program-D. In other words, if Program-D possesses the COMMON attribute,\nProgram-D can be referenced in Program-C and Program-F but not by statements in Program-E, Program-\nA, or Program-B.\nChapter 10. COBOL program structure  89", "output": "The mechanism used to determine which program to call is as follows:\n• If one of two programs that have the same name as that specified in the CALL statement is directly\ncontained within the program that includes the CALL statement, that program is called.\n• If one of two programs that have the same name as that specified in the CALL statement possesses the\nCOMMON attribute and is directly contained within another program that directly or indirectly contains\nthe program that includes the CALL statement, that common program is called unless the calling\nprogram is contained within that common program.\n• Otherwise, the separately compiled program is called.\nThe following rules apply to referencing a program-name of a program that is contained within another\nprogram. For this discussion, Program-A contains Program-B and Program-C; Program-C contains\nProgram-D and Program-F; and Program-D contains Program-E.\nIf Program-D does not possess the COMMON attribute, then Program-D can be referenced only by the\nprogram that directly contains Program-D, that is, Program-C.\nIf Program-D does possess the COMMON attribute, then Program-D can be referenced by Program-C\n(because Program-C contains Program-D) and by any programs contained in Program-C except for\nprograms contained in Program-D. In other words, if Program-D possesses the COMMON attribute,\nProgram-D can be referenced in Program-C and Program-F but not by statements in Program-E, Program-\nA, or Program-B.\nChapter 10. COBOL program structure  89"}
{"instruction": "Summarize this COBOL documentation section", "input": "Table 137. SYSADATA token record (continued)\nField\nSize\nDescription\n \n \n0721\nOFF\n0722\nOPTIONAL\n0723\nORGANIZATION\n0724\nPOSITION\n0725\nPROGRAM\n0726\nRANDOM\n0727\nRELATIVE\n0728\nRERUN\n0729\nRESERVE\n0730\nSAME\n0731\nSEGMENT-LIMIT\n0732\nSELECT\n0733\nSEQUENCE\n0734\nSEQUENTIAL\n0736\nSORT-MERGE\n0737\nSTANDARD-1\n0738\nTAPE\n0739\nWORDS\n0740\nPROCESSING\n942  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "Table 137. SYSADATA token record (continued)\nField\nSize\nDescription\n \n \n0721\nOFF\n0722\nOPTIONAL\n0723\nORGANIZATION\n0724\nPOSITION\n0725\nPROGRAM\n0726\nRANDOM\n0727\nRELATIVE\n0728\nRERUN\n0729\nRESERVE\n0730\nSAME\n0731\nSEGMENT-LIMIT\n0732\nSELECT\n0733\nSEQUENCE\n0734\nSEQUENTIAL\n0736\nSORT-MERGE\n0737\nSTANDARD-1\n0738\nTAPE\n0739\nWORDS\n0740\nPROCESSING\n942  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Value CVDA\n197 ALTERNATE\n198 DEFAULT\n199 PRINCIPAL\n200 OFF\n201 ON\n202 RESSECNO\n203 RESSECINT\n204 RES", "output": "Value CVDA\n197 ALTERNATE\n198 DEFAULT\n199 PRINCIPAL\n200 OFF\n201 ON\n202 RESSECNO\n203 RESSECINT\n204 RESSECEXT\n204 RESSECYES\n205 CMDSECNO\n207 CMDSECEXT\n207 CMDSECYES\n208 COMMIT\n209 READBACK\n210 EMPTY\n211 NOTEMPTY\n212 FULL\n213 TERMINAL\n214 NOTERMINAL\n215 PHYSICAL\n216 LOGICAL\n221 EXTRA\n222 INTRA\n223 NOCTL\n224 ASACTL\n225 SWITCHING\n226 INPUT\n227 OUTPUT\n228 DISPATCHABLE\n229 RUNNING\n231 SUSPENDED\n232 KILL\n233 TASK\n234 TERM\n235 DEST\n744  CICS TS for z/OS: API Reference"}
{"instruction": "Explain this COBOL concept", "input": "ISSUE REPLACE\nISSUE REPLACE\nDESTID( data-value )\nDESTIDLENG(  data-value )\nVOLUME(  data-value )\nVOLUMELENG(  data-value )\nFROM( data-area )\nLENGTH( data-value )\nNUMREC( data-value )\nRIDFLD( data-area )\nKEYLENGTH(  data-value )\nKEYNUMBER(  data-value )\nRRN\nDEFRESP\nNOWAIT\nConditions: FUNCERR, INVREQ, SELNERR, UNEXPIN\n \nDescription\nISSUE REPLACE updates (replaces) a record in either a relative (addressed direct) or an indexed (keyed\ndirect) data set in an outboard controller.\nOptions\nDEFRESP\nspecifies that all terminal control commands issued as a result of the ISSUE REPLACE command\nrequest a definite response from the outboard batch program, irrespective of the specification of\nmessage integrity for the CICS task (by the system programmer).\nDESTID(data-value)\nspecifies the name (1–8 characters) of the data set in the outboard destination.\nDESTIDLENG(data-value)\nspecifies the length (halfword binary value) of the name specified in the DESTID option.\nFROM(data-area)\nspecifies the data that is to be written to the data set.\nKEYLENGTH(data-value)\nspecifies the length (halfword binary value) of the key specified in the RIDFLD option.\nKEYNUMBER(data-value)\nspecifies the number, as a halfword binary value, of the index to be used to locate the record. There\ncan be eight indexes (1 through 8). The default is 1. This option applies only to DPCX/DXAM and is\nmutually exclusive with RRN.\nLENGTH(data-value)\nspecifies the length (halfword binary value) of the data to be written.\nNOWAIT\nspecifies that the CICS task continues processing without waiting for the ISSUE REPLACE command\nto complete. If this option is not specified, the task activity is suspended until the command is\ncompleted.\n294  CICS TS for z/OS: API Reference", "output": "ISSUE REPLACE\nISSUE REPLACE\nDESTID( data-value )\nDESTIDLENG(  data-value )\nVOLUME(  data-value )\nVOLUMELENG(  data-value )\nFROM( data-area )\nLENGTH( data-value )\nNUMREC( data-value )\nRIDFLD( data-area )\nKEYLENGTH(  data-value )\nKEYNUMBER(  data-value )\nRRN\nDEFRESP\nNOWAIT\nConditions: FUNCERR, INVREQ, SELNERR, UNEXPIN\n \nDescription\nISSUE REPLACE updates (replaces) a record in either a relative (addressed direct) or an indexed (keyed\ndirect) data set in an outboard controller.\nOptions\nDEFRESP\nspecifies that all terminal control commands issued as a result of the ISSUE REPLACE command\nrequest a definite response from the outboard batch program, irrespective of the specification of\nmessage integrity for the CICS task (by the system programmer).\nDESTID(data-value)\nspecifies the name (1–8 characters) of the data set in the outboard destination.\nDESTIDLENG(data-value)\nspecifies the length (halfword binary value) of the name specified in the DESTID option.\nFROM(data-area)\nspecifies the data that is to be written to the data set.\nKEYLENGTH(data-value)\nspecifies the length (halfword binary value) of the key specified in the RIDFLD option.\nKEYNUMBER(data-value)\nspecifies the number, as a halfword binary value, of the index to be used to locate the record. There\ncan be eight indexes (1 through 8). The default is 1. This option applies only to DPCX/DXAM and is\nmutually exclusive with RRN.\nLENGTH(data-value)\nspecifies the length (halfword binary value) of the data to be written.\nNOWAIT\nspecifies that the CICS task continues processing without waiting for the ISSUE REPLACE command\nto complete. If this option is not specified, the task activity is suspended until the command is\ncompleted.\n294  CICS TS for z/OS: API Reference"}
{"instruction": "What is An RTIMOUT value of zero in COBOL?", "input": "", "output": "An RTIMOUT value of zero is that the application is\nprepared to wait indefinitely"}
{"instruction": "Summarize this COBOL documentation section", "input": "Chapter 52. FACTORIAL\nThe FACTORIAL function returns an integer that is the factorial of the argument specified.\nThe function type is integer.\nFormat\nFUNCTION FACTORIAL\n(\nargument-1\n)\nargument-1\nIf the ARITH(COMPAT) compiler option is in effect, argument-1 must be an integer greater than\nor equal to zero and less than or equal to 28. If the ARITH(EXTEND) compiler option is in effect,\nargument-1 must be an integer greater than or equal to zero and less than or equal to 29.\nIf the value of argument-1 is zero, the value 1 is returned; otherwise, the factorial of argument-1 is\nreturned.\n© Copyright IBM Corp. 1991, 2025\n569", "output": "Chapter 52. FACTORIAL\nThe FACTORIAL function returns an integer that is the factorial of the argument specified.\nThe function type is integer.\nFormat\nFUNCTION FACTORIAL\n(\nargument-1\n)\nargument-1\nIf the ARITH(COMPAT) compiler option is in effect, argument-1 must be an integer greater than\nor equal to zero and less than or equal to 28. If the ARITH(EXTEND) compiler option is in effect,\nargument-1 must be an integer greater than or equal to zero and less than or equal to 29.\nIf the value of argument-1 is zero, the value 1 is returned; otherwise, the factorial of argument-1 is\nreturned.\n© Copyright IBM Corp. 1991, 2025\n569"}
{"instruction": "Summarize this COBOL documentation section", "input": "Language element or concept\nSequence string\nENVIRONMENT DIVISION (optional)\nIS0200\nError handling, termination of program\nIA4620, IA5080, IA7800-7980\nEVALUATE statement\nIA6270-6590\nEVALUATE . . . ALSO\nIS2400\nEXIT PROGRAM not only statement in paragraph\nIS2000\nExponentiation\nIS4500\nEXTERNAL clause\nIS1200\nFILE-CONTROL entry for sequential file\nIA1190-1300\nFILE-CONTROL entry for VSAM indexed file\nIA1070-1180\nFILE SECTION (optional)\nIS0200\nFILE STATUS code check\nIA4600-4630, IA4760-4790\nFILLER (optional)\nIS0400\nFlags, level-88, definition\nIA1730-1800, IA2440-2480, IA2710\nFlags, level-88, testing\nIA4430, IA5200-5250\nFLOATING POINT\nIS4400\nGLOBAL statement\nIS0300\nINITIAL statement for nested programs\nIS2300\nINITIALIZE\nIS2500\nInitializing a table in the DATA DIVISION\nIA2920-4260\nInline PERFORM statement\nIA4410-4520\nI-O-CONTROL paragraphs (optional)\nIS0200\nINPUT-OUTPUT SECTION (optional)\nIS0200\nIntrinsic functions:\n1. CURRENT-DATE\n2. MAX\n3. MEAN\n4. MEDIAN\n5. MIN\n6. STANDARD-DEVIATION\n7. UPPER-CASE\n8. VARIANCE\n9. WHEN-COMPILED\n \n1. IA9005\n2. IA9235\n3. IA9215\n4. IA9220\n5. IA9240\n6. IA9230\n7. IA9015\n8. IA9225\n9. IA9000\nIS (optional in all clauses)\nIS0700\nLABEL RECORDS (optional)\nIS1150\nLINKAGE SECTION\nIS4900\nMixing of indexes and subscripts\nIS3500\nAppendix H. Using sample programs  989", "output": "Language element or concept\nSequence string\nENVIRONMENT DIVISION (optional)\nIS0200\nError handling, termination of program\nIA4620, IA5080, IA7800-7980\nEVALUATE statement\nIA6270-6590\nEVALUATE . . . ALSO\nIS2400\nEXIT PROGRAM not only statement in paragraph\nIS2000\nExponentiation\nIS4500\nEXTERNAL clause\nIS1200\nFILE-CONTROL entry for sequential file\nIA1190-1300\nFILE-CONTROL entry for VSAM indexed file\nIA1070-1180\nFILE SECTION (optional)\nIS0200\nFILE STATUS code check\nIA4600-4630, IA4760-4790\nFILLER (optional)\nIS0400\nFlags, level-88, definition\nIA1730-1800, IA2440-2480, IA2710\nFlags, level-88, testing\nIA4430, IA5200-5250\nFLOATING POINT\nIS4400\nGLOBAL statement\nIS0300\nINITIAL statement for nested programs\nIS2300\nINITIALIZE\nIS2500\nInitializing a table in the DATA DIVISION\nIA2920-4260\nInline PERFORM statement\nIA4410-4520\nI-O-CONTROL paragraphs (optional)\nIS0200\nINPUT-OUTPUT SECTION (optional)\nIS0200\nIntrinsic functions:\n1. CURRENT-DATE\n2. MAX\n3. MEAN\n4. MEDIAN\n5. MIN\n6. STANDARD-DEVIATION\n7. UPPER-CASE\n8. VARIANCE\n9. WHEN-COMPILED\n \n1. IA9005\n2. IA9235\n3. IA9215\n4. IA9220\n5. IA9240\n6. IA9230\n7. IA9015\n8. IA9225\n9. IA9000\nIS (optional in all clauses)\nIS0700\nLABEL RECORDS (optional)\nIS1150\nLINKAGE SECTION\nIS4900\nMixing of indexes and subscripts\nIS3500\nAppendix H. Using sample programs  989"}
{"instruction": "Explain this COBOL concept", "input": "14\nThe code page combination for client and server is invalid.\n17\nInvalid forms data was found in the input message.\n22 LENGERR\nRESP2 values are:\n1\nThe length in NAMELENGTH or VALUELENGTH is less than or equal to zero.\n4\nThe form field name has been truncated during a read operation because the receiving buffer is\ntoo small.\n5\nThe form field value has been truncated during a read operation because the receiving buffer is\ntoo small.\n153\nThe form type is unknown.\n154\nA boundary string was expected in the forms data, but was not found.\n13 NOTFND\nRESP2 values are:\n1\nThe form field with the given name cannot be found.\nWEB READ HTTPHEADER\nExtract HTTP header information.\nWEB READ HTTPHEADER\nWEB\nREAD\nHTTPHEADER(  data-area )\nNAMELENGTH(  data-value )\nSESSTOKEN(  data-area )\nVALUE(  data-area )\nVALUELENGTH(  data-area )\nConditions: INVREQ, LENGERR, NOTFND, NOTOPEN\nThis command is threadsafe.\nDescription\nWEB READ HTTPHEADER enables an application to extract HTTP header information from a message.\nWhen CICS is an HTTP server, the message is a request from a Web client. When CICS is an HTTP client,\nthe message is a response from a server, and the SESSTOKEN option is specified.\nFor CICS as an HTTP server, you can use the WEB READ HTTPHEADER command either before, or after,\nyou use the WEB RECEIVE command to receive the body of the message. For CICS as an HTTP client, you\nmust first receive the message using the WEB RECEIVE command, and then you can read the headers\nusing the WEB READ HTTPHEADER command.\nHTTP header reference for CICS web support lists HTTP/1.1 headers that you are likely to receive, and\ngives guidance for the actions that you might take in response to them.\nThe HTTP header browsing commands (WEB STARTBROWSE HTTPHEADER, WEB READNEXT\nHTTPHEADER, WEB ENDBROWSE HTTPHEADER) can be used to browse through all the HTTP header\ninformation for a message.\nChapter 2. CICS command summary  623", "output": "14\nThe code page combination for client and server is invalid.\n17\nInvalid forms data was found in the input message.\n22 LENGERR\nRESP2 values are:\n1\nThe length in NAMELENGTH or VALUELENGTH is less than or equal to zero.\n4\nThe form field name has been truncated during a read operation because the receiving buffer is\ntoo small.\n5\nThe form field value has been truncated during a read operation because the receiving buffer is\ntoo small.\n153\nThe form type is unknown.\n154\nA boundary string was expected in the forms data, but was not found.\n13 NOTFND\nRESP2 values are:\n1\nThe form field with the given name cannot be found.\nWEB READ HTTPHEADER\nExtract HTTP header information.\nWEB READ HTTPHEADER\nWEB\nREAD\nHTTPHEADER(  data-area )\nNAMELENGTH(  data-value )\nSESSTOKEN(  data-area )\nVALUE(  data-area )\nVALUELENGTH(  data-area )\nConditions: INVREQ, LENGERR, NOTFND, NOTOPEN\nThis command is threadsafe.\nDescription\nWEB READ HTTPHEADER enables an application to extract HTTP header information from a message.\nWhen CICS is an HTTP server, the message is a request from a Web client. When CICS is an HTTP client,\nthe message is a response from a server, and the SESSTOKEN option is specified.\nFor CICS as an HTTP server, you can use the WEB READ HTTPHEADER command either before, or after,\nyou use the WEB RECEIVE command to receive the body of the message. For CICS as an HTTP client, you\nmust first receive the message using the WEB RECEIVE command, and then you can read the headers\nusing the WEB READ HTTPHEADER command.\nHTTP header reference for CICS web support lists HTTP/1.1 headers that you are likely to receive, and\ngives guidance for the actions that you might take in response to them.\nThe HTTP header browsing commands (WEB STARTBROWSE HTTPHEADER, WEB READNEXT\nHTTPHEADER, WEB ENDBROWSE HTTPHEADER) can be used to browse through all the HTTP header\ninformation for a message.\nChapter 2. CICS command summary  623"}
{"instruction": "Explain this COBOL concept", "input": "SPOOLWRITE\nWrite data to a spool report.\nSPOOLWRITE\nSPOOLWRITE\nTOKEN(  data-area )\nFROM( data-area )\nFLENGTH(  data-value )\nLINE\nPAGE\nNOHANDLE\nRESP\nRESP2\nConditions: ALLOCERR, INVREQ, LENGERR, NOSPOOL, NOSTG, NOTAUTH, NOTOPEN, SPOLBUSY,\nSPOLERR, STRELERR\nDescription\nThe SPOOLWRITE command writes data to a spool report.\nOptions\nFLENGTH(data-value)\nspecifies the fullword binary variable that is to be set to the length of the data that is transferred. This\nis set by the user on output. It is optional and, if it is omitted, CICS uses the length of the data area.\nFROM(data-area)\nspecifies the data area from which to take the variable length data. The data itself is not altered in any\nway by CICS. FROM is a sender field.\nLINE|PAGE\nspecifies the format of the data to be sent. The default action is LINE.\nThe PAGE option must be used to correctly format information for the advanced function printer (AFP)\npage printing devices. If a customer is creating MIXED mode type data, that is LINE records and X'5A'\n(AFPDS or MODCA) pagemode records, the LINE or PAGE operand must match the type record being\nwritten to spool.\nTOKEN(data-area)\nspecifies the 8-character CICS-allocated token used to identify a report. It is a receiver on\nSPOOLOPEN and a sender on all other commands.\nRestriction: You must specify the RESP or NOHANDLE option on the EXEC CICS SPOOLWRITE command.\nConditions\nNote: There are no default actions.\n85 ALLOCERR\noccurs in any of the following situations:\n• Dynamic allocation has rejected a request to allocate an input data set.\nRESP2 gives the dynamic allocation response code that denotes this error. The first two characters\nare the information reason code (S99INFO), and the second two are the error reason code\n(S99ERROR), as defined in the z/OS MVS Programming: Authorized Assembler Services Guide.\n16 INVREQ\nRESP2 values:\nChapter 2. CICS command summary  519", "output": "SPOOLWRITE\nWrite data to a spool report.\nSPOOLWRITE\nSPOOLWRITE\nTOKEN(  data-area )\nFROM( data-area )\nFLENGTH(  data-value )\nLINE\nPAGE\nNOHANDLE\nRESP\nRESP2\nConditions: ALLOCERR, INVREQ, LENGERR, NOSPOOL, NOSTG, NOTAUTH, NOTOPEN, SPOLBUSY,\nSPOLERR, STRELERR\nDescription\nThe SPOOLWRITE command writes data to a spool report.\nOptions\nFLENGTH(data-value)\nspecifies the fullword binary variable that is to be set to the length of the data that is transferred. This\nis set by the user on output. It is optional and, if it is omitted, CICS uses the length of the data area.\nFROM(data-area)\nspecifies the data area from which to take the variable length data. The data itself is not altered in any\nway by CICS. FROM is a sender field.\nLINE|PAGE\nspecifies the format of the data to be sent. The default action is LINE.\nThe PAGE option must be used to correctly format information for the advanced function printer (AFP)\npage printing devices. If a customer is creating MIXED mode type data, that is LINE records and X'5A'\n(AFPDS or MODCA) pagemode records, the LINE or PAGE operand must match the type record being\nwritten to spool.\nTOKEN(data-area)\nspecifies the 8-character CICS-allocated token used to identify a report. It is a receiver on\nSPOOLOPEN and a sender on all other commands.\nRestriction: You must specify the RESP or NOHANDLE option on the EXEC CICS SPOOLWRITE command.\nConditions\nNote: There are no default actions.\n85 ALLOCERR\noccurs in any of the following situations:\n• Dynamic allocation has rejected a request to allocate an input data set.\nRESP2 gives the dynamic allocation response code that denotes this error. The first two characters\nare the information reason code (S99INFO), and the second two are the error reason code\n(S99ERROR), as defined in the z/OS MVS Programming: Authorized Assembler Services Guide.\n16 INVREQ\nRESP2 values:\nChapter 2. CICS command summary  519"}
{"instruction": "What are the compiler rules or directives for this?", "input": "is in effect, that can be used to save index-name values for future", "output": "is in effect, that can be used to save index-name values for future"}
{"instruction": "Explain this COBOL concept", "input": "SEGMENT-LIMIT IS\nThe SEGMENT-LIMIT clause is syntax checked but has no effect on the execution of the program.\npriority-number\nAn integer ranging from 1 through 49. All sections with priority-numbers 0 through 49 are fixed\npermanent segments. See “Procedures” on page 271 for a description of priority-numbers and\nsegmentation support.\nSegmentation is not supported for programs compiled with the THREAD option.\nAll of the OBJECT-COMPUTER paragraph is syntax checked, but only the PROGRAM COLLATING\nSEQUENCE clause has an effect on the execution of the program.\nThe OBJECT-COMPUTER paragraph cannot be specified in a function prototype definition.\nSPECIAL-NAMES paragraph\nThe SPECIAL-NAMES paragraph is the name of an ENVIRONMENT DIVISION paragraph in which\nenvironment-names are related to user-specified mnemonic-names.\nThe SPECIAL-NAMES paragraph:\n• Relates IBM-specified environment-names to user-defined mnemonic-names\n• Relates alphabet-names to character sets or collating sequences\n• Specifies symbolic characters\n• Relates class names to sets of characters\n• Specifies one or more currency sign values and defines a picture symbol to represent each currency sign\nvalue in PICTURE clauses\n• Specifies that the functions of the comma and decimal point are to be interchanged in PICTURE clauses\nand numeric literals\n• Relates xml-schema-names to ddnames or environment variable names identifying files containing XML\nschemas\nThe clauses in the SPECIAL-NAMES paragraph can appear in any order.\n126  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "SEGMENT-LIMIT IS\nThe SEGMENT-LIMIT clause is syntax checked but has no effect on the execution of the program.\npriority-number\nAn integer ranging from 1 through 49. All sections with priority-numbers 0 through 49 are fixed\npermanent segments. See “Procedures” on page 271 for a description of priority-numbers and\nsegmentation support.\nSegmentation is not supported for programs compiled with the THREAD option.\nAll of the OBJECT-COMPUTER paragraph is syntax checked, but only the PROGRAM COLLATING\nSEQUENCE clause has an effect on the execution of the program.\nThe OBJECT-COMPUTER paragraph cannot be specified in a function prototype definition.\nSPECIAL-NAMES paragraph\nThe SPECIAL-NAMES paragraph is the name of an ENVIRONMENT DIVISION paragraph in which\nenvironment-names are related to user-specified mnemonic-names.\nThe SPECIAL-NAMES paragraph:\n• Relates IBM-specified environment-names to user-defined mnemonic-names\n• Relates alphabet-names to character sets or collating sequences\n• Specifies symbolic characters\n• Relates class names to sets of characters\n• Specifies one or more currency sign values and defines a picture symbol to represent each currency sign\nvalue in PICTURE clauses\n• Specifies that the functions of the comma and decimal point are to be interchanged in PICTURE clauses\nand numeric literals\n• Relates xml-schema-names to ddnames or environment variable names identifying files containing XML\nschemas\nThe clauses in the SPECIAL-NAMES paragraph can appear in any order.\n126  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "SET(ptr-ref)\nspecifies the pointer reference that is to be set to the address location of the data r", "output": "SET(ptr-ref)\nspecifies the pointer reference that is to be set to the address location of the data read from the data\nset.\nIf you specify the SET option, the parameter must be a data area. On completion of the retrieval\noperation, the data area is set to the length of the data.\nIf DATALOCATION(ANY) is associated with the application program, the address of the data can be\nabove or below the 16MB line.\nIf DATALOCATION(BELOW) is associated with the application program, and the data resides above the\n16MB line, the data is copied below the 16MB line, and the address of this copy is returned.\nIf TASKDATAKEY(USER) is specified for the running task, and storage protection is active, the data\nreturned is in a user-key. If TASKDATAKEY(CICS) is specified and storage protection is active, the data\nreturned is in a CICS-key.\nIf you have specified SET, you must also specify LENGTH.\nConditions\n46 DSSTAT\noccurs when the destination status changes in one of the following ways:\n• The data stream is abended.\n• The data stream is suspended.\nDefault action: terminate the task abnormally.\n06 EOC\noccurs if the request/response unit (RU) is received with the end-of-chain (EOC) indicator set. Field\nEIBEOC also contains this indicator.\nDefault action: ignore the condition.\n05 EODS\noccurs when the end of the data set is encountered.\nDefault action: terminate the task abnormally.\n16 INVREQ\nRESP2 values:\n200\nA distributed program link server application specified the function-shipping session (its principal\nfacility) on the CONVID option.\nDefault action: terminate the task abnormally.\n22 LENGERR\noccurs if the length of the retrieved data is greater than the value specified by the LENGTH option.\nDefault action: terminate the task abnormally.\n49 UNEXPIN\noccurs when some unexpected or unrecognized information is received from the outboard controller.\nDefault action: terminate the task abnormally.\nISSUE REPLACE\nUpdate a record in a data set.\nChapter 2. CICS command summary  293"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "MULTIPLY statement\nThe MULTIPLY statement multiplies numeric items and sets the values of data items", "output": "MULTIPLY statement\nThe MULTIPLY statement multiplies numeric items and sets the values of data items equal to the results.\nFormat 1: MULTIPLY statement\nMULTIPLY\nidentifier-1\nliteral-1\nBY\nidentifier-2\nROUNDED\nON\nSIZE ERROR\nimperative-statement-1\nNOT\nON\nSIZE ERROR\nimperative-statement-2\nEND-MULTIPLY\nIn format 1, the value of identifier-1 or literal-1 is multiplied by the value of identifier-2; the product is\nthen placed in identifier-2. For each successive occurrence of identifier-2, the multiplication takes place in\nthe left-to-right order in which identifier-2 is specified.\nFormat 2: MULTIPLY statement with GIVING phrase\nMULTIPLY\nidentifier-1\nliteral-1\nBY\nidentifier-2\nliteral-2\nGIVING\nidentifier-3\nROUNDED\nON\nSIZE ERROR\nimperative-statement-1\nNOT\nON\nSIZE ERROR\nimperative-statement-2\nEND-MULTIPLY\nIn format 2, the value of identifier-1 or literal-1 is multiplied by the value of identifier-2 or literal-2. The\nproduct is then stored in the data items referenced by identifier-3.\nFor all formats:\nidentifier-1 , identifier-2\nMust name an elementary numeric item.\n416  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What is LAST\nspecifies that this in COBOL?", "input": "", "output": "LAST\nspecifies that this is last output operation for a transaction and, therefore, the end of a bracket"}
{"instruction": "Summarize this COBOL documentation section", "input": "• An out-of-range value is supplied in the PROCLENGTH option.\n• The value that is specified in the PIPLENGTH option is less than 0.\n• The value that is specified in the PIPLENGTH option exceeds the CICS implementation limit of 32\n763.\n• A PIPLIST length element (LL) has a value less than 4.\n• The sum of the length elements (LLs) in the PIPLIST does not equal the value that is specified by\nPIPLENGTH.\nDefault action: terminate the task abnormally.\n61 NOTALLOC\nThis condition occurs if the specified CONVID value does not relate to a conversation owned by the\napplication.\nDefault action: terminate the task abnormally.\n97 PARTNERIDERR\nThis condition occurs if the name specified in the PARTNER option is not recognized by CICS.\nDefault action: terminate the task abnormally.\n81 TERMERR\nThis condition occurs for a session-related error. Any action on that conversation other than a FREE\ncauses an ATCV abend.\nA CANCEL TASK request by a user node error program (NEP) can cause this condition if the task has\nan outstanding terminal control request active when the node abnormal condition program handles\nthe session error.\nDefault action: terminate the task abnormally with abend code ATNI.\nCONVERSE (default)\nCommunicate on standard CICS terminal support.\nCONVERSE (default)\nCONVERSE\nFROM( data-area )\nFROMLENGTH(  data-value )\nFROMFLENGTH(  data-value )\nINTO( data-area )\nSET( ptr-ref )\nTOLENGTH(  data-area )\nTOFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nNOTRUNCATE\nConditions: LENGERR\n   \nDescription\nThis form of the CONVERSE command is used by all CICS-supported z/OS Communications Server\nterminals for which the other CONVERSE descriptions are not appropriate.\nChapter 2. CICS command summary  79", "output": "• An out-of-range value is supplied in the PROCLENGTH option.\n• The value that is specified in the PIPLENGTH option is less than 0.\n• The value that is specified in the PIPLENGTH option exceeds the CICS implementation limit of 32\n763.\n• A PIPLIST length element (LL) has a value less than 4.\n• The sum of the length elements (LLs) in the PIPLIST does not equal the value that is specified by\nPIPLENGTH.\nDefault action: terminate the task abnormally.\n61 NOTALLOC\nThis condition occurs if the specified CONVID value does not relate to a conversation owned by the\napplication.\nDefault action: terminate the task abnormally.\n97 PARTNERIDERR\nThis condition occurs if the name specified in the PARTNER option is not recognized by CICS.\nDefault action: terminate the task abnormally.\n81 TERMERR\nThis condition occurs for a session-related error. Any action on that conversation other than a FREE\ncauses an ATCV abend.\nA CANCEL TASK request by a user node error program (NEP) can cause this condition if the task has\nan outstanding terminal control request active when the node abnormal condition program handles\nthe session error.\nDefault action: terminate the task abnormally with abend code ATNI.\nCONVERSE (default)\nCommunicate on standard CICS terminal support.\nCONVERSE (default)\nCONVERSE\nFROM( data-area )\nFROMLENGTH(  data-value )\nFROMFLENGTH(  data-value )\nINTO( data-area )\nSET( ptr-ref )\nTOLENGTH(  data-area )\nTOFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nNOTRUNCATE\nConditions: LENGERR\n   \nDescription\nThis form of the CONVERSE command is used by all CICS-supported z/OS Communications Server\nterminals for which the other CONVERSE descriptions are not appropriate.\nChapter 2. CICS command summary  79"}
{"instruction": "Explain this COBOL concept", "input": "$125.53CR\nClient Information: \n  Name:\n    Smith               \n    John                \n  Address:\n    12345 First Avenue  \n    New York            \n    New York            \n    10203     \nSuccessful JSON Parse\nTransactions:\n  Record 1:\n    TXID:        00107\n    Description: prod a ver 1                                      \n    Item ID:     ab/1424 24\n    Price:        $12.34\n    Comment:     express shipping    \n  Record 2:\n    TXID:        01904\n    Description: prod g ver 2                                      \n    Item ID:     gb/0515 33\n    Price:       $833.22\n    Comment:     digital download        \n   \nRelated references  \nJSON PARSE statement (Enterprise COBOL for z/OS Language Reference)    \nChapter 36. Processing JSON input   643", "output": "$125.53CR\nClient Information: \n  Name:\n    Smith               \n    John                \n  Address:\n    12345 First Avenue  \n    New York            \n    New York            \n    10203     \nSuccessful JSON Parse\nTransactions:\n  Record 1:\n    TXID:        00107\n    Description: prod a ver 1                                      \n    Item ID:     ab/1424 24\n    Price:        $12.34\n    Comment:     express shipping    \n  Record 2:\n    TXID:        01904\n    Description: prod g ver 2                                      \n    Item ID:     gb/0515 33\n    Price:       $833.22\n    Comment:     digital download        \n   \nRelated references  \nJSON PARSE statement (Enterprise COBOL for z/OS Language Reference)    \nChapter 36. Processing JSON input   643"}
{"instruction": "Summarize this COBOL documentation section", "input": "START statement\nThe START statement provides a means of positioning within an indexed or relative file for subsequent\nsequential record retrieval.\nWhen the START statement is executed, the associated indexed or relative file must be open in either\nINPUT or I-O mode.\nFormat\nSTART\nfile-name-1\nKEY\nIS\nEQUAL\nTO\n = \nGREATER\nTHAN\n > \nNOT LESS\nTHAN\nNOT < \nGREATER\nTHAN\nOR EQUAL\nTO\n >= \nPARTIAL\ndata-name-1\nINVALID\nKEY\nimperative-statement-1\nNOT INVALID\nKEY\nimperative-statement-2\nEND-START\nfile-name-1\nMust name a file with sequential or dynamic access. file-name-1 must be defined in an FD entry in the\nDATA DIVISION and must not name a sort file.\nKEY phrase\nWhen the KEY phrase is specified, the file position indicator is positioned at the logical record in the file\nwhose key field satisfies the comparison.\nWhen the KEY phrase is not specified, KEY IS EQUAL (to the prime record key) is implied.\nPARTIAL phrase\nThe PARTIAL phrase can be specified for VSAMDB files.\nWhen the PARTIAL phrase is specified the key value in data-name-1 is considered a partial, or generic,\nvalue.\nPartial key values can be useful when searching for records where the key starts with a known prefix.\ndata-name-1\nCan be qualified; it cannot be subscripted.\nWhen the START statement is executed, a comparison is made between the current value in the key\ndata-name and the corresponding key field in the file's index.\nChapter 28. PROCEDURE DIVISION statements  465", "output": "START statement\nThe START statement provides a means of positioning within an indexed or relative file for subsequent\nsequential record retrieval.\nWhen the START statement is executed, the associated indexed or relative file must be open in either\nINPUT or I-O mode.\nFormat\nSTART\nfile-name-1\nKEY\nIS\nEQUAL\nTO\n = \nGREATER\nTHAN\n > \nNOT LESS\nTHAN\nNOT < \nGREATER\nTHAN\nOR EQUAL\nTO\n >= \nPARTIAL\ndata-name-1\nINVALID\nKEY\nimperative-statement-1\nNOT INVALID\nKEY\nimperative-statement-2\nEND-START\nfile-name-1\nMust name a file with sequential or dynamic access. file-name-1 must be defined in an FD entry in the\nDATA DIVISION and must not name a sort file.\nKEY phrase\nWhen the KEY phrase is specified, the file position indicator is positioned at the logical record in the file\nwhose key field satisfies the comparison.\nWhen the KEY phrase is not specified, KEY IS EQUAL (to the prime record key) is implied.\nPARTIAL phrase\nThe PARTIAL phrase can be specified for VSAMDB files.\nWhen the PARTIAL phrase is specified the key value in data-name-1 is considered a partial, or generic,\nvalue.\nPartial key values can be useful when searching for records where the key starts with a known prefix.\ndata-name-1\nCan be qualified; it cannot be subscripted.\nWhen the START statement is executed, a comparison is made between the current value in the key\ndata-name and the corresponding key field in the file's index.\nChapter 28. PROCEDURE DIVISION statements  465"}
{"instruction": "Explain this COBOL concept", "input": "Table 83. IBM extension language elements (continued)\nLanguage area\nExtension elements\nDATA DIVISION\nLOCAL-STORAGE SECTION\nThe GLOBAL clause in the LINKAGE SECTION\nSpecifying level numbers that are lower than other level numbers at\nthe same hierarchical level in a data description entry. [The 85 COBOL\nStandard requires that all elementary or group items at the same level\nin the hierarchy be assigned identical level numbers.]\nData categories internal floating-point, external floating-point, DBCS,\nnational, and national-edited.\nData category numeric with usage NATIONAL.\nData category numeric-edited with usage NATIONAL.\nFILE SECTION\ndata-name in the LABEL RECORDS clause, for specifying user labels\nRECORDING MODE clause\nLine-sequential format file description entry\nSort/merge file description entry\nThe following clauses:\n• BLOCK CONTAINS\n• LABEL RECORDS\n• VALUE OF\n• LINAGE\n• CODE-SET\n• WITH FOOTING\n• LINES AT\nBLOCK CONTAINS clause\nBLOCK CONTAINS 0 for QSAM files. [The 85 COBOL Standard requires\nthat at least 1 CHARACTER or RECORD be specified in the BLOCK\nCONTAINS clause.]\nVALUE OF clause\nThe lack of VALUE clause effect on execution when specified under an\nSD\nDATA RECORDS clause\nOptionality of an 01 record description entry for a specified data-name.\n[The 85 COBOL Standard requires that an 01 record with the same\ndata-name be specified.]\nLINAGE clause\nSpecifying LINAGE for files opened in EXTEND mode\nBLANK WHEN ZERO clause\nAlternative spellings ZEROS and ZEROES for ZERO\nGLOBAL clause\nSpecifying GLOBAL in the LINKAGE SECTION\nINDEXED BY phrase\nNonunique unreferenced index names\nAppendix B. IBM extensions  751", "output": "Table 83. IBM extension language elements (continued)\nLanguage area\nExtension elements\nDATA DIVISION\nLOCAL-STORAGE SECTION\nThe GLOBAL clause in the LINKAGE SECTION\nSpecifying level numbers that are lower than other level numbers at\nthe same hierarchical level in a data description entry. [The 85 COBOL\nStandard requires that all elementary or group items at the same level\nin the hierarchy be assigned identical level numbers.]\nData categories internal floating-point, external floating-point, DBCS,\nnational, and national-edited.\nData category numeric with usage NATIONAL.\nData category numeric-edited with usage NATIONAL.\nFILE SECTION\ndata-name in the LABEL RECORDS clause, for specifying user labels\nRECORDING MODE clause\nLine-sequential format file description entry\nSort/merge file description entry\nThe following clauses:\n• BLOCK CONTAINS\n• LABEL RECORDS\n• VALUE OF\n• LINAGE\n• CODE-SET\n• WITH FOOTING\n• LINES AT\nBLOCK CONTAINS clause\nBLOCK CONTAINS 0 for QSAM files. [The 85 COBOL Standard requires\nthat at least 1 CHARACTER or RECORD be specified in the BLOCK\nCONTAINS clause.]\nVALUE OF clause\nThe lack of VALUE clause effect on execution when specified under an\nSD\nDATA RECORDS clause\nOptionality of an 01 record description entry for a specified data-name.\n[The 85 COBOL Standard requires that an 01 record with the same\ndata-name be specified.]\nLINAGE clause\nSpecifying LINAGE for files opened in EXTEND mode\nBLANK WHEN ZERO clause\nAlternative spellings ZEROS and ZEROES for ZERO\nGLOBAL clause\nSpecifying GLOBAL in the LINKAGE SECTION\nINDEXED BY phrase\nNonunique unreferenced index names\nAppendix B. IBM extensions  751"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Abbreviations are: LC\nnnn must be an integer between 10 and 255, or 0.\nIf you specify LINECOUNT(0), ", "output": "Abbreviations are: LC\nnnn must be an integer between 10 and 255, or 0.\nIf you specify LINECOUNT(0), no page ejects are generated in the compilation listing.\nThe compiler uses three lines of nnn for titles. For example, if you specify LINECOUNT(60), 57 lines of\nsource code are printed on each page of the output listing.\nLIST\nUse the LIST compiler option to produce a listing of the assembler-language expansion of your source\ncode.\nLIST option syntax\nNOLIST\nLIST\nDefault is: NOLIST\nAbbreviations are: None\nThese items will also be written to the output listing:\n• Constant area\n• Program prolog areas (PPA1, PPA2, PPA3, PPA4)\n• Time stamp, compiler version, and build level information\n• Compiler options and program information\n• Base locator table\n• External symbols dictionary\n• Initial heap storage maps\n• Stack storage maps\nThe output is generated if:\n• You specify the COMPILE option, or the NOCOMPILE(x) option is in effect and an error of level x or higher\ndoes not occur.\n• You do not specify the OFFSET option.\nIf you want to limit the assembler listing output, use *CONTROL (or *CBL) LIST or NOLIST statements\nin the PROCEDURE DIVISION. Source statements that follow a *CONTROL NOLIST statement are not\nincluded in the listing until a subsequent *CONTROL LIST statement switches the output back to normal\nLIST format.\nRelated tasks   \n“Getting listings” on page 477 \nRelated references   \n“Conflicting compiler options” on page 358  \n*CONTROL (*CBL) statement (Enterprise COBOL for z/OS Language Reference)\n396  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What is you can determine that the uninitialized switch in COBOL?", "input": "", "output": "you can determine that the uninitialized switch is cause of the problem or\nremove it as a possible cause"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Conditions\n16 INVREQ\nRESP2 values:\n1\nThe command is issued in a non-CICS Web support application.\n2\n", "output": "Conditions\n16 INVREQ\nRESP2 values:\n1\nThe command is issued in a non-CICS Web support application.\n2\nA WEB SEND command has not been issued..\n13 NOTFND\nRESP2 values:\n1\nDocument is not available as the last WEB SEND specified DOCSTATUS(DOCDELETE) or the last\nWEB SEND was not a SEND for a document with ACTION(EVENTUAL).\nWEB SEND (Server)\nSend an HTTP response, or a non-HTTP message.\nWEB SEND\nWEB\nSEND\nDOCTOKEN(  data-value )\nNODOCDELETE\nDOCDELETE\nDOCSTATUS(  cvda)\nFROM( data-area )\nFROMLENGTH(  data-value )\nCHUNKNO\nCHUNKYES\nCHUNKEND\nCHUNKING(  cvda)\nHOSTCODEPAGE(  data-value )\nCONTAINER(  data-value )\nCHANNEL(  data-value )\nMEDIATYPE(  data-value )\nSRVCONVERT\nNOSRVCONVERT\nSERVERCONV(  cvda)\nCHARACTERSET(  data-value )\nSTATUSCODE(  data-value )\nSTATUSTEXT(  data-area )\nSTATUSLEN(  data-value )\nLENGTH( data-value )\nIMMEDIATE\nEVENTUAL\nACTION(  cvda)\nNOCLOSE\nCLOSE\nCLOSESTATUS(  cvda)\nConditions: CHANNELERR, CONTAINERERR, IOERR, INVREQ, LENGERR, NOTFND\nThis command is threadsafe.\n644  CICS TS for z/OS: API Reference"}
{"instruction": "Summarize this COBOL documentation section", "input": "Format 1: WRITE statement for sequential files\nWRITE\nrecord-name-1\nFROM\nidentifier-1\nBEFORE\nAFTER\nADVANCING\nidentifier-2\ninteger-1\nLINE\nLINES\nmnemonic-name-1\nPAGE\nphrase 1\ninvalid_key\nnot_invalid_key\nEND-WRITE\nphrase 1\nAT\nEND-OF-PAGE\nEOP\nimperative-statement-3\nNOT\nAT\nEND-OF-PAGE\nEOP\nimperative-statement-4\ninvalid_key\nINVALID\nKEY\nimperative-statement-1\nnot_invalid_key\nNOT INVALID\nKEY\nimperative-statement-2\nFormat 2: WRITE statement for indexed and relative files\nWRITE\nrecord-name-1\nFROM\nidentifier-1\nINVALID\nKEY\nimperative-statement-1\nNOT INVALID\nKEY\nimperative-statement-2\nEND-WRITE\n482  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "Format 1: WRITE statement for sequential files\nWRITE\nrecord-name-1\nFROM\nidentifier-1\nBEFORE\nAFTER\nADVANCING\nidentifier-2\ninteger-1\nLINE\nLINES\nmnemonic-name-1\nPAGE\nphrase 1\ninvalid_key\nnot_invalid_key\nEND-WRITE\nphrase 1\nAT\nEND-OF-PAGE\nEOP\nimperative-statement-3\nNOT\nAT\nEND-OF-PAGE\nEOP\nimperative-statement-4\ninvalid_key\nINVALID\nKEY\nimperative-statement-1\nnot_invalid_key\nNOT INVALID\nKEY\nimperative-statement-2\nFormat 2: WRITE statement for indexed and relative files\nWRITE\nrecord-name-1\nFROM\nidentifier-1\nINVALID\nKEY\nimperative-statement-1\nNOT INVALID\nKEY\nimperative-statement-2\nEND-WRITE\n482  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "User-defined word\nDBCS characters allowed?\nLibrary-name\nNo\nMnemonic-name\nYes\nObject-oriented class-n", "output": "User-defined word\nDBCS characters allowed?\nLibrary-name\nNo\nMnemonic-name\nYes\nObject-oriented class-name\nNo\nParagraph-name\nYes\nPriority-numbers: 00–99\nNo\nProgram-name\nNo\nRecord-name\nYes\nSection-name\nYes\nSymbolic-character\nYes\nText-name\nNo\nType-name\nYes\nXML-schema-name\nYes\nThe maximum length of a user-defined word is 30 bytes, except for level-numbers and priority-numbers.\nLevel-numbers and priority numbers must each be a one-digit or two-digit integer.\nA given user-defined word can belong to only one of these sets, except that a given number can be both\na priority-number and a level-number. Each user-defined word within a set must be unique, except for\npriority-numbers and level-numbers and except as specified in Chapter 8, “Referencing data names, copy\nlibraries, and PROCEDURE DIVISION names,” on page 67.\nThe following types of user-defined words can be referenced by statements and entries in the program in\nwhich the user-defined word is declared:\n• Paragraph-name\n• Section-name\nThe following types of user-defined words can be referenced by any COBOL program, provided that the\ncompiling system supports the associated library or other system and that the entities referenced are\nknown to that system:\n• Library-name\n• Text-name\nThe following types of names, when they are declared within a configuration section, can be referenced by\nstatements and entries in the program that contains the configuration section or in any program contained\nwithin that program:\n• Alphabet-name\n• Class-name\n• Condition-name\n• Mnemonic-name\n• Symbolic-character\n• XML-schema-name\nThe function of each user-defined word is described in the clause or statement in which it appears.\nRelated references   \nAppendix F, “Context-sensitive words,” on page 789\nChapter 3. Character-strings: COBOL words and literals  13"}
{"instruction": "Summarize this COBOL documentation section", "input": "• SYNCSEND \nSYSID(systemname)\nspecifies the remote system to which an APPC session is to be allocated. The name, which is 1–4\ncharacters, identifies an entry (defined as an APPC connection) in the CICS terminal control table.\nTable 1. GDS ALLOCATE return codes\nRETCODE\n(hexadecimal)\nDescription\n01 0C 00\nSYSID is unrecognized.\n01 0C 04\nSYSID is not an LUTYPE6.2 connection name.\n01 04 04\nNOQUEUE is specified but no bound connection-winner sessions are\navailable.\n01 04 08\nMODENAME is not known.\n01 04 0C\nThe MODENAME value is SNASVCMG which is restricted to use by CICS.\n01 04 0C\nz/OS Communications Server has no class of service (COS) table for the\nMODENAME value.\n01 04 10\nThe task was canceled during queuing of the command.\n01 04 14\nAll modegroups are closed.\n01 04 14\nThe requested modegroup is closed.\n01 04 18\nThe requested modegroup is draining (closing down).\n01 08 00\nAll sessions in the requested modegroup are unusable.\n01 08 00\nThe connection is in quiesce state.\n01 08 00\nThe connection is out of service.\n01 08 00\nThe connection is not acquired.\n01 08 00\nThe requested modegroup's local max (maximum permitted number of\nsessions) is 0.\n01 08 00\nThe VTAM® ACB is closed.\n01 0C 14\nThe NETNAME specified in the PARTNER definition is not known.\n02 0C 00\nPARTNER is not known.\n06 00 00\nThe PROFILE specified in the PARTNER definition is not known.\nNote: VTAM is now the z/OS Communications Server.\nGDS ASSIGN\nGet the identifier of the principal facility in use by APPC basic conversation (assembler-language and C\nprograms only).\nGDS ASSIGN (APPC basic)\nGDS ASSIGN\nPRINCONVID(  data-area )\nPRINSYSID(  data-area )\nRETCODE(  data-area )\nChapter 2. CICS command summary  199", "output": "• SYNCSEND \nSYSID(systemname)\nspecifies the remote system to which an APPC session is to be allocated. The name, which is 1–4\ncharacters, identifies an entry (defined as an APPC connection) in the CICS terminal control table.\nTable 1. GDS ALLOCATE return codes\nRETCODE\n(hexadecimal)\nDescription\n01 0C 00\nSYSID is unrecognized.\n01 0C 04\nSYSID is not an LUTYPE6.2 connection name.\n01 04 04\nNOQUEUE is specified but no bound connection-winner sessions are\navailable.\n01 04 08\nMODENAME is not known.\n01 04 0C\nThe MODENAME value is SNASVCMG which is restricted to use by CICS.\n01 04 0C\nz/OS Communications Server has no class of service (COS) table for the\nMODENAME value.\n01 04 10\nThe task was canceled during queuing of the command.\n01 04 14\nAll modegroups are closed.\n01 04 14\nThe requested modegroup is closed.\n01 04 18\nThe requested modegroup is draining (closing down).\n01 08 00\nAll sessions in the requested modegroup are unusable.\n01 08 00\nThe connection is in quiesce state.\n01 08 00\nThe connection is out of service.\n01 08 00\nThe connection is not acquired.\n01 08 00\nThe requested modegroup's local max (maximum permitted number of\nsessions) is 0.\n01 08 00\nThe VTAM® ACB is closed.\n01 0C 14\nThe NETNAME specified in the PARTNER definition is not known.\n02 0C 00\nPARTNER is not known.\n06 00 00\nThe PROFILE specified in the PARTNER definition is not known.\nNote: VTAM is now the z/OS Communications Server.\nGDS ASSIGN\nGet the identifier of the principal facility in use by APPC basic conversation (assembler-language and C\nprograms only).\nGDS ASSIGN (APPC basic)\nGDS ASSIGN\nPRINCONVID(  data-area )\nPRINSYSID(  data-area )\nRETCODE(  data-area )\nChapter 2. CICS command summary  199"}
{"instruction": "Explain this COBOL concept", "input": "• READQ TS\n• WRITEQ TS\nTerminal control\n• ALLOCATE (LUTYPE6.1)\n• ALLOCATE (MRO)\n• BUILD ATTACH (LUTYPE6.1)\n• BUILD ATTACH (MRO)\n• CONVERSE (APPC)\n• “CONVERSE (default)” on page 79\n• CONVERSE (LUTYPE2/LUTYPE3)\n• CONVERSE (LUTYPE4)\n• CONVERSE (LUTYPE6.1)\n• CONVERSE (MRO)\n• “CONVERSE (non-z/OS Communications Server default)” on page 92\n• “CONVERSE: non-z/OS Communications Server options” on page 94\n• CONVERSE (SCS)\n• “CONVERSE: z/OS Communications Server options” on page 88\n• CONVERSE (2260)\n• CONVERSE (3270 logical)\n• CONVERSE (3600-3601)\n• CONVERSE (3600-3614)\n• CONVERSE (3650 interpreter)\n• CONVERSE (3650-3270)\n• CONVERSE (3650-3653)\n• CONVERSE (3650-3680)\n• CONVERSE (3767)\n• CONVERSE (3770)\n• CONVERSE (3790 full-function or inquiry)\n• CONVERSE (3790 3270-display)\n• EXTRACT ATTACH (LUTYPE6.1)\n• EXTRACT ATTACH (MRO)\n• EXTRACT ATTRIBUTES (MRO)\n• EXTRACT LOGONMSG\n• EXTRACT TCT\n• FREE (LUTYPE6.1)\n• FREE\n• FREE (MRO)\n• HANDLE AID\n• ISSUE COPY (3270 logical)\n• “ISSUE DISCONNECT (LUTYPE6.1)” on page 276\n• ISSUE DISCONNECT\n22  CICS TS for z/OS: API Reference", "output": "• READQ TS\n• WRITEQ TS\nTerminal control\n• ALLOCATE (LUTYPE6.1)\n• ALLOCATE (MRO)\n• BUILD ATTACH (LUTYPE6.1)\n• BUILD ATTACH (MRO)\n• CONVERSE (APPC)\n• “CONVERSE (default)” on page 79\n• CONVERSE (LUTYPE2/LUTYPE3)\n• CONVERSE (LUTYPE4)\n• CONVERSE (LUTYPE6.1)\n• CONVERSE (MRO)\n• “CONVERSE (non-z/OS Communications Server default)” on page 92\n• “CONVERSE: non-z/OS Communications Server options” on page 94\n• CONVERSE (SCS)\n• “CONVERSE: z/OS Communications Server options” on page 88\n• CONVERSE (2260)\n• CONVERSE (3270 logical)\n• CONVERSE (3600-3601)\n• CONVERSE (3600-3614)\n• CONVERSE (3650 interpreter)\n• CONVERSE (3650-3270)\n• CONVERSE (3650-3653)\n• CONVERSE (3650-3680)\n• CONVERSE (3767)\n• CONVERSE (3770)\n• CONVERSE (3790 full-function or inquiry)\n• CONVERSE (3790 3270-display)\n• EXTRACT ATTACH (LUTYPE6.1)\n• EXTRACT ATTACH (MRO)\n• EXTRACT ATTRIBUTES (MRO)\n• EXTRACT LOGONMSG\n• EXTRACT TCT\n• FREE (LUTYPE6.1)\n• FREE\n• FREE (MRO)\n• HANDLE AID\n• ISSUE COPY (3270 logical)\n• “ISSUE DISCONNECT (LUTYPE6.1)” on page 276\n• ISSUE DISCONNECT\n22  CICS TS for z/OS: API Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "ZWB\nIf you compile using ZWB, the compiler removes the sign from a signed zoned decimal (DISPLAY) fi", "output": "ZWB\nIf you compile using ZWB, the compiler removes the sign from a signed zoned decimal (DISPLAY) field\nbefore comparing this field to an alphanumeric elementary field during execution.\nZWB option syntax\nZWB\nNOZWB\nDefault is: ZWB\nAbbreviations are: None\nIf the zoned decimal item is a scaled item (that is, it contains the symbol P in its PICTURE string),\ncomparisons that use the decimal item are not affected by ZWB. Such items always have their sign\nremoved before the comparison is made to an alphanumeric field.\nZWB affects how a program runs. The same COBOL program can produce different results depending on\nthe setting of this option.\nUse NOZWB if you want to test input numeric fields for SPACES.\nCOBOL runtime options\nThis section lists the COBOL runtime options.\nTable 55. COBOL runtime options\nCOBOL runtime options\nPurposes\nAIXBLD | NOAIXBLD\nInvokes the access method services (AMS) for\nVSAM indexed and relative data sets to complete\nthe file and index definition procedures for COBOL\nprograms. It builds the alternate index at runtime.\nCBLOPTS\nSpecifies the relative order in which program\narguments and runtime options are expected. The\ndefault CBLOPTS(ON) implies program arguments\nare first followed by a “/” and then runtime options.\nCBLPSHPOP\nControls if CICS PUSH HANDLE and CICS POP\nHANDLE are used.\nCBLQDA\nControls COBOL QSAM dynamic allocation.\nCHECK\nEnables range checking if compiled with SSRANGE.\nIgnored for applications compiled with Enterprise\nCOBOL 5 and later.\nDEBUG | NODEBUG\nActivates the COBOL batch debugging features\nspecified by the USE FOR DEBUGGING declarative.\nFLOW\nControls the FLOW output produced by OS/VS\nCOBOL programs.\nRTEUSE\nImplicitly initializes the runtime environment to be\nreusable.\nSIMVRD | NOSIMVRD\nSpecifies if your COBOL programs use a\nVSAM KSDS to simulate variable-length relative\norganization data sets.\n448  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What is which in COBOL?", "input": "", "output": "which is that they\nmight be changed by a called subprogram"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 84. EBCDIC collating sequence (continued)\nOrdinal\nnumber\nSymbol\nMeaning\nDecimal\nrepresentation", "output": "Table 84. EBCDIC collating sequence (continued)\nOrdinal\nnumber\nSymbol\nMeaning\nDecimal\nrepresentation\nHex representation\n. . .\n \n \n \n \n160\n€\nEuro currency sign\n159\n9F\n. . .\n \n \n \n \n162\n~\nTilde\n161\nA1\n163\ns\n \n162\nA2\n164\nt\n \n163\nA3\n165\nu\n \n164\nA4\n166\nv\n \n165\nA5\n167\nw\n \n166\nA6\n168\nx\n \n167\nA7\n169\ny\n \n168\nA8\n170\nz\n \n169\nA9\n. . .\n \n \n \n \n177\n^\nCaret\n176\nB0\n. . .\n \n \n \n \n188\n[\nOpening square bracket\n187\nBA\n189\n]\nClosing square bracket\n188\nBB\n. . .\n \n \n \n \n193\n{\nOpening brace\n192\nC0\n194\nA\n \n193\nC1\n195\nB\n \n194\nC2\n196\nC\n \n195\nC3®\n197\nD\n \n196\nC4\n198\nE\n \n197\nC5\n199\nF\n \n198\nC6\n200\nG\n \n199\nC7\n201\nH\n \n200\nC8\n202\nI\n \n201\nC9\n. . .\n \n \n \n \n209\n}\nClosing brace\n208\nD0\n210\nJ\n \n209\nD1\n211\nK\n \n210\nD2\n212\nL\n \n211\nD3\n213\nM\n \n212\nD4\nAppendix C. EBCDIC and ASCII collating sequences  763"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Default action: terminate the task abnormally.\n81 TERMERR\noccurs for a session-related error. Any ac", "output": "Default action: terminate the task abnormally.\n81 TERMERR\noccurs for a session-related error. Any action on that conversation other than a FREE causes an ATCV\nabend.\nA CANCEL TASK request by a user node error program (NEP) may cause this condition if the task has\nan outstanding terminal control request active when the node abnormal condition program handles\nthe session error.\nDefault action: terminate the task abnormally with abend code ATNI.\nISSUE PRINT\nPrint displayed data on first available printer.\nISSUE PRINT\nISSUE PRINT\nConditions: INVREQ, NOTALLOC, TERMERR\n \nDescription\nISSUE PRINT prints displayed data on the first available printer that can respond to a print request.\nISSUE PRINT can be used on a number of logical units, using the printers defined below:\n• For a 3270 logical unit or a 3650 host conversational (3270) logical unit, the printer must be defined\nby the PRINTER or ALTPRINTER options on the RDO TERMINAL resource definition, or by a printer\nsupplied by the autoinstall user program.\n• For a 3270-display logical unit with the PTRADAPT feature, used with a 3274 or 3276, the printer\nis allocated by the printer authorization matrix. The PTRADAPT feature is enabled by specifying\nDEVICE=LUTYPE2 and PRINTADAPTER=YES on the RDO TYPETERM resource definition.\n• For a 3790 (3270-display) logical unit, the printer is allocated by the 3790.\nThe printer must be in service, not currently attached to a task, and owned by the same CICS system\nthat owns the terminal running the transaction.\nConditions\n16 INVREQ\nRESP2 values:\n200\nA distributed program link server application specified the function-shipping session (its principal\nfacility) on the CONVID option.\nDefault action: terminate the task abnormally.\n61 NOTALLOC\noccurs if the facility specified in the command is not owned by the application.\nDefault action: terminate the task abnormally.\n81 TERMERR\noccurs for a terminal-related error.\n290  CICS TS for z/OS: API Reference"}
{"instruction": "What are the compiler rules or directives for this?", "input": "different files at run time, and those files have differing fixed lengths, avoid record-length", "output": "different files at run time, and those files have differing fixed lengths, avoid record-length"}
{"instruction": "What is the\nreturned value in COBOL?", "input": "", "output": "the\nreturned value is position of the first\ncharacter in error.\n• Otherwise, the returned value is (FUNCTION\nLENGTH (argument-1) + 1)"}
{"instruction": "Summarize this COBOL documentation section", "input": "Chapter 90. SIN\nThe SIN function returns a numeric value that approximates the sine of the angle or arc specified by the\nargument in radians.\nThe function type is numeric.\nFormat\nFUNCTION SIN\n(\nargument-1\n)\nargument-1\nMust be class numeric.\nThe returned value is the approximation of the sine of argument-1 and is greater than or equal to -1 and\nless than or equal to +1.\n© Copyright IBM Corp. 1991, 2025\n645", "output": "Chapter 90. SIN\nThe SIN function returns a numeric value that approximates the sine of the angle or arc specified by the\nargument in radians.\nThe function type is numeric.\nFormat\nFUNCTION SIN\n(\nargument-1\n)\nargument-1\nMust be class numeric.\nThe returned value is the approximation of the sine of argument-1 and is greater than or equal to -1 and\nless than or equal to +1.\n© Copyright IBM Corp. 1991, 2025\n645"}
{"instruction": "What is The function of the AT END phrase in COBOL?", "input": "", "output": "The function of the AT END phrase is same for a serial search and a binary search"}
{"instruction": "Explain this COBOL concept", "input": "Format 1a (Low-High qualification)\ndata-name-1\nIN\nOF\ndata-name-2\nIN\nOF\nfile-name-1\n(\nsubscript\n)\n(\nleftmost-character-position\n:\nlength\n)\nFormat 1b (High-Low qualification)\nfile-name-1\n::\ndata-name-2\n::\ndata-name-1\n(\nsubscript\n)\n(\nleftmost-character-position\n:\nlength\n)\ndata-name-1 , data-name-2\nCan be a record-name.\nfile-name-1\nMust be identified by an FD or SD entry in the DATA DIVISION.\nfile-name-1 must be unique within this program.\nFormat 2a (Low-High qualification)\ncondition-name-1\nindex-name-1\ndata-name-1\nIN\nOF\ndata-name-2\nIN\nOF\nfile-name-1\n70  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "Format 1a (Low-High qualification)\ndata-name-1\nIN\nOF\ndata-name-2\nIN\nOF\nfile-name-1\n(\nsubscript\n)\n(\nleftmost-character-position\n:\nlength\n)\nFormat 1b (High-Low qualification)\nfile-name-1\n::\ndata-name-2\n::\ndata-name-1\n(\nsubscript\n)\n(\nleftmost-character-position\n:\nlength\n)\ndata-name-1 , data-name-2\nCan be a record-name.\nfile-name-1\nMust be identified by an FD or SD entry in the DATA DIVISION.\nfile-name-1 must be unique within this program.\nFormat 2a (Low-High qualification)\ncondition-name-1\nindex-name-1\ndata-name-1\nIN\nOF\ndata-name-2\nIN\nOF\nfile-name-1\n70  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "Summarize this COBOL documentation section", "input": "• CANCEL\n• DELAY\n• FORMATTIME\n• POST\n• RETRIEVE\n• START\n• WAIT EVENT\nJournaling\n• WAIT JOURNALNAME\n• WAIT JOURNALNUM\n• WRITE JOURNALNAME\n• WRITE JOURNALNUM\nMonitoring\n• MONITOR\nNamed counter server\n• DEFINE COUNTER and DEFINE DCOUNTER\n• DELETE COUNTER and DELETE DCOUNTER\n• GET COUNTER and GET DCOUNTER\n• QUERY COUNTER and QUERY DCOUNTER\n• REWIND COUNTER and REWIND DCOUNTER\n• UPDATE COUNTER and UPDATE DCOUNTER\nProgram control\n• “INVOKE APPLICATION” on page 260\n• LINK\n• LOAD\n• RELEASE\n• RETURN\n• XCTL\nScheduling services\n• START ATTACH\n• START BREXIT\n20  CICS TS for z/OS: API Reference", "output": "• CANCEL\n• DELAY\n• FORMATTIME\n• POST\n• RETRIEVE\n• START\n• WAIT EVENT\nJournaling\n• WAIT JOURNALNAME\n• WAIT JOURNALNUM\n• WRITE JOURNALNAME\n• WRITE JOURNALNUM\nMonitoring\n• MONITOR\nNamed counter server\n• DEFINE COUNTER and DEFINE DCOUNTER\n• DELETE COUNTER and DELETE DCOUNTER\n• GET COUNTER and GET DCOUNTER\n• QUERY COUNTER and QUERY DCOUNTER\n• REWIND COUNTER and REWIND DCOUNTER\n• UPDATE COUNTER and UPDATE DCOUNTER\nProgram control\n• “INVOKE APPLICATION” on page 260\n• LINK\n• LOAD\n• RELEASE\n• RETURN\n• XCTL\nScheduling services\n• START ATTACH\n• START BREXIT\n20  CICS TS for z/OS: API Reference"}
{"instruction": "What are the compiler rules or directives for this?", "input": "input message\n550  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "input message\n550  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What is This option is required when the WSACONTEXT GET command is used by a web service requester\napplication and in COBOL?", "input": "", "output": "This option is required when the WSACONTEXT GET command is used by a web service requester\napplication and is channel name used by subsequent INVOKE SERVICE commands"}
{"instruction": "What is 5 Language Reference\n\n\nIf an arithmetic expression is specified as an argument and if the first operator in the expression in COBOL?", "input": "", "output": "5 Language Reference\n\n\nIf an arithmetic expression is specified as an argument and if the first operator in the expression is unary\nplus or a unary minus, the expression must be immediately preceded by a left parenthesis"}
{"instruction": "What is SEARCH in COBOL?", "input": "", "output": "SEARCH is same for a serial search and a binary search"}
{"instruction": "What is Note that the ECBLIST variable in COBOL?", "input": "", "output": "Note that the ECBLIST variable is pointer pointing to the first address of\nthe list"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 66. Signature information bytes\nOffset\nin\ndecim\nal\nSignatur\ne byte\nBit\nItem\nOn\nOff\n04\n28\n0\nSQL", "output": "Table 66. Signature information bytes\nOffset\nin\ndecim\nal\nSignatur\ne byte\nBit\nItem\nOn\nOff\n04\n28\n0\nSQL\nNOSQL\n1\nCICS\nNOCICS\n2\nMDECK\nNOMDECK\n3\nSQLCCSID\nNOSQLCCSID\n4\nOPTFILE\nNOOPTFILE\n5\nXMLPARSE(XMLSS)\nXMLPARSE(COMPAT)\n6\nBLOCK0\nNOBLOCK0\n7\nDISPSIGN(SEP)\nDISPSIGN(COMPAT)\n05\n29\n0\nProgram uses Java-based OO syntax\n1\nProgram uses RANDOM function\n2\nProgram uses NATIONAL data (Unicode)\n3\nXML PARSE with schema validation\n4\nSTGOPT\nNOSTGOPT\n5\nAFP(VOLATILE)\nAFP(NOVOLATILE)\n6\nHGPR(PRESERVE)\nHGPR(NOPRESERVE)\n7\nTEST|NOTEST(DWARF)\nNot TEST|NOTEST(NODWARF)\n06\n30\n0\nQUALIFY(EXTEND)\nQUALIFY(COMPAT)\n1\nVLR(COMPAT)\nVLR(STANDARD)\n2\nCOPYRIGHT string specified\nCOPYRIGHT string not specified\n3\nSERVICE string specified\nSERVICE string not specified\n4\nINVDATA(FNC,x)\nNot INVDATA(FNC,x)\nNote: When bits 4 and 5 are both off,\nNOINVDATA is in effect.\n5\nINVDATA(NOFNC,x)\nNot INVDATA(NOFNC,x)\nNote: When bits 4 and 5 are both off,\nNOINVDATA is in effect\n6\nINVDATA(x,NOCS)\nINVDATA(x,CS), should be zero when\nbits 4 and 5 are zero.\n7\nNUMCHECK(ZON(LAX))\nNUMCHECK(ZON(STRICT))\nChapter 22. Debugging  491"}
{"instruction": "Summarize this COBOL documentation section", "input": "Table 6. Internal representation of numeric items (continued)\nNumeric type\nPICTURE and USAGE and\noptional SIGN clause\nValue\nInternal representation\nInternal\ndecimal\nPIC S9999 PACKED-\nDECIMAL\nPIC S9999 COMP-3 \n+ 1234\n   01 23 4C\n- 1234\n   01 23 4D\nPIC 9999  PACKED-\nDECIMAL\nPIC 9999  COMP-3 \n  1234\n   01 23 4F\nInternal\nfloating point\nCOMP-1\n+ 1234\n43 4D 20 00\n- 1234\nC3 4D 20 00\nCOMP-2\n+ 1234\n43 4D 20 00 00 00 00 00\n- 1234\nC3 4D 20 00 00 00 00 00\nExternal\nfloating point\nPIC +9(2).9(2)E+99\nDISPLAY\n+ 12.34E+02\n4E F1 F2 4B F3 F4 C5 4E F0\nF2\n- 12.34E+02\n60 F1 F2 4B F3 F4 C5 4E F0\nF2\nPIC +9(2).9(2)E+99\nNATIONAL\n+ 12.34E+02\n00 2B 00 31 00 32 00 2E 00 \n33\n00 34 00 45 00 2B 00 30 00 \n32\n- 12.34E+02\n00 2D 00 31 00 32 00 2E 00 \n33\n00 34 00 45 00 2B 00 30 00 \n32\n1. The example demonstrates that COMP-5 data items can contain values of magnitude up to the capacity\nof the native binary representation (2, 4, or 8 bytes), rather than being limited to the value implied by the\nnumber of 9s in the PICTURE clause.\nData format conversions\nWhen the code in your program involves the interaction of items that have different data formats,\nthe compiler converts those items either temporarily, for comparisons and arithmetic operations, or\npermanently, for assignment to the receiver in a MOVE or COMPUTE statement.\nA conversion is actually a move of a value from one data item to another. The compiler performs any\nconversions that are required during the execution of arithmetic or comparisons by using the same rules\nthat are used for MOVE and COMPUTE statements.\nWhen possible, the compiler performs a move to preserve numeric value instead of a direct digit-for-digit\nmove.\nChapter 3. Working with numbers and arithmetic  57", "output": "Table 6. Internal representation of numeric items (continued)\nNumeric type\nPICTURE and USAGE and\noptional SIGN clause\nValue\nInternal representation\nInternal\ndecimal\nPIC S9999 PACKED-\nDECIMAL\nPIC S9999 COMP-3 \n+ 1234\n   01 23 4C\n- 1234\n   01 23 4D\nPIC 9999  PACKED-\nDECIMAL\nPIC 9999  COMP-3 \n  1234\n   01 23 4F\nInternal\nfloating point\nCOMP-1\n+ 1234\n43 4D 20 00\n- 1234\nC3 4D 20 00\nCOMP-2\n+ 1234\n43 4D 20 00 00 00 00 00\n- 1234\nC3 4D 20 00 00 00 00 00\nExternal\nfloating point\nPIC +9(2).9(2)E+99\nDISPLAY\n+ 12.34E+02\n4E F1 F2 4B F3 F4 C5 4E F0\nF2\n- 12.34E+02\n60 F1 F2 4B F3 F4 C5 4E F0\nF2\nPIC +9(2).9(2)E+99\nNATIONAL\n+ 12.34E+02\n00 2B 00 31 00 32 00 2E 00 \n33\n00 34 00 45 00 2B 00 30 00 \n32\n- 12.34E+02\n00 2D 00 31 00 32 00 2E 00 \n33\n00 34 00 45 00 2B 00 30 00 \n32\n1. The example demonstrates that COMP-5 data items can contain values of magnitude up to the capacity\nof the native binary representation (2, 4, or 8 bytes), rather than being limited to the value implied by the\nnumber of 9s in the PICTURE clause.\nData format conversions\nWhen the code in your program involves the interaction of items that have different data formats,\nthe compiler converts those items either temporarily, for comparisons and arithmetic operations, or\npermanently, for assignment to the receiver in a MOVE or COMPUTE statement.\nA conversion is actually a move of a value from one data item to another. The compiler performs any\nconversions that are required during the execution of arithmetic or comparisons by using the same rules\nthat are used for MOVE and COMPUTE statements.\nWhen possible, the compiler performs a move to preserve numeric value instead of a direct digit-for-digit\nmove.\nChapter 3. Working with numbers and arithmetic  57"}
{"instruction": "What is oriented COBOL programs\nA wrapper in COBOL?", "input": "", "output": "oriented COBOL programs\nA wrapper is class that provides an interface between object-oriented code and procedure-oriented\ncode"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "A CANCEL TASK request by a user node error program (NEP) may cause this condition if the task has\nan", "output": "A CANCEL TASK request by a user node error program (NEP) may cause this condition if the task has\nan outstanding terminal control request active when the node abnormal condition program handles\nthe session error.\nDefault action: terminate the task abnormally with abend code ATNI.\nISSUE QUERY\nInterrogate a data set. \nISSUE QUERY\nISSUE QUERY\nDESTID( data-value )\nDESTIDLENG(  data-value )\nVOLUME(  data-value )\nVOLUMELENG(  data-value )\nConditions: FUNCERR, INVREQ, SELNERR, UNEXPIN\n \nDescription\nISSUE QUERY interrogates a data set. It is used to request that a sequential data set in an outboard\ncontroller be transmitted to the host system. The application program should either follow this command\nwith ISSUE RECEIVE commands to get the resulting inbound data, or terminate the transaction to allow\nCICS to start a new transaction to process the data.\nOptions\nDESTID(data-value)\nspecifies the name (1–8 characters) of the data set in the outboard destination.\nDESTIDLENG(data-value)\nspecifies the length (halfword binary value) of the name specified in the DESTID option.\nVOLUME(data-value)\nspecifies the name (1–6 characters) of a diskette in an outboard destination that contains the data set\nspecified in the DESTID option.\nVOLUMELENG(data-value)\nspecifies the length (halfword binary value) of the name specified in the VOLUME option.\nConditions\n48 FUNCERR\noccurs if there is an error during execution of the command. Destination selection is unaffected and\nother commands for the same destination may be successful.\nDefault action: terminate the task abnormally.\n16 INVREQ\nRESP2 values:\n200\nA distributed program link server application specified the function-shipping session (its principal\nfacility) on the CONVID option.\nChapter 2. CICS command summary  291"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "TITLE statement\nThis statement specifies that a title (header) should be printed at the top of each ", "output": "TITLE statement\nThis statement specifies that a title (header) should be printed at the top of each page of the source\nlisting.\nUSE statement\nThe USE statement provides declaratives to specify these elements:\n• Error-handling procedures: EXCEPTION/ERROR\n• Debugging lines and sections: DEBUGGING\nRelated tasks   \n“Changing the header of a source listing” on page 5  \n“Specifying compiler options under z/OS” on page 287  \n“Specifying compiler options under z/OS UNIX” on page 298  \n“Setting environment variables under z/OS UNIX” on page 297  \n“Eliminating repetitive coding” on page 812\nRelated references   \n“cob2 syntax and options” on page 301\nCALLINTERFACE (Enterprise COBOL for z/OS Language Reference)\nDEFINE (Enterprise COBOL for z/OS Language Reference)\nEVALUATE (Enterprise COBOL for z/OS Language Reference)\nIF (Enterprise COBOL for z/OS Language Reference)\nINLINE (Enterprise COBOL for z/OS Language Reference)\nCOPY statement (Enterprise COBOL for z/OS Language Reference)\n462  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "Explain this COBOL concept", "input": "Method overloading, overriding, and hiding\nCOBOL methods can be overloaded, overridden, or hidden, based on the rules of the Java language.\nMethod overloading\nMethod names that are defined for a class are not required to be unique. (The set of methods defined\nfor a class includes the methods introduced by the class definition and the methods inherited from\nparent classes.)\nMethod names defined for a class must have unique signatures. Two methods defined for a class and\nthat have the same name but different signatures are said to be overloaded.\nThe type of the method return value, if any, is not included in the method signature.\nA class must not define two methods with the same signature but different return value types, or with\nthe same signature but where one method specifies a return value and the other does not.\nThe rules for overloaded method definitions and resolution of overloaded method invocations are\nbased on the corresponding rules for Java.\nMethod overriding (for instance methods)\nAn instance method in a subclass overrides an instance method with the same name that is inherited\nfrom a parent class if the two methods have the same signature.\nWhen a method overrides an instance method defined in a parent class, the presence or absence of a\nmethod return value (the PROCEDURE DIVISION RETURNING data-name) must be consistent in the\ntwo methods. Further, when method return values are specified, the return values in the overridden\nmethod and the overriding method must have identical data types.\nAn instance method must not override a factory method in a COBOL parent class, or a static method in\na Java parent class.\nMethod hiding (for factory methods)\nA factory method is said to hide any and all methods with the same signature in the superclasses of\nthe method definition that would otherwise be accessible. A factory method must not hide an instance\nmethod.\n114  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "Method overloading, overriding, and hiding\nCOBOL methods can be overloaded, overridden, or hidden, based on the rules of the Java language.\nMethod overloading\nMethod names that are defined for a class are not required to be unique. (The set of methods defined\nfor a class includes the methods introduced by the class definition and the methods inherited from\nparent classes.)\nMethod names defined for a class must have unique signatures. Two methods defined for a class and\nthat have the same name but different signatures are said to be overloaded.\nThe type of the method return value, if any, is not included in the method signature.\nA class must not define two methods with the same signature but different return value types, or with\nthe same signature but where one method specifies a return value and the other does not.\nThe rules for overloaded method definitions and resolution of overloaded method invocations are\nbased on the corresponding rules for Java.\nMethod overriding (for instance methods)\nAn instance method in a subclass overrides an instance method with the same name that is inherited\nfrom a parent class if the two methods have the same signature.\nWhen a method overrides an instance method defined in a parent class, the presence or absence of a\nmethod return value (the PROCEDURE DIVISION RETURNING data-name) must be consistent in the\ntwo methods. Further, when method return values are specified, the return values in the overridden\nmethod and the overriding method must have identical data types.\nAn instance method must not override a factory method in a COBOL parent class, or a static method in\na Java parent class.\nMethod hiding (for factory methods)\nA factory method is said to hide any and all methods with the same signature in the superclasses of\nthe method definition that would otherwise be accessible. A factory method must not hide an instance\nmethod.\n114  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "Summarize this COBOL documentation section", "input": "• Use the RECORD CONTAINS integer clause (format-1 RECORD clause) to indicate the length of the\nrecord in bytes.\nWhen you use this clause, the file is always fixed format with record length integer even if there are\nmultiple level-01 record description entries with different lengths associated with the file.\n• Omit the RECORD CONTAINS integer clause, but code the same fixed size and no OCCURS DEPENDING\nON clause for all level-01 record description entries associated with the file. This fixed size is the record\nlength.\nIn an unblocked format-F file, the logical record is the same as the block.\nIn a blocked format-F file, the number of logical records in a block (the blocking factor) is constant for\nevery block in the file except the last block, which might be shorter.\nFiles in the z/OS UNIX file system are never blocked.\nRelated concepts   \n“Logical records” on page 174 \nRelated tasks   \n“Requesting variable-length format” on page 176  \n“Requesting spanned format” on page 177  \n“Requesting undefined format” on page 179  \n“Establishing record formats” on page 174 \nRelated references   \n“Layout of format-F records” on page 175 \nLayout of format-F records\nThe layout of format-F QSAM records is shown below.\nRelated concepts   \n“Logical records” on page 174 \nRelated tasks   \n“Requesting fixed-length\nformat” on page 174  \nz/OS DFSMS: Using Data Sets (Fixed-length record formats)\nRelated references   \n“Layout of format-V records” on page 177  \n“Layout of format-S records” on page 179  \n“Layout of format-U\nrecords” on page 180 \nChapter 9. Processing QSAM files  175", "output": "• Use the RECORD CONTAINS integer clause (format-1 RECORD clause) to indicate the length of the\nrecord in bytes.\nWhen you use this clause, the file is always fixed format with record length integer even if there are\nmultiple level-01 record description entries with different lengths associated with the file.\n• Omit the RECORD CONTAINS integer clause, but code the same fixed size and no OCCURS DEPENDING\nON clause for all level-01 record description entries associated with the file. This fixed size is the record\nlength.\nIn an unblocked format-F file, the logical record is the same as the block.\nIn a blocked format-F file, the number of logical records in a block (the blocking factor) is constant for\nevery block in the file except the last block, which might be shorter.\nFiles in the z/OS UNIX file system are never blocked.\nRelated concepts   \n“Logical records” on page 174 \nRelated tasks   \n“Requesting variable-length format” on page 176  \n“Requesting spanned format” on page 177  \n“Requesting undefined format” on page 179  \n“Establishing record formats” on page 174 \nRelated references   \n“Layout of format-F records” on page 175 \nLayout of format-F records\nThe layout of format-F QSAM records is shown below.\nRelated concepts   \n“Logical records” on page 174 \nRelated tasks   \n“Requesting fixed-length\nformat” on page 174  \nz/OS DFSMS: Using Data Sets (Fixed-length record formats)\nRelated references   \n“Layout of format-V records” on page 177  \n“Layout of format-S records” on page 179  \n“Layout of format-U\nrecords” on page 180 \nChapter 9. Processing QSAM files  175"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "BIF DEEDIT\nBIF DEEDIT\nFIELD( data-area )\nLENGTH( data-value )\nCondition: LENGERR\nThis command is thr", "output": "BIF DEEDIT\nBIF DEEDIT\nFIELD( data-area )\nLENGTH( data-value )\nCondition: LENGERR\nThis command is threadsafe.\n \nDescription\nBIF DEEDIT provides the built-in function DEEDIT. It specifies that alphabetic and special characters are\nremoved from an EBCDIC data field, and the remaining digits right-aligned and padded to the left with\nzeros as necessary.\nIf the field ends with a minus sign or a carriage-return (CR), a negative zone (X'D') is placed in the\nrightmost (low-order) byte.\nIf the zone portion of the rightmost byte contains one of the characters X'A' through X'F', and the\nnumeric portion contains one of the hexadecimal digits X'0' through X'9', the rightmost byte is returned\nunaltered (see the example). This permits the application program to operate on a zoned numeric field.\nThe returned value is in the field that initially contained the unedited data.\nA 1-byte field is returned unaltered, no matter what the field contains.\nOptions\nFIELD(data-area)\nThis option specifies the field to be edited.\nLENGTH(data-value)\nThis option specifies the field length in bytes.\nConditions\n22 LENGERR\nThis condition occurs if the LENGTH value is less than 1.\nDefault action: terminate the task abnormally.\nExamples\nEXEC CICS BIF DEEDIT\n     FIELD(CONTG)\n     LENGTH(9)\nThis removes all characters other than digits from CONTG, a 9 byte field, and returns the edited result in\nthat field to the application program.\nTwo examples of the contents of CONTG before and after execution of the command are:\nOriginal value      Returned value\n14-6704/B             00146704B\n$25.68                000002568\nA decimal point is an EBCDIC special character and as such is removed.\n56  CICS TS for z/OS: API Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Format 2: data-pointer relation condition\nADDRESS OF\nidentifier-1\nidentifier-2\nNULL\nNULLS\nIS\nNOT\nEQU", "output": "Format 2: data-pointer relation condition\nADDRESS OF\nidentifier-1\nidentifier-2\nNULL\nNULLS\nIS\nNOT\nEQUAL\nTO\n = \nADDRESS OF\nidentifier-3\nidentifier-4\nNULL\nNULLS\nidentifier-1 , identifier-3\nCan specify any level item defined in the LINKAGE SECTION, except 66 and 88.\nidentifier-2 , identifier-4\nMust be described as USAGE POINTER.\nNULL, NULLS\nCan be used only if the other operand is defined as USAGE POINTER. That is, NULL=NULL is not\nallowed.\nThe following table summarizes the permissible comparisons for USAGE POINTER, NULL, and ADDRESS\nOF.\nTable 26. Permissible comparisons for USAGE POINTER, NULL, and ADDRESS OF\n Permissible\ncomparisons\nUSAGE POINTER\nsecond operand \nADDRESS OF\nsecond operand \nNULL or NULLS\nsecond operand \nUSAGE POINTER\nfirst operand\nYes\nYes\nYes\nADDRESS OF\nfirst operand\nYes\nYes\nYes\nNULL/NULLS\nfirst operand\nYes\nYes\nNo\nYes\nComparison allowed only for EQUAL, NOT EQUAL\nNo\nNo comparison allowed\nProcedure-pointer and function-pointer relation conditions\nOnly EQUAL and NOT EQUAL are allowed as relational operators when specifying procedure-pointer or\nfunction-pointer data items in a relation condition.\nProcedure-pointer data items are defined explicitly as USAGE PROCEDURE-POINTER. Function-pointer\ndata items are defined explicitly as USAGE FUNCTION-POINTER.\nChapter 27. Procedure division structure  287"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "27\nInvalid session token.\n124 TIMEDOUT\n156\nTimeout on socket send.\n112 TOKENERR\nRESP2 values are:\n47", "output": "27\nInvalid session token.\n124 TIMEDOUT\n156\nTimeout on socket send.\n112 TOKENERR\nRESP2 values are:\n47\nThe document token specified is invalid or the document has been deleted.\nWEB STARTBROWSE FORMFIELD\nSignal start of HTML form field browse.\nWEB STARTBROWSE FORMFIELD\nWEB\nSTARTBROWSE\nFORMFIELD\n( data-area )\nNAMELENGTH(  data-area )\nCHARACTERSET(  data-value )\nHOSTCODEPAGE(  data-value )\nConditions: INVREQ, LENGERR, NOTFND\nThis command is threadsafe.\nDescription\nWEB STARTBROWSE FORMFIELD signals the start of a browse of a set of name and value pairs in an HTML\nform that is part of the body of an HTTP request being processed by the current CICS task.\nOptions\nCHARACTERSET(name)\nspecifies the 40–character name of the character set that is required for encoding the form data. This\noption should match the forms encoding determined by the corresponding HTML form (see How the\nclient encoding is determined for more information). CICS does not support all the character sets\nnamed by IANA. HTML coded character sets lists the IANA character sets that are supported by CICS\nfor code page conversion.\nCLNTCODEPAGE(name)\nThis option is supported for upgrade purposes only. CHARACTERSET replaces it. The action taken by\nCICS is the same for both keywords.\nFORMFIELD(data-area)\nis the keyword that initiates the STARTBROWSE FORMFIELD command. You can optionally specify the\nname of the form field at which browsing is to start, by specifying this in a data-area, followed by the\nNAMELENGTH option, for example,\nWEB STARTBROWSE FORMFIELD(name) NAMELENGTH(len)\nThe name is a string of text containing the name of the requested field. If a name is not specified,\nbrowsing starts at the first name and value pair in the HTML form.\nHOSTCODEPAGE(name)\nspecifies the 8–character name of the CICS (host) code page required by the application program, into\nwhich the form data is to be converted. This code page is normally an EBCDIC code page.\n662  CICS TS for z/OS: API Reference"}
{"instruction": "What are the compiler rules or directives for this?", "input": "must appear before the PROCEDURE DIVISION header for the outermost", "output": "must appear before the PROCEDURE DIVISION header for the outermost"}
{"instruction": "What is API Reference\n\n\nThis option is required when the WSACONTEXT BUILD command is used by a web service requester\napplication and in COBOL?", "input": "", "output": "API Reference\n\n\nThis option is required when the WSACONTEXT BUILD command is used by a web service requester\napplication and is channel name used by subsequent INVOKE SERVICE commands"}
{"instruction": "Summarize this COBOL documentation section", "input": "Table 66. Signature information bytes (continued)\nOffset\nin\ndecim\nal\nSignatur\ne byte\nBit\nItem\nOn\nOff\n18\n11\n1\nEND-PERFORM\n2\nENTER\n3\nENTRY\n4\nEXIT\n5\nEXEC\n6\nGO TO\n7\nIF\n19\n12\n0\nINITIALIZE\n1\nINVOKE\n2\nINSPECT\n3\nMERGE\n4\nMOVE\n5\nMULTIPLY\n6\nOPEN\n7\nPERFORM\n20\n13\n0\nREAD\n2\nRELEASE\n3\nRETURN\n4\nREWRITE\n5\nSEARCH\n7\nSET\n21\n14\n0\nSORT\n1\nSTART\n2\nSTOP\n3\nSTRING\n4\nSUBTRACT\n7\nUNSTRING\nChapter 22. Debugging  495", "output": "Table 66. Signature information bytes (continued)\nOffset\nin\ndecim\nal\nSignatur\ne byte\nBit\nItem\nOn\nOff\n18\n11\n1\nEND-PERFORM\n2\nENTER\n3\nENTRY\n4\nEXIT\n5\nEXEC\n6\nGO TO\n7\nIF\n19\n12\n0\nINITIALIZE\n1\nINVOKE\n2\nINSPECT\n3\nMERGE\n4\nMOVE\n5\nMULTIPLY\n6\nOPEN\n7\nPERFORM\n20\n13\n0\nREAD\n2\nRELEASE\n3\nRETURN\n4\nREWRITE\n5\nSEARCH\n7\nSET\n21\n14\n0\nSORT\n1\nSTART\n2\nSTOP\n3\nSTRING\n4\nSUBTRACT\n7\nUNSTRING\nChapter 22. Debugging  495"}
{"instruction": "What is NUMBER in COBOL?", "input": "", "output": "NUMBER is value in the range 1–240, specifying a starting line number"}
{"instruction": "Explain this COBOL concept", "input": "PRTEXIT parameters\nThe compiler uses 10 parameters, passed by reference, to communicate with the exit module. The return\ncode, data length, and data buffer parameters are set by the exit module for return to the compiler; the\nother items are passed from the compiler to the exit module.\nTable 122. PRTEXIT parameters\nParameter\nnumber\nParameter item\nDescription of item\n1\nUser-exit type\nHalfword that identifies which user exit is to perform the\noperation.\n3=PRTEXIT\n2\nOperation code\nHalfword that indicates the type of operation:\n• 0=OPEN\n• 1=CLOSE\n• 3=PUT\n3\nReturn code\nFullword, set by the exit module, that indicates the success of\nthe requested operation:\n• 0=Operation was successful\n• 12=Operation failed\n4\nUser-exit work area\nSix-fullword work area provided by the compiler for use by the\nuser-exit module.\nThird word: for use by PRTEXIT\n5\nData length\nFullword that specifies the length of the record being supplied\nby the PUT operation (the compiler sets this value to 133)\n6\nData buffer or str3\nData buffer where the compiler has placed the record to be\nprinted by the PUT operation.\nstr3 applies only to OPEN. The first halfword (on a halfword\nboundary) contains the length of the string, followed by the\nstring.\n7\nNot used\n(Used only by LIBEXIT and MSGEXIT)\n8\nNot used\n(Used only by LIBEXIT)\n9\nNot used\n(Used only by LIBEXIT)\n10\nNot used\n(Used only by LIBEXIT)\nRelated tasks   \n“Using the user-exit work\narea” on page 851 \n“Calling from exit modules” on page 852 \nUsing the EXIT compiler option with CICS, SQL and\nSQLIMS statements \nAppendix E. EXIT compiler option  857", "output": "PRTEXIT parameters\nThe compiler uses 10 parameters, passed by reference, to communicate with the exit module. The return\ncode, data length, and data buffer parameters are set by the exit module for return to the compiler; the\nother items are passed from the compiler to the exit module.\nTable 122. PRTEXIT parameters\nParameter\nnumber\nParameter item\nDescription of item\n1\nUser-exit type\nHalfword that identifies which user exit is to perform the\noperation.\n3=PRTEXIT\n2\nOperation code\nHalfword that indicates the type of operation:\n• 0=OPEN\n• 1=CLOSE\n• 3=PUT\n3\nReturn code\nFullword, set by the exit module, that indicates the success of\nthe requested operation:\n• 0=Operation was successful\n• 12=Operation failed\n4\nUser-exit work area\nSix-fullword work area provided by the compiler for use by the\nuser-exit module.\nThird word: for use by PRTEXIT\n5\nData length\nFullword that specifies the length of the record being supplied\nby the PUT operation (the compiler sets this value to 133)\n6\nData buffer or str3\nData buffer where the compiler has placed the record to be\nprinted by the PUT operation.\nstr3 applies only to OPEN. The first halfword (on a halfword\nboundary) contains the length of the string, followed by the\nstring.\n7\nNot used\n(Used only by LIBEXIT and MSGEXIT)\n8\nNot used\n(Used only by LIBEXIT)\n9\nNot used\n(Used only by LIBEXIT)\n10\nNot used\n(Used only by LIBEXIT)\nRelated tasks   \n“Using the user-exit work\narea” on page 851 \n“Calling from exit modules” on page 852 \nUsing the EXIT compiler option with CICS, SQL and\nSQLIMS statements \nAppendix E. EXIT compiler option  857"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "The data item data-name-8 specifies the VSAM status code, which you define as a 6-byte alphanumeric\n", "output": "The data item data-name-8 specifies the VSAM status code, which you define as a 6-byte alphanumeric\ngroup data item that has three subordinate 2-byte binary fields. The VSAM status code contains\nmeaningful values when the COBOL file status key is not 0.\nYou can define data-name-8 in the WORKING-STORAGE SECTION, as in VSAM-CODE below.\n01 RETURN-STATUS.\n    05 FS-CODE              PIC X(2).\n    05 VSAM-CODE.\n       10 VSAM-R15-RETURN   PIC S9(4) Usage Comp-5.\n       10 VSAM-FUNCTION     PIC S9(4) Usage Comp-5.\n       10 VSAM-FEEDBACK     PIC S9(4) Usage Comp-5.\nEnterprise COBOL uses data-name-8 to pass information supplied by VSAM. In the following example,\nFS-CODE corresponds to data-name-1 and VSAM-CODE corresponds to data-name-8:\n“Example: checking VSAM status codes” on page 263\nRelated references   \nFILE STATUS clause (Enterprise COBOL for z/OS Language Reference)  \nFile status key (Enterprise COBOL for z/OS Language Reference)  \nz/OS DFSMS Macro Instructions for Data Sets (VSAM macro return and\n   reason codes)\nExample: checking VSAM status codes\nThe following example reads an indexed file (starting at the fifth record), checks the file status key after\neach input or output request, and displays the VSAM status codes when the file status key is not zero.\nThis example also illustrates how output from this program might look if the file being processed\ncontained six records.\nIDENTIFICATION DIVISION.\nPROGRAM-ID. EXAMPLE.\nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.\nFILE-CONTROL.\n    SELECT VSAMFILE ASSIGN TO VSAMFILE\n    ORGANIZATION IS INDEXED\n    ACCESS DYNAMIC\n    RECORD KEY IS VSAMFILE-KEY\n    FILE STATUS IS FS-CODE VSAM-CODE.\nDATA DIVISION.\nFILE SECTION.\nFD  VSAMFILE\n    RECORD  30.\n01  VSAMFILE-REC.\n    10 VSAMFILE-KEY             PIC X(6).\n    10 FILLER                   PIC X(24).\nWORKING-STORAGE SECTION.\n01  RETURN-STATUS.\nChapter 14. Handling errors  263"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "FREE (MRO)\nFREE\nCONVID(  name )\nSESSION(  name )\nSTATE(  cvda)\nConditions: INVREQ, NOTALLOC\nDescript", "output": "FREE (MRO)\nFREE\nCONVID(  name )\nSESSION(  name )\nSTATE(  cvda)\nConditions: INVREQ, NOTALLOC\nDescription\nFREE returns an MRO session to CICS when a transaction that owns it no longer requires it. The session\ncan then be allocated for use by other transactions.\nIf you omit both CONVID and SESSION, the principal facility is freed. Facilities not freed explicitly are\nfreed by CICS when the task terminates.\nIf you are running EDF, and the transaction frees the principal facility, EDF is terminated.\nOptions\nCONVID(name)\nIdentifies the MRO session to be freed. The 4-character name identifies either the token returned by\na previously executed ALLOCATE command in EIBRSRCE in the EIB, or the token representing the\nprincipal session (returned by a previously executed ASSIGN command).\nSESSION(name)\nSpecifies the symbolic identifier (1–4 characters) of a session TCTTE. This option specifies the\nalternate facility to be used.\nSTATE(cvda)\nGets the state of the current conversation. The STATE on a FREE command returns a cvda code of 00 if\nthere is no longer an active conversation. The other output cvda values are:\n• ALLOCATED \n• FREE \n• PENDFREE \n• RECEIVE \n• ROLLBACK \n• SEND \n• SYNCFREE \n• SYNCRECEIVE \n• SYNCSEND \nConditions\n16 INVREQ\nOccurs in any one of the following situations:\n• The session specified in the command was allocated for a basic (unmapped) APPC conversation\n• The session is in the wrong state to be freed.\nSee also EIBRCODE in EIB fields.\nDefault action: terminate the task abnormally.\n61 NOTALLOC\noccurs if the session specified in the command is not owned by the application.\nDefault action: terminate the task abnormally.\n192  CICS TS for z/OS: API Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Chapter 4. CICS-value data areas used by all\ncommands\nThe CICS-value data-area (CVDA) values and the", "output": "Chapter 4. CICS-value data areas used by all\ncommands\nThe CICS-value data-area (CVDA) values and their numeric equivalents for all of the EXEC CICS\ncommands.\nCVDAs are described in CICS-value data areas (CVDAs).\nCVDAs and numeric values in alphabetic sequence\nCVDA\nValue\nABEND\n900\nACQFAIL\n515\nACQUIRED\n69\nACQUIRING\n71\nACTIVE\n181\nACTIVITY\n1002\nADD\n291\nADDABLE\n41\nADDFAIL\n519\nADDRESS\n859\nADVANCE\n265\nAINIT\n282\nALARM\n501\nALL\n856\nALLCONN\n169\nALLOCATD\n81\nALLQUERY\n431\nALLVALUES\n860\nALTERABLE\n52\nALTERNATE\n197\nALTPRTCOPY\n446\nANALYZER\n1126\nAND\n1005\nANY\n158\nAPLKYBD\n391\nAPLTEXT\n393\nAPPC\n124\n© Copyright IBM Corp. 1974, 2023\n707"}
{"instruction": "What is BLKSET in COBOL?", "input": "", "output": "BLKSET is default when invoking DFSORT.\n– Tape device is used for intermediate work storage.\n– L5 is used in the RECORD statement of DFSORT OPTION control"}
{"instruction": "Explain this COBOL concept", "input": "Table 137. SYSADATA token record (continued)\nField\nSize\nDescription\n \n \n1211\nFACTORY\n1212\nOBJECT\n1213\nFUNCTION-ID\n2020\nTRACE\n2046\nSUPPRESS\n3000\nDATADEF\n3001\nF-NAME\n3002\nUPSI-SWITCH\n3003\nCONDNAME\n3004\nCONDVAR\n3005\nBLOB\n3006\nCLOB\n3007\nDBCLOB\n3008\nBLOB-LOCATOR\n3009\nCLOB-LOCATOR\n3010\nDBCLOB-LOCATOR\n3011\nBLOB-FILE\n3012\nCLOB-FILE\n3013\nDBCLOB-FILE\n3014\nDFHRESP\n948  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "Table 137. SYSADATA token record (continued)\nField\nSize\nDescription\n \n \n1211\nFACTORY\n1212\nOBJECT\n1213\nFUNCTION-ID\n2020\nTRACE\n2046\nSUPPRESS\n3000\nDATADEF\n3001\nF-NAME\n3002\nUPSI-SWITCH\n3003\nCONDNAME\n3004\nCONDVAR\n3005\nBLOB\n3006\nCLOB\n3007\nDBCLOB\n3008\nBLOB-LOCATOR\n3009\nCLOB-LOCATOR\n3010\nDBCLOB-LOCATOR\n3011\nBLOB-FILE\n3012\nCLOB-FILE\n3013\nDBCLOB-FILE\n3014\nDFHRESP\n948  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What are the compiler rules or directives for this?", "input": "is in effect, its value is UX'22'. If the APOST compiler option is in effect, its value is", "output": "is in effect, its value is UX'22'. If the APOST compiler option is in effect, its value is"}
{"instruction": "Explain this COBOL concept", "input": "standard to allow successful parsing of the web headers (this includes all SBCS CECP and Euro code\npages). Otherwise, CICS returns the data in the default EBCDIC code page 037 instead.\nNAMELENGTH(data-value)\nSpecifies the length, as a fullword binary value, of the query parameter name.\nSET(ptr-ref)\nSpecifies a pointer reference that is to be set to the address of data received.\nVALUE(data-area)\nSpecifies the buffer to contain the value of the named query parameter. CICS unescapes any escaped\ncharacters before placing them in the buffer.\nVALUELENGTH(data-area)\nSpecifies the length, as a fullword binary value, of the query parameter value. The real length of\nthe value is returned in this data area. If you specify the VALUE option, VALUELENGTH specifies the\nmaximum length of the data that the program accepts. If the value exceeds the length of the buffer,\nthe value is truncated. If the length of the query parameter value is less than the size of the buffer, the\nquery parameter value is placed in the leftmost byte positions.\nConditions\n16 INVREQ\nRESP2 values are:\n1\nThe command is being issued in a non-CICS Web support application.\n3\nThe command is being issued for a non-HTTP request.\n12\nThe host code page cannot be found.\n13\nNo keyword parameters were supplied in the HTTP request.\n14\nThe code page combination for client and server is invalid.\n17\nInvalid keyword parameters found in the HTTP request.\n22 LENGERR\nRESP2 values are:\n1\nThe length in NAMELENGTH or VALUELENGTH is less than or equal to zero.\n5\nThe keyword parameter value has been truncated during a read operation because the receiving\nbuffer is too small.\n13 NOTFND\nRESP2 value is:\n1\nThe keyword parameter with the given name could not be found.\n626  CICS TS for z/OS: API Reference", "output": "standard to allow successful parsing of the web headers (this includes all SBCS CECP and Euro code\npages). Otherwise, CICS returns the data in the default EBCDIC code page 037 instead.\nNAMELENGTH(data-value)\nSpecifies the length, as a fullword binary value, of the query parameter name.\nSET(ptr-ref)\nSpecifies a pointer reference that is to be set to the address of data received.\nVALUE(data-area)\nSpecifies the buffer to contain the value of the named query parameter. CICS unescapes any escaped\ncharacters before placing them in the buffer.\nVALUELENGTH(data-area)\nSpecifies the length, as a fullword binary value, of the query parameter value. The real length of\nthe value is returned in this data area. If you specify the VALUE option, VALUELENGTH specifies the\nmaximum length of the data that the program accepts. If the value exceeds the length of the buffer,\nthe value is truncated. If the length of the query parameter value is less than the size of the buffer, the\nquery parameter value is placed in the leftmost byte positions.\nConditions\n16 INVREQ\nRESP2 values are:\n1\nThe command is being issued in a non-CICS Web support application.\n3\nThe command is being issued for a non-HTTP request.\n12\nThe host code page cannot be found.\n13\nNo keyword parameters were supplied in the HTTP request.\n14\nThe code page combination for client and server is invalid.\n17\nInvalid keyword parameters found in the HTTP request.\n22 LENGERR\nRESP2 values are:\n1\nThe length in NAMELENGTH or VALUELENGTH is less than or equal to zero.\n5\nThe keyword parameter value has been truncated during a read operation because the receiving\nbuffer is too small.\n13 NOTFND\nRESP2 value is:\n1\nThe keyword parameter with the given name could not be found.\n626  CICS TS for z/OS: API Reference"}
{"instruction": "Summarize this COBOL documentation section", "input": "• The RESTART parameter has been added to the JOB statement, and indicates that restart is to begin\nwith the first step at the checkpoint entry named C0000002.\n• The DD statement DDCKPNT was originally assigned a conditional disposition of CATLG for the\ncheckpoint data set:\n– If the step terminated normally in the previous run of the job, the data set was kept. In that case,\nthe SYSCHK DD statement must contain all of the information necessary for retrieving the checkpoint\ndata set.\n– If the job abnormally terminated, the data set was cataloged. In that case, the only parameters\nrequired on the SYSCHK DD statement are DSNAME and DISP as shown.\nIf a checkpoint is taken in a job that is running when V=R is specified, the job cannot be restarted until\nadequate nonpageable dynamic storage becomes available.\n790  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "• The RESTART parameter has been added to the JOB statement, and indicates that restart is to begin\nwith the first step at the checkpoint entry named C0000002.\n• The DD statement DDCKPNT was originally assigned a conditional disposition of CATLG for the\ncheckpoint data set:\n– If the step terminated normally in the previous run of the job, the data set was kept. In that case,\nthe SYSCHK DD statement must contain all of the information necessary for retrieving the checkpoint\ndata set.\n– If the job abnormally terminated, the data set was cataloged. In that case, the only parameters\nrequired on the SYSCHK DD statement are DSNAME and DISP as shown.\nIf a checkpoint is taken in a job that is running when V=R is specified, the job cannot be restarted until\nadequate nonpageable dynamic storage becomes available.\n790  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What is if it in COBOL?", "input": "", "output": "if it is user-name of one of the\nfollowing types:\n• Data entry\n• Identifier\n• File-name\n• Index-name\n• Procedure-name\n• Condition-name\n• Mnemonic-name\nThis value corresponds to the Symbol ID in a Symbol (Type 42)\nrecord, except for procedure-names where it corresponds to the\nParagraph ID"}
{"instruction": "Explain this COBOL concept", "input": "9\nThere are no more sub-events to retrieve.\n10\nThe composite event contains no sub-events (it is empty).\n111 EVENTERR\nRESP2 values:\n4\nThe event specified on the EVENT option is not recognized by BTS.\n16 INVREQ\nRESP2 values:\n1\nThe command was issued outside the scope of an activity.\n2\nThe event specified on the EVENT option is invalid. It is not a composite event.\nRETURN\nReturn program control.\nRETURN\nRETURN\nTRANSID(  name )\nCOMMAREA(  data-area )\nLENGTH( data-value )\nCHANNEL(  name )\nIMMEDIATE\nINPUTMSG(  data-area )\nINPUTMSGLEN(  data-value )\nENDACTIVITY\nConditions: CHANNELERR, INVREQ, LENGERR\nThis command is threadsafe.\n \n \nDescription\nRETURN returns control from an application program either to an application program at the next higher\nlogical level, or to CICS.\nWhen returning a communications area (COMMAREA), the LENGTH option specifies the length of the data\nto be passed. The LENGTH value being passed must not be greater than the length of the data area\nspecified in the COMMAREA option. If it is, the results are unpredictable and may result in a LENGERR\ncondition, as described in the section about passing data to other programs in Passing data to other\nprograms.\nThe valid range for the COMMAREA length is 0 through 32 763 bytes. If the length provided is outside this\nrange, the LENGERR condition occurs.\nThe COMMAREA, IMMEDIATE, and CHANNEL options can be used only when the RETURN command is\nreturning control to CICS; otherwise, the INVREQ condition occurs.\n426  CICS TS for z/OS: API Reference", "output": "9\nThere are no more sub-events to retrieve.\n10\nThe composite event contains no sub-events (it is empty).\n111 EVENTERR\nRESP2 values:\n4\nThe event specified on the EVENT option is not recognized by BTS.\n16 INVREQ\nRESP2 values:\n1\nThe command was issued outside the scope of an activity.\n2\nThe event specified on the EVENT option is invalid. It is not a composite event.\nRETURN\nReturn program control.\nRETURN\nRETURN\nTRANSID(  name )\nCOMMAREA(  data-area )\nLENGTH( data-value )\nCHANNEL(  name )\nIMMEDIATE\nINPUTMSG(  data-area )\nINPUTMSGLEN(  data-value )\nENDACTIVITY\nConditions: CHANNELERR, INVREQ, LENGERR\nThis command is threadsafe.\n \n \nDescription\nRETURN returns control from an application program either to an application program at the next higher\nlogical level, or to CICS.\nWhen returning a communications area (COMMAREA), the LENGTH option specifies the length of the data\nto be passed. The LENGTH value being passed must not be greater than the length of the data area\nspecified in the COMMAREA option. If it is, the results are unpredictable and may result in a LENGERR\ncondition, as described in the section about passing data to other programs in Passing data to other\nprograms.\nThe valid range for the COMMAREA length is 0 through 32 763 bytes. If the length provided is outside this\nrange, the LENGERR condition occurs.\nThe COMMAREA, IMMEDIATE, and CHANNEL options can be used only when the RETURN command is\nreturning control to CICS; otherwise, the INVREQ condition occurs.\n426  CICS TS for z/OS: API Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "001\nThe current value that the server has attempted to return in the VALUE data area has overflowed\n", "output": "001\nThe current value that the server has attempted to return in the VALUE data area has overflowed\ninto the high-order (sign) bit (that is, the value returned is negative).\n002\nThe current value is too large for a fullword data area by only 1 bit. In this case, the overflow value\nis exactly 1.\n003\nThe current value is too large for a fullword data area by a value greater than 1.\nDefault action: terminate the task abnormally.\n72 SUPPRESSED\nRESP2 values:\n101\nThe maximum value for the named counter has already been assigned and the counter is in the\n'counter-at-limit' condition. No more counter numbers can be assigned until the named counter\nhas been reset, either by a REWIND command, or by specifying the WRAP option on the GET\ncommand.\n103\nOne of the following:\n• The current value of the named counter is not within the range specified by the COMPAREMAX\nand COMPAREMIN parameters, when both are specified\n• The current value of the named counter is greater than the COMPAREMAX parameter or less than\nthe COMPAREMIN parameter, when only one option is specified.\nDefault action: terminate the task abnormally.\nGETMAIN\nGet main 24-bit or 31-bit storage.\nGETMAIN\nGETMAIN\nSET( ptr-ref )\nFLENGTH(  data-value )\nBELOW\nLENGTH( data-value )\nINITIMG(  data-value )\nSHARED\nNOSUSPEND\nUSERDATAKEY\nCICSDATAKEY\nConditions: LENGERR, NOSTG\nThis command is threadsafe.\nDescription\nGETMAIN gets a main storage area of the size indicated by the FLENGTH option. The address of the area is\nreturned in the pointer reference supplied in the SET option.\nThis command includes the LENGTH option for compatibility purposes only; for programs that run with\ncurrent versions of CICS, use FLENGTH.\n228  CICS TS for z/OS: API Reference"}
{"instruction": "Explain this COBOL concept", "input": "Table 137. SYSADATA token record (continued)\nField\nSize\nDescription\n0741\nAPPLY\n0742\nWRITE-ONLY\n0743\nCOMMON\n0744\nALPHABET\n0745\nPADDING\n0746\nSYMBOLIC\n0747\nSTANDARD-2\n0748\nOVERRIDE\n0750\nPASSWORD\n0751\nXML-SCHEMA\nAppendix G. COBOL SYSADATA file contents  943", "output": "Table 137. SYSADATA token record (continued)\nField\nSize\nDescription\n0741\nAPPLY\n0742\nWRITE-ONLY\n0743\nCOMMON\n0744\nALPHABET\n0745\nPADDING\n0746\nSYMBOLIC\n0747\nSTANDARD-2\n0748\nOVERRIDE\n0750\nPASSWORD\n0751\nXML-SCHEMA\nAppendix G. COBOL SYSADATA file contents  943"}
{"instruction": "What is 13\nThere in COBOL?", "input": "", "output": "13\nThere is unknown return code in ESMRESP from the ESM.\n18\nThe CICS ESM interface is not initialized.\n29\nThe ESM is not responding.\n32\nThe user ID field contains a blank character in an invalid position"}
{"instruction": "Summarize this COBOL documentation section", "input": "UPDATE COUNTER and UPDATE DCOUNTER\nUpdate the current value of a named counter. Use COUNTER for fullword signed counters and DCOUNTER\nfor doubleword unsigned counters.\nUPDATE COUNTER\nUPDATE\nCOUNTER(  name )\nPOOL( name )\nVALUE(  data-value )\nCOMPAREMIN(  data-value )\nCOMPAREMAX(  data-value )\nNOSUSPEND\nConditions: BUSY, INVREQ, SUPPRESSED\nThis command is threadsafe.\nUPDATE DCOUNTER\nUPDATE\nDCOUNTER(  name )\nPOOL( name )\nVALUE(  data-area )\nCOMPAREMIN(  data-area )\nCOMPAREMAX(  data-area )\nNOSUSPEND\nConditions: BUSY, INVREQ, SUPPRESSED\nThis command is threadsafe.\nDescription\nThese counter commands set a new current value for the named counter.\nYou can use the COMPAREMAX and COMPAREMIN options to set a new current value only if it falls within\na specified range, or is above or below a specified value.\nFor information about specifying fullword and doubleword variables on these named counter commands,\nsee “CICS command argument values” on page 2.\nOptions\nCOMPAREMAX(data-value)\nSpecifies, as a fullword signed binary value (or doubleword unsigned binary value for DCOUNTER), a\nvalue to compare with the current value of the named counter, and makes the result of the UPDATE\ncommand conditional on the comparison:\n• If the current value to assign is less than, or equal to, the value specified for the COMPAREMAX\nparameter, the current value is reset and the response is normal.\n• If the current value is greater than the specified value, CICS returns an exception condition.\nNormally, the COMPAREMAX value is greater than the COMPAREMIN value and the current value must\nsatisfy both comparisons (that is, it must be between the two values or equal to one of them).\nYou can specify a COMPAREMAX value that is less than the COMPAREMIN value. In this situation, the\ncurrent value is considered to be in range if it satisfies either the COMPAREMIN or the COMPAREMAX\ncomparison.\n568  CICS TS for z/OS: API Reference", "output": "UPDATE COUNTER and UPDATE DCOUNTER\nUpdate the current value of a named counter. Use COUNTER for fullword signed counters and DCOUNTER\nfor doubleword unsigned counters.\nUPDATE COUNTER\nUPDATE\nCOUNTER(  name )\nPOOL( name )\nVALUE(  data-value )\nCOMPAREMIN(  data-value )\nCOMPAREMAX(  data-value )\nNOSUSPEND\nConditions: BUSY, INVREQ, SUPPRESSED\nThis command is threadsafe.\nUPDATE DCOUNTER\nUPDATE\nDCOUNTER(  name )\nPOOL( name )\nVALUE(  data-area )\nCOMPAREMIN(  data-area )\nCOMPAREMAX(  data-area )\nNOSUSPEND\nConditions: BUSY, INVREQ, SUPPRESSED\nThis command is threadsafe.\nDescription\nThese counter commands set a new current value for the named counter.\nYou can use the COMPAREMAX and COMPAREMIN options to set a new current value only if it falls within\na specified range, or is above or below a specified value.\nFor information about specifying fullword and doubleword variables on these named counter commands,\nsee “CICS command argument values” on page 2.\nOptions\nCOMPAREMAX(data-value)\nSpecifies, as a fullword signed binary value (or doubleword unsigned binary value for DCOUNTER), a\nvalue to compare with the current value of the named counter, and makes the result of the UPDATE\ncommand conditional on the comparison:\n• If the current value to assign is less than, or equal to, the value specified for the COMPAREMAX\nparameter, the current value is reset and the response is normal.\n• If the current value is greater than the specified value, CICS returns an exception condition.\nNormally, the COMPAREMAX value is greater than the COMPAREMIN value and the current value must\nsatisfy both comparisons (that is, it must be between the two values or equal to one of them).\nYou can specify a COMPAREMAX value that is less than the COMPAREMIN value. In this situation, the\ncurrent value is considered to be in range if it satisfies either the COMPAREMIN or the COMPAREMAX\ncomparison.\n568  CICS TS for z/OS: API Reference"}
{"instruction": "What are the compiler rules or directives for this?", "input": "PGMNAME(LONGMIXED) is required.             *\n      *    This means that the Program-Id name has to be a literal     *\n      *  - This program uses COMP-5 data items so that the program     *\n      * ", "output": "PGMNAME(LONGMIXED) is required.             *\n      *    This means that the Program-Id name has to be a literal     *\n      *  - This program uses COMP-5 data items so that the program     *\n      *    can work with any setting of the TRUNC compiler option      *\n      *  - Rather than passing the zstream structure by REFERENCE like *\n      *    most COBOL programs, we pass the ADDRESS OF using the       *\n      *    BY VALUE phrase to avoid high-order bit getting set         *\n      *  - This sample has DISPLAY statements to tell you if it was    *\n      *    successful or not, and they should be removed for production*\n      *  - The binder (linkage editor) needs to have LIBRARY           *\n      *    statements in order to access the functions in the          *\n      *    /usr/lpp/hzc/lib/libzz.a archive file. See the sample       *\n      *    LKED.SYSIN statements below                                 *\n      *                                                                *\n      ******************************************************************\n       Id Division.                                                    \n       Program-id. 'ZLIB'.                                             \n      *                                                                \n       Data Division.                                                 \n       Working-Storage Section.                       \n      **> Memory for tests. 'data' to be compressed   \n       01  zinput   pic X(65536) value x'00'.         \n       01  zoutput  pic X(65536) value x'00'.         \n       01  z.                                         \n      *         next_in  is a  Pointer to zstring     \n           02   next_in         Pointer.              \n           02   avail_in        Pic S9(9)   Comp-5.   \n           02   total_in        Pic S9(9)   Comp-5.   \n      *         next_out is a  Pointer to zstring     \n           02   next_out        Pointer.              \n           02   avail_out       Pic S9(9)   Comp-5.   \n           02   total_out       Pic S9(9)   Comp-5.   \n      *         msg      is a  Pointer to zstring     \n           02   msg             Pointer.              \n           02   state           Pointer.              \n           02   zalloc          Function-pointer.     \n           02   zfree           Function-pointer.     \n           02   opaque          Function-pointer.     \n           02   data_type       Pic S9(9)   Comp-5.   \n           02   adler           Pic S9(9)   Comp-5.   \n           02   reserved        Pic S9(9)   Comp-5.   \n       01  y.                                         \n      *         next_in  is a  Pointer to zstring     \n           02   next_in         Pointer.              \n           02   avail_in        Pic S9(9)   Comp-5.   \n           02   total_in        Pic S9(9)   Comp-5.   \n      *         next_out is a  Pointer to zstring     \n           02   next_out        Pointer.              \n           02   avail_out       Pic S9(9)   Comp-5.   \n           02   total_out       Pic S9(9)   Comp-5.   \n      *         msg      is a  Pointer to zstring     \n           02   msg             Pointer.              \n           02   state           Pointer.              \n© Copyright IBM Corp. 1991, 2025\n791"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Example: qualifying index names in a group type instance\nThis example demonstrates how to uniquely q", "output": "Example: qualifying index names in a group type instance\nThis example demonstrates how to uniquely qualify index names in a program that has multiple\ninstances of a group type that contains a table with index names.\n* type definition\n 01 MYTYPE-T TYPEDEF.\n   03 MYTAB OCCURS 10 TIMES INDEXED BY INX.\n     05 DATA1 PIC X(20).\n     05 DATA2 PIC S9(9) COMP-3.\n* type instance definitions\n 01 GRP1 TYPE MYTYPE-T.\n 01 GRP2 TYPE MYTYPE-T.\n:\n PROCEDURE DIVISION.\n     SET GRP1::INX TO 8  *> INX in GRP1\n     MOVE 'Hello, world 1!' TO\n           GRP1::DATA1(GRP1::INX)\n     SET GRP2::INX TO 4  *> INX in GRP2\n     MOVE 'Hello, world 2!' TO\n           GRP2::DATA1(GRP2::INX)\nRestrictions\nThe following constraints apply to the use of types:\n• Neither a data item whose data description entry contains the TYPEDEF clause nor any subordinate of\nsuch an item may be the object of a RENAMES clause.\n• A data item defined with the TYPEDEF clause cannot serve as the object of a REDEFINES clause.\nHowever, subordinate items within a group type definition can be redefined. In such cases, the\nredefining item is considered as part of the type definition.\n• A group type that includes a table defined with the OCCURS DEPENDING ON clause cannot reference a\ndata item within the same group type as the dependency object.\n• The EXTERNAL, VOLATILE, and RENAMES clauses are not allowed in data description entries that\ninclude the TYPEDEF clause.\n• The following clauses are not allowed in data description entries that include the TYPE clause: BLANK\nWHEN ZERO, DYNAMIC LENGTH, JUSTIFIED, PICTURE, SIGN, SYNCHRONIZED, and USAGE.\nChapter 2. Using data  47"}
{"instruction": "Explain this COBOL concept", "input": "Table 136. SYSADATA parse tree record (continued)\nField\nSize\nDescription\n \n \nFor data description clause type:\n0001\nBLANK WHEN ZERO\n0002\nDATA-NAME OR FILLER\n0003\nJUSTIFIED\n0004\nOCCURS\n0005\nPICTURE\n0006\nREDEFINES\n0007\nRENAMES\n0008\nSIGN\n0009\nSYNCHRONIZED\n0010\nUSAGE\n0011\nVALUE\n0012\nVOLATILE\n0013\nDYNAMIC LENGTH\n0023\nGLOBAL\n0024\nEXTERNAL\n0025\nTYPEDEF\n0026\nTYPE\n906  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "Table 136. SYSADATA parse tree record (continued)\nField\nSize\nDescription\n \n \nFor data description clause type:\n0001\nBLANK WHEN ZERO\n0002\nDATA-NAME OR FILLER\n0003\nJUSTIFIED\n0004\nOCCURS\n0005\nPICTURE\n0006\nREDEFINES\n0007\nRENAMES\n0008\nSIGN\n0009\nSYNCHRONIZED\n0010\nUSAGE\n0011\nVALUE\n0012\nVOLATILE\n0013\nDYNAMIC LENGTH\n0023\nGLOBAL\n0024\nEXTERNAL\n0025\nTYPEDEF\n0026\nTYPE\n906  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What are the compiler rules or directives for this?", "input": "GB 18030 characters that are represented in CCSID 1388.\n• Use national data items to define and process GB 18030 characters that are represented in UTF-16,", "output": "GB 18030 characters that are represented in CCSID 1388.\n• Use national data items to define and process GB 18030 characters that are represented in UTF-16,"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "5\nA CONTAINER specified in the web service binding file could not be located.\n6\nThe specified URIMAP", "output": "5\nA CONTAINER specified in the web service binding file could not be located.\n6\nThe specified URIMAP could not be located.\n124 TIMEDOUT\nRESP2 values:\n1\nAn expected timeout has occurred. When the message exchange pattern specifies an optional\nerror response, and an error response is not returned from the remote web service, the timeout is\nacceptable.\n2\nAn unexpected timeout has occurred. A response was expected from the remote web service, but\nnone was received.\n62\nAn unexpected timeout has occurred on socket receive.\nINVOKE WEBSERVICE\nCall a service from a CICS application. This command is a synonym of the INVOKE SERVICE command\nand is provided for compatibility with existing web service requester applications. Use INVOKE SERVICE\nfor any new web service applications.\nDescription\nFor details of the INVOKE SERVICE command, see “INVOKE SERVICE” on page 263.\nISSUE ABEND\nAbend the mapped conversation with an APPC partner. \nISSUE ABEND (APPC)\nISSUE ABEND\nCONVID(  name )\nSTATE(  cvda)\nConditions: INVREQ, NOTALLOC, TERMERR\n \nDescription\nISSUE ABEND abnormally ends the conversation. The partner transaction sees the TERMERR condition.\nOptions\nCONVID(name)\nidentifies the conversation to be abended. The 4-character name identifies either the symbolic\nidentifier returned by a previously executed ALLOCATE command in EIBRSRCE in the EIB, or the\nsymbolic identifier representing the principal facility (returned by a previously executed ASSIGN\ncommand).\nFor compatibility with earlier releases, SESSION is accepted as a synonym for CONVID. New programs\nshould use CONVID.\nIf both CONVID and SESSION are omitted, the principal facility is assumed.\n268  CICS TS for z/OS: API Reference"}
{"instruction": "Explain this COBOL concept", "input": "Table 28. Combined conditions—permissible element sequences\nCombined\ncondition element\nLeft\nmost\nWhen not leftmost, can be\nimmediately preceded by:\nRight\nmost\nWhen not rightmost, can be\nimmediately followed by:\nsimple-condition\nYes\nOR\nNOT\nAND\n(\nYes\nOR\nAND\n)\nOR\nAND\nNo\nsimple-condition\n)\nNo\nsimple-condition\nNOT\n(\nNOT\nYes\nOR\nAND\n(\nNo\nsimple-condition\n(\n(\nYes\nOR\nNOT\nAND\n(\nNo\nsimple-condition\nNOT\n(\n)\nNo\nsimple-condition\n)\nYes\nOR\nAND\n)\nParentheses are never needed when either ANDs or ORs (but not both) are used exclusively in one\ncombined condition. However, parentheses might be needed to modify the implicit precedence rules to\nmaintain the correct logical relation of operators and operands.\nThere must be a one-to-one correspondence between left and right parentheses, with each left\nparenthesis to the left of its corresponding right parenthesis.\nThe following table illustrates the relationships between logical operators and conditions C1 and C2.\nTable 29. Logical operators and evaluation results of combined conditions\nValue\nfor C1\nValue\nfor C2\nC1\nAND\nC2\nC1 OR\nC2\nNOT\n(C1\nAND\nC2)\nNOT\nC1\nAND\nC2\nNOT\n(C1\nOR\nC2)\nNOT C1\nOR C2\nTrue\nTrue\nTrue\nTrue\nFalse\nFalse\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\nTrue\nTrue\nFalse\nTrue\nTrue\nFalse\nFalse\nTrue\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nTrue\nTrue\nOrder of evaluation of conditions\nParentheses, both explicit and implicit, define the level of inclusiveness within a complex condition. Two\nor more conditions connected by only the logical operators AND or OR at the same level of inclusiveness\nestablish a hierarchical level within a complex condition. Therefore an entire complex condition is\n292  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "Table 28. Combined conditions—permissible element sequences\nCombined\ncondition element\nLeft\nmost\nWhen not leftmost, can be\nimmediately preceded by:\nRight\nmost\nWhen not rightmost, can be\nimmediately followed by:\nsimple-condition\nYes\nOR\nNOT\nAND\n(\nYes\nOR\nAND\n)\nOR\nAND\nNo\nsimple-condition\n)\nNo\nsimple-condition\nNOT\n(\nNOT\nYes\nOR\nAND\n(\nNo\nsimple-condition\n(\n(\nYes\nOR\nNOT\nAND\n(\nNo\nsimple-condition\nNOT\n(\n)\nNo\nsimple-condition\n)\nYes\nOR\nAND\n)\nParentheses are never needed when either ANDs or ORs (but not both) are used exclusively in one\ncombined condition. However, parentheses might be needed to modify the implicit precedence rules to\nmaintain the correct logical relation of operators and operands.\nThere must be a one-to-one correspondence between left and right parentheses, with each left\nparenthesis to the left of its corresponding right parenthesis.\nThe following table illustrates the relationships between logical operators and conditions C1 and C2.\nTable 29. Logical operators and evaluation results of combined conditions\nValue\nfor C1\nValue\nfor C2\nC1\nAND\nC2\nC1 OR\nC2\nNOT\n(C1\nAND\nC2)\nNOT\nC1\nAND\nC2\nNOT\n(C1\nOR\nC2)\nNOT C1\nOR C2\nTrue\nTrue\nTrue\nTrue\nFalse\nFalse\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\nTrue\nTrue\nFalse\nTrue\nTrue\nFalse\nFalse\nTrue\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nTrue\nTrue\nOrder of evaluation of conditions\nParentheses, both explicit and implicit, define the level of inclusiveness within a complex condition. Two\nor more conditions connected by only the logical operators AND or OR at the same level of inclusiveness\nestablish a hierarchical level within a complex condition. Therefore an entire complex condition is\n292  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "Explain this COBOL concept", "input": "Table 106. IGZCD2A return codes (continued)\nReturn code\nExplanation\n1. If a truncation occurs within the DBCS characters, the truncation is on an even-byte boundary and a\nshift-in (SI) is inserted. If necessary, the alphanumeric data is padded with a single-byte space after\nthe shift-in.\nExample: IGZCD2A\nThis example CALL statement converts the DBCS data in dbcs-item to alphanumeric data with double-\nbyte characters. The results of the conversion are placed in alpha-item.\nCALL \"IGZCD2A\" USING BY REFERENCE dbcs-item alpha-item\n    BY CONTENT LENGTH OF dbcs-item LENGTH OF alpha-item\nSuppose the contents of dbcs-item and alpha-item and the lengths before the conversion are:\ndbcs-item  = .A.BD1D2D3.C.D\nalpha-item = ssssssssssss\nLENGTH OF dbcs-item  = 14\nLENGTH OF alpha-item = 12\nThen after the conversion, dbcs-item and alpha-item will contain:\ndbcs-item  = .A.BD1D2D3.C.D\nalpha-item = AB<D1D2D3>CD\nThe content of the RETURN-CODE register is 0.\nRelated references   \n“DBCS notation” on page 829 \nAppendix B. Converting double-byte character set (DBCS) data  833", "output": "Table 106. IGZCD2A return codes (continued)\nReturn code\nExplanation\n1. If a truncation occurs within the DBCS characters, the truncation is on an even-byte boundary and a\nshift-in (SI) is inserted. If necessary, the alphanumeric data is padded with a single-byte space after\nthe shift-in.\nExample: IGZCD2A\nThis example CALL statement converts the DBCS data in dbcs-item to alphanumeric data with double-\nbyte characters. The results of the conversion are placed in alpha-item.\nCALL \"IGZCD2A\" USING BY REFERENCE dbcs-item alpha-item\n    BY CONTENT LENGTH OF dbcs-item LENGTH OF alpha-item\nSuppose the contents of dbcs-item and alpha-item and the lengths before the conversion are:\ndbcs-item  = .A.BD1D2D3.C.D\nalpha-item = ssssssssssss\nLENGTH OF dbcs-item  = 14\nLENGTH OF alpha-item = 12\nThen after the conversion, dbcs-item and alpha-item will contain:\ndbcs-item  = .A.BD1D2D3.C.D\nalpha-item = AB<D1D2D3>CD\nThe content of the RETURN-CODE register is 0.\nRelated references   \n“DBCS notation” on page 829 \nAppendix B. Converting double-byte character set (DBCS) data  833"}
{"instruction": "What is When CICS in COBOL?", "input": "", "output": "When CICS is HTTP server, the message is a request from a Web client"}
{"instruction": "Explain this COBOL concept", "input": "Format 3: WRITE statement for line-sequential files\nWRITE\nrecord-name-1\nFROM\nidentifier-1\nAFTER\nADVANCING\nidentifier-2\ninteger-1\nLINE\nLINES\nPAGE\nEND-WRITE\nrecord-name-1\nMust be defined in a DATA DIVISION FD entry. record-name-1 can be qualified. It must not be\nassociated with a sort or merge file.\nFor relative files, the number of character positions in the record being written can be different from\nthe number of character positions in the record being replaced.\nFROM phrase\nThe result of the execution of the WRITE statement with the FROM identifier-1 phrase is equivalent to\nthe execution of the following statements in the order specified:\nMOVE identifier-1 TO record-name-1.\nWRITE record-name-1. \nThe MOVE is performed according to the rules for a MOVE statement without the CORRESPONDING\nphrase.\nidentifier-1\nidentifier-1 can reference any of the following items:\n• A data item defined in the WORKING-STORAGE SECTION, the LOCAL-STORAGE SECTION, or the\nLINKAGE SECTION\n• A record description for another previously opened file\n• An alphanumeric function\n• A national function\nidentifier-1 must be a valid sending item for a MOVE statement with record-name-1 as the receiving\nitem.\nidentifier-1 and record-name-1 must not refer to the same storage area.\nAfter the WRITE statement is executed, the information is still available in identifier-1. (See “INTO and\nFROM phrases” on page 311 under Common processing facilities.)\nidentifier-2\nMust be an integer data item.\nADVANCING phrase\nThe ADVANCING phrase controls positioning of the output record on the page.\nChapter 28. PROCEDURE DIVISION statements  483", "output": "Format 3: WRITE statement for line-sequential files\nWRITE\nrecord-name-1\nFROM\nidentifier-1\nAFTER\nADVANCING\nidentifier-2\ninteger-1\nLINE\nLINES\nPAGE\nEND-WRITE\nrecord-name-1\nMust be defined in a DATA DIVISION FD entry. record-name-1 can be qualified. It must not be\nassociated with a sort or merge file.\nFor relative files, the number of character positions in the record being written can be different from\nthe number of character positions in the record being replaced.\nFROM phrase\nThe result of the execution of the WRITE statement with the FROM identifier-1 phrase is equivalent to\nthe execution of the following statements in the order specified:\nMOVE identifier-1 TO record-name-1.\nWRITE record-name-1. \nThe MOVE is performed according to the rules for a MOVE statement without the CORRESPONDING\nphrase.\nidentifier-1\nidentifier-1 can reference any of the following items:\n• A data item defined in the WORKING-STORAGE SECTION, the LOCAL-STORAGE SECTION, or the\nLINKAGE SECTION\n• A record description for another previously opened file\n• An alphanumeric function\n• A national function\nidentifier-1 must be a valid sending item for a MOVE statement with record-name-1 as the receiving\nitem.\nidentifier-1 and record-name-1 must not refer to the same storage area.\nAfter the WRITE statement is executed, the information is still available in identifier-1. (See “INTO and\nFROM phrases” on page 311 under Common processing facilities.)\nidentifier-2\nMust be an integer data item.\nADVANCING phrase\nThe ADVANCING phrase controls positioning of the output record on the page.\nChapter 28. PROCEDURE DIVISION statements  483"}
{"instruction": "Summarize this COBOL documentation section", "input": "Processing alphanumeric data items that contain DBCS data\nIf you use byte-oriented operations (for example, STRING, UNSTRING, or reference modification) on an\nalphanumeric data item that contains DBCS characters, results are unpredictable. You should instead\nconvert the item to a national data item before you process it.\nThat is, do these steps:\n1. Convert the item to UTF-16 in a national data item by using a MOVE statement or the NATIONAL-OF\nintrinsic function.\n2. Process the national data item as needed.\n3. Convert the result back to an alphanumeric data item by using the DISPLAY-OF intrinsic function.\nRelated tasks   \n“Joining data items (STRING)” on page 109  \n“Splitting data items (UNSTRING)” on page 111  \n“Referring to substrings of data items” on page 115  \n“Converting to or from national (Unicode) representation” on page 140 \n166  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "Processing alphanumeric data items that contain DBCS data\nIf you use byte-oriented operations (for example, STRING, UNSTRING, or reference modification) on an\nalphanumeric data item that contains DBCS characters, results are unpredictable. You should instead\nconvert the item to a national data item before you process it.\nThat is, do these steps:\n1. Convert the item to UTF-16 in a national data item by using a MOVE statement or the NATIONAL-OF\nintrinsic function.\n2. Process the national data item as needed.\n3. Convert the result back to an alphanumeric data item by using the DISPLAY-OF intrinsic function.\nRelated tasks   \n“Joining data items (STRING)” on page 109  \n“Splitting data items (UNSTRING)” on page 111  \n“Referring to substrings of data items” on page 115  \n“Converting to or from national (Unicode) representation” on page 140 \n166  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "Summarize this COBOL documentation section", "input": "EXTRACT CERTIFICATE\nEXTRACT CERTIFICATE(  ptr-ref )\nLENGTH( data-area )\nSERIALNUM(  ptr-ref )\nSERIALNUMLEN(  data-area )\nUSERID( data-area )\nOWNER\nISSUER\nCOMMONNAME(  ptr-ref )\nCOMMONNAMLEN(  data-area )\nCOUNTRY(  ptr-ref )\nCOUNTRYLEN(  data-area )\nSTATE(  ptr-ref )\nSTATELEN(  data-area )\nLOCALITY(  ptr-ref )\nLOCALITYLEN(  data-area )\nORGANIZATION(  ptr-ref )\nORGANIZATLEN(  data-area )\nORGUNIT(  ptr-ref )\nORGUNITLEN(  data-area )\nConditions: INVREQ\nThis command is threadsafe.\n \nDescription\nEXTRACT CERTIFICATE allows the application to obtain information from the X.509 certificate that was\nreceived from a client during a Secure Sockets Layer (SSL) handshake over a TCPIPSERVICE that specified\nSSL(CLIENTAUTH). The certificate contains fields that identify the owner (or subject) of the certificate,\nand fields that identify the certificate authority that issued the certificate. You can select the fields that\nyou require by specifying the OWNER or ISSUER option. You cannot retrieve both OWNER and ISSUER\nfields with one command.\nIf you attempt to extract a certificate and there is no certificate to extract, low or zero values are returned\nfor the pointers.\nOptions\nCERTIFICATE(ptr-ref)\nSpecifies a pointer reference to be set to the address of the full binary certificate received from the\nclient. The pointer reference is valid until the next CICS command or the end of task.\nCOMMONNAME(ptr-ref)\nSpecifies a pointer reference to be set to the common name from the client certificate. The pointer\nreference is valid until the next CICS command or the end of task.\nCOMMONNAMLEN(data-area)\nSpecifies a fullword binary data area to be set to the length of the common name from the client\ncertificate.\nChapter 2. CICS command summary  167", "output": "EXTRACT CERTIFICATE\nEXTRACT CERTIFICATE(  ptr-ref )\nLENGTH( data-area )\nSERIALNUM(  ptr-ref )\nSERIALNUMLEN(  data-area )\nUSERID( data-area )\nOWNER\nISSUER\nCOMMONNAME(  ptr-ref )\nCOMMONNAMLEN(  data-area )\nCOUNTRY(  ptr-ref )\nCOUNTRYLEN(  data-area )\nSTATE(  ptr-ref )\nSTATELEN(  data-area )\nLOCALITY(  ptr-ref )\nLOCALITYLEN(  data-area )\nORGANIZATION(  ptr-ref )\nORGANIZATLEN(  data-area )\nORGUNIT(  ptr-ref )\nORGUNITLEN(  data-area )\nConditions: INVREQ\nThis command is threadsafe.\n \nDescription\nEXTRACT CERTIFICATE allows the application to obtain information from the X.509 certificate that was\nreceived from a client during a Secure Sockets Layer (SSL) handshake over a TCPIPSERVICE that specified\nSSL(CLIENTAUTH). The certificate contains fields that identify the owner (or subject) of the certificate,\nand fields that identify the certificate authority that issued the certificate. You can select the fields that\nyou require by specifying the OWNER or ISSUER option. You cannot retrieve both OWNER and ISSUER\nfields with one command.\nIf you attempt to extract a certificate and there is no certificate to extract, low or zero values are returned\nfor the pointers.\nOptions\nCERTIFICATE(ptr-ref)\nSpecifies a pointer reference to be set to the address of the full binary certificate received from the\nclient. The pointer reference is valid until the next CICS command or the end of task.\nCOMMONNAME(ptr-ref)\nSpecifies a pointer reference to be set to the common name from the client certificate. The pointer\nreference is valid until the next CICS command or the end of task.\nCOMMONNAMLEN(data-area)\nSpecifies a fullword binary data area to be set to the length of the common name from the client\ncertificate.\nChapter 2. CICS command summary  167"}
{"instruction": "Explain this COBOL concept", "input": "– SKIP2\n– SKIP3\n– TITLE\n• Debugging lines, which are source lines that have a D in column 7, if WITH DEBUGGING MODE is not\nspecified\nTable 137. SYSADATA token record\nField\nSize\nDescription\nToken number\nFL4\nThe token number within the source file generated by the compiler,\nstarting at 1. Any copybooks have already been included in the\nsource.\nToken code\nHL2\nThe type of token (user-name, literal, reserved word, and so forth).\nFor reserved words, the compiler reserved-word table values are\nused.\nFor PICTURE strings, the special code 0000 is used.\nFor each piece (other than the last) of a continued token, the\nspecial code 3333 is used.\nOtherwise, the following codes are used:\n0001\nACCEPT\n0002\nADD\n0003\nALTER\n0004\nCALL\n0005\nCANCEL\n0007\nCLOSE\n0009\nCOMPUTE\n0011\nDELETE\n0013\nDISPLAY\n0014\nDIVIDE\n0017\nREADY\n0018\nEND-PERFORM\n0019\nENTER\n0020\nENTRY\n926  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "– SKIP2\n– SKIP3\n– TITLE\n• Debugging lines, which are source lines that have a D in column 7, if WITH DEBUGGING MODE is not\nspecified\nTable 137. SYSADATA token record\nField\nSize\nDescription\nToken number\nFL4\nThe token number within the source file generated by the compiler,\nstarting at 1. Any copybooks have already been included in the\nsource.\nToken code\nHL2\nThe type of token (user-name, literal, reserved word, and so forth).\nFor reserved words, the compiler reserved-word table values are\nused.\nFor PICTURE strings, the special code 0000 is used.\nFor each piece (other than the last) of a continued token, the\nspecial code 3333 is used.\nOtherwise, the following codes are used:\n0001\nACCEPT\n0002\nADD\n0003\nALTER\n0004\nCALL\n0005\nCANCEL\n0007\nCLOSE\n0009\nCOMPUTE\n0011\nDELETE\n0013\nDISPLAY\n0014\nDIVIDE\n0017\nREADY\n0018\nEND-PERFORM\n0019\nENTER\n0020\nENTRY\n926  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "Summarize this COBOL documentation section", "input": "Comparison of commonly used terms\nTo better understand the terms used throughout the IBM z/OS Language Environment and IBM Enterprise\nCOBOL for z/OS information, and to understand which terms are meant to be equivalent, see the following\ntable.\nLanguage Environment term\nEnterprise COBOL equivalent\nAggregate\nGroup item\nArray\nA table created using the OCCURS clause\nArray element\nTable element\nEnclave\nRun unit\nExternal data\nWORKING-STORAGE data defined using the EXTERNAL clause\nLocal data\nAny non-EXTERNAL data item\nPass parameters directly, by value\nBY VALUE\nPass parameters indirectly, by reference\nBY REFERENCE\nPass parameters indirectly, by value\nBY CONTENT\nRoutine\nProgram\nScalar\nElementary item\nHow to read syntax diagrams\nUse the following description to read the syntax diagrams in this information.\n• Read the syntax diagrams from left to right, from top to bottom, following the path of the line.\nThe ►►─── symbol indicates the beginning of a syntax diagram.\nThe ───► symbol indicates that the syntax diagram is continued on the next line.\nThe ►─── symbol indicates that the syntax diagram is continued from the previous line.\nThe ───►◄ symbol indicates the end of a syntax diagram.\nDiagrams of syntactical units other than complete statements start with the ►─── symbol and end with\nthe ───► symbol.\n• Required items appear on the horizontal line (the main path):\nrequired_item\n• Optional items appear below the main path:\nrequired_item\noptional_item\n• If you can choose from two or more items, they appear vertically, in a stack. If you must choose one of\nthe items, one item of the stack appears on the main path:\nPreface  xxxi", "output": "Comparison of commonly used terms\nTo better understand the terms used throughout the IBM z/OS Language Environment and IBM Enterprise\nCOBOL for z/OS information, and to understand which terms are meant to be equivalent, see the following\ntable.\nLanguage Environment term\nEnterprise COBOL equivalent\nAggregate\nGroup item\nArray\nA table created using the OCCURS clause\nArray element\nTable element\nEnclave\nRun unit\nExternal data\nWORKING-STORAGE data defined using the EXTERNAL clause\nLocal data\nAny non-EXTERNAL data item\nPass parameters directly, by value\nBY VALUE\nPass parameters indirectly, by reference\nBY REFERENCE\nPass parameters indirectly, by value\nBY CONTENT\nRoutine\nProgram\nScalar\nElementary item\nHow to read syntax diagrams\nUse the following description to read the syntax diagrams in this information.\n• Read the syntax diagrams from left to right, from top to bottom, following the path of the line.\nThe ►►─── symbol indicates the beginning of a syntax diagram.\nThe ───► symbol indicates that the syntax diagram is continued on the next line.\nThe ►─── symbol indicates that the syntax diagram is continued from the previous line.\nThe ───►◄ symbol indicates the end of a syntax diagram.\nDiagrams of syntactical units other than complete statements start with the ►─── symbol and end with\nthe ───► symbol.\n• Required items appear on the horizontal line (the main path):\nrequired_item\n• Optional items appear below the main path:\nrequired_item\noptional_item\n• If you can choose from two or more items, they appear vertically, in a stack. If you must choose one of\nthe items, one item of the stack appears on the main path:\nPreface  xxxi"}
{"instruction": "Summarize this COBOL documentation section", "input": "Chapter 110. VARIANCE\nThe VARIANCE function returns a numeric value that approximates the variance of its arguments.\nThe function type is numeric.\nFormat\nFUNCTION VARIANCE\n(\nargument-1\n)\nargument-1\nMust be class numeric.\nThe returned value is the approximation of the variance of the argument-1 series.\nThe returned value is defined as the square of the standard deviation of the argument-1 series. This value\nis calculated as follows:\n1. The difference between each argument-1 value and the arithmetic mean of the argument-1 series is\ncalculated and squared.\n2. The values obtained are then added together. This quantity is divided by the number of values in the\nargument series.\nIf the argument-1 series consists of only one value, or if the argument-1 series consists of all variable-\noccurrence data items and the total number of occurrences for all of them is one, the returned value is\nzero.\n© Copyright IBM Corp. 1991, 2025\n687", "output": "Chapter 110. VARIANCE\nThe VARIANCE function returns a numeric value that approximates the variance of its arguments.\nThe function type is numeric.\nFormat\nFUNCTION VARIANCE\n(\nargument-1\n)\nargument-1\nMust be class numeric.\nThe returned value is the approximation of the variance of the argument-1 series.\nThe returned value is defined as the square of the standard deviation of the argument-1 series. This value\nis calculated as follows:\n1. The difference between each argument-1 value and the arithmetic mean of the argument-1 series is\ncalculated and squared.\n2. The values obtained are then added together. This quantity is divided by the number of values in the\nargument series.\nIf the argument-1 series consists of only one value, or if the argument-1 series consists of all variable-\noccurrence data items and the total number of occurrences for all of them is one, the returned value is\nzero.\n© Copyright IBM Corp. 1991, 2025\n687"}
{"instruction": "What is and running OO applications  307\n\n\nRunning OO applications that start with a main method\nIf the first routine of a mixed COBOL and Java application in COBOL?", "input": "", "output": "and running OO applications  307\n\n\nRunning OO applications that start with a main method\nIf the first routine of a mixed COBOL and Java application is main method of a Java class or the main\nfactory method of a COBOL class, run the application by using the java command and by specifying the\nname of the class that contains the main method"}
{"instruction": "Summarize this COBOL documentation section", "input": "Table 134. SYSADATA options record (continued)\nField\nSize\nDescription\nOption byte 2\nXL1\n1... ....\nBit 1 = OFFSET, Bit 0 = NOOFFSET\n.1.. ....\nBit 1 = MAP, Bit 0 = NOMAP\n..1. ....\nBit 1 = LIST, Bit 0 = NOLIST\n...1 ....\nBit 1 = DBCSXREF, Bit 0 = NODBCSXREF\n.... 1...\nBit 1 = XREF(SHORT), Bit 0 = not XREF(SHORT). This\nflag should be used in combination with the flag at bit 7.\nXREF(FULL) is indicated by this flag being off and the flag at\nbit 7 being on.\n.... .1..\nBit 1 = SOURCE, Bit 0 = NOSOURCE\n.... ..1.\nBit 1 = VBREF, Bit 0 = NOVBREF\n.... ...1\nBit 1 = XREF, Bit 0 = not XREF. See also flag at bit 4 above.\nOption byte 3\nXL1\n1... ....\nBit 1 = FLAG imbedded diagnostics level specified (a value y is\nspecified as in FLAG(x,y))\n.1.. ....\nBit 1 = FLAGSTD, Bit 0 = NOFLAGSTD\n..1. ....\nBit 1 = NUM, Bit 0 = NONUM\n...1 ....\nBit 1 = SEQUENCE, Bit 0 = NOSEQUENCE\n.... 1...\nBit 1 = SOSI, Bit 0 = NOSOSI (AIX only)\n.... .1..\nBit 1 = NSYMBOL(NATIONAL), Bit 0 = NSYMBOL(DBCS)\n.... ..1.\nBit 1 = PROFILE, Bit 0 = NOPROFILE (AIX only)\n.... ...1\nBit 1 = WORD, Bit 0 = NOWORD\n886  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "Table 134. SYSADATA options record (continued)\nField\nSize\nDescription\nOption byte 2\nXL1\n1... ....\nBit 1 = OFFSET, Bit 0 = NOOFFSET\n.1.. ....\nBit 1 = MAP, Bit 0 = NOMAP\n..1. ....\nBit 1 = LIST, Bit 0 = NOLIST\n...1 ....\nBit 1 = DBCSXREF, Bit 0 = NODBCSXREF\n.... 1...\nBit 1 = XREF(SHORT), Bit 0 = not XREF(SHORT). This\nflag should be used in combination with the flag at bit 7.\nXREF(FULL) is indicated by this flag being off and the flag at\nbit 7 being on.\n.... .1..\nBit 1 = SOURCE, Bit 0 = NOSOURCE\n.... ..1.\nBit 1 = VBREF, Bit 0 = NOVBREF\n.... ...1\nBit 1 = XREF, Bit 0 = not XREF. See also flag at bit 4 above.\nOption byte 3\nXL1\n1... ....\nBit 1 = FLAG imbedded diagnostics level specified (a value y is\nspecified as in FLAG(x,y))\n.1.. ....\nBit 1 = FLAGSTD, Bit 0 = NOFLAGSTD\n..1. ....\nBit 1 = NUM, Bit 0 = NONUM\n...1 ....\nBit 1 = SEQUENCE, Bit 0 = NOSEQUENCE\n.... 1...\nBit 1 = SOSI, Bit 0 = NOSOSI (AIX only)\n.... .1..\nBit 1 = NSYMBOL(NATIONAL), Bit 0 = NSYMBOL(DBCS)\n.... ..1.\nBit 1 = PROFILE, Bit 0 = NOPROFILE (AIX only)\n.... ...1\nBit 1 = WORD, Bit 0 = NOWORD\n886  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "Summarize this COBOL documentation section", "input": "Chapter 72. MIN\nThe MIN function returns the content of the argument that contains the minimum value.\nThe function type depends on the argument type, as follows:\nArgument type\nFunction type\nAlphabetic\nAlphanumeric\nAlphanumeric\nAlphanumeric\nNational\nNational\nAll arguments integer\n(includes integer arguments of usage NATIONAL)\nInteger\nNumeric (some arguments can be integer)\n(includes numeric arguments of usage NATIONAL)\nNumeric\nFormat\nFUNCTION MIN\n(\nargument-1\n)\nargument-1\nMust be class alphabetic, alphanumeric, national, or numeric.\nAll arguments must be of the same class, except that a combination of alphabetic and alphanumeric\narguments is allowed.\nThe returned value is the content of argument-1 having the least value. The comparisons used to\ndetermine the least value are made according to the rules for simple conditions. For more information,\nsee “Conditional expressions” on page 274.\nIf more than one argument-1 has the same least value, the leftmost argument-1 having that value is\nreturned.\nIf the type of the function is alphanumeric or national, the size of the returned value is the size of the\nselected argument-1.\n© Copyright IBM Corp. 1991, 2025\n609", "output": "Chapter 72. MIN\nThe MIN function returns the content of the argument that contains the minimum value.\nThe function type depends on the argument type, as follows:\nArgument type\nFunction type\nAlphabetic\nAlphanumeric\nAlphanumeric\nAlphanumeric\nNational\nNational\nAll arguments integer\n(includes integer arguments of usage NATIONAL)\nInteger\nNumeric (some arguments can be integer)\n(includes numeric arguments of usage NATIONAL)\nNumeric\nFormat\nFUNCTION MIN\n(\nargument-1\n)\nargument-1\nMust be class alphabetic, alphanumeric, national, or numeric.\nAll arguments must be of the same class, except that a combination of alphabetic and alphanumeric\narguments is allowed.\nThe returned value is the content of argument-1 having the least value. The comparisons used to\ndetermine the least value are made according to the rules for simple conditions. For more information,\nsee “Conditional expressions” on page 274.\nIf more than one argument-1 has the same least value, the leftmost argument-1 having that value is\nreturned.\nIf the type of the function is alphanumeric or national, the size of the returned value is the size of the\nselected argument-1.\n© Copyright IBM Corp. 1991, 2025\n609"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "wherever a literal of the category associated with the name is permitted, including in a defined con", "output": "wherever a literal of the category associated with the name is permitted, including in a defined condition\nand a boolean condition.\n• In the text that follows a DEFINE directive specifying compilation-variable-name-1 with the OFF phrase,\ncompilation-variable-name-1 can be used only in a defined condition, unless compilation-variable-\nname-1 is redefined in a subsequent DEFINE directive without the OFF phrase.\n• If the OVERRIDE phrase is specified, compilation-variable-name-1 is unconditionally set to reference\nthe value of the specified operand.\n• If the AS PARAMETER phrase is specified, the value referenced by compilation-variable-name-1 is\nobtained from a DEFINE option for compilation-variable-name-1, if such an option exists. If there is no\nDEFINE option for compilation-variable-name-1, compilation-variable-name-1 is not defined.\n• If arith-expr-1 is specified, arith-expr-1 is evaluated according to “Compile-time arithmetic\nexpressions” on page 729, and compilation-variable-name-1 references the resultant value.\n• If literal-1 is specified, compilation-variable-name-1 references literal-1.\nRelated references   \n“Defined conditions” on page 729  \n“Predefined compilation variables” on page 730  \nDEFINE (Enterprise COBOL Programming Guide) \nEVALUATE\nThe EVALUATE directive provides a multi-branch method of choosing the source lines to include in a\ncompilation group.\nFormat 1\n>>EVALUATE\nliteral-1\narith-expr-1\n>>WHEN\nliteral-2\narith-expr-2\nTHROUGH\nTHRU\nliteral-3\narith-expr-3\ntext-1\n>>WHEN\nOTHER\ntext-2\n>>END-EVALUATE\nFormat 2\n>>EVALUATE\nTRUE\n>>WHEN\nconstant-conditional-expression-1\ntext-1\n>>WHEN\nOTHER\ntext-2\n>>END-EVALUATE\nFor descriptive purposes, in this topic:\n• operand-1 refers to literal-1 or arith-expr-1 in format 1, and to the TRUE keyword in format 2.\n724  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What is or in COBOL?", "input": "", "output": "or is function-identifier, the subscript, reference-\nmodifier, or function is evaluated only once as the first operation in the execution of the INSPECT\nstatement"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "National-edited\nA data item is described as category national-edited by its PICTURE character-string", "output": "National-edited\nA data item is described as category national-edited by its PICTURE character-string. For PICTURE\ncharacter-string details, see “National-edited items” on page 220.\nA data item of category national-edited is referred to as a national-edited data item.\nUTF-8\nEach of the following data items is of category UTF-8:\n• A data item is described as category UTF-8 when its PICTURE character-string contains one or more\nU symbols. The explicit USAGE UTF-8 clause may be present for items containing U in their PICTURE\ncharacter-string but is not required. For PICTURE character-string details, see “UTF-8 items” on page\n222.\n• A group item explicitly or implicitly described with a GROUP-USAGE UTF-8 clause.\n• A UTF-8 function.\nNumeric\nEach of the following data items is of category numeric:\n• An elementary data item described as numeric by its PICTURE character-string and not described with\na BLANK WHEN ZERO clause. For PICTURE character-string details, see “Numeric items” on page 221.\n• An elementary data item described with one of the following usages:\n– BINARY, COMPUTATIONAL, COMPUTATIONAL-4, COMPUTATIONAL-5, COMP, COMP-4, or COMP-5\n– PACKED-DECIMAL, COMPUTATIONAL-3, or COMP-3\n• A special register of numeric type:\n– JSON-CODE\n– JSON-STATUS\n– LENGTH OF\n– LINAGE-COUNTER\n– RETURN-CODE\n– SORTCORE-SIZE\n– SORT-FILE-SIZE\n– SORT-MODE-SIZE\n– SORT-RETURN\n– TALLY\n– XML-CODE\n• A numeric function.\n• An integer function.\nA data item of category numeric is referred to as a numeric data item.\nNumeric-edited\nEach of the following data items is of category numeric-edited:\n• A data item described as numeric-edited by its PICTURE character-string. For PICTURE character-string\ndetails, see “Numeric-edited items” on page 222.\n• A data item described as numeric by its PICTURE character-string and described with a BLANK WHEN\nZERO clause.\n178  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What are the compiler rules or directives for this?", "input": "to assign a literal value to a compilation variable that is defined in", "output": "to assign a literal value to a compilation variable that is defined in"}
{"instruction": "What are the compiler rules or directives for this?", "input": "The IF directive provides for a one-way or two-way conditional compilation.", "output": "The IF directive provides for a one-way or two-way conditional compilation."}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Chapter 59. INTEGER\nThe INTEGER function returns the greatest integer value that is less than or equ", "output": "Chapter 59. INTEGER\nThe INTEGER function returns the greatest integer value that is less than or equal to the argument\nspecified.\nThe function type is integer.\nFormat\nFUNCTION INTEGER\n(\nargument-1\n)\nargument-1\nMust be class numeric.\nThe returned value is the greatest integer less than or equal to the value of argument-1. For example,\nFUNCTION INTEGER (2.5) returns a value of 2 and FUNCTION INTEGER (-2.5) returns a value of -3.\n© Copyright IBM Corp. 1991, 2025\n583"}
{"instruction": "What are the compiler rules or directives for this?", "input": "\"OPTFILE\" was specified, \" \n      *  but file SYSOPTF could not be opened.  No options from a      \n      *  \"SYSOPTF\" file were used.                                     \n      *  This customization ", "output": "\"OPTFILE\" was specified, \" \n      *  but file SYSOPTF could not be opened.  No options from a      \n      *  \"SYSOPTF\" file were used.                                     \n      *  This customization would allow users to specify OPTFILE       \n      *  as a default option and it would only have an affect          \n      *  if there is a SYSOPTF file present                            \n      *****************************************************************\n             When(4019)                                                \n               Compute EXIT-USER-SEV = -1 \n      *****************************************************************\n      *  Change severity of 'optimization' messages to suppress them\n      *  so that compilation Return Code can be zero (RC=0)\n      * 7300: The code from lines &2 in program '&1' can never\n      *       be executed and was therefore discarded.\n      * 7301: A zero base was raised to a zero power in a numeric\n      *       literal exponentiation. The result was set to 1.\n      * 7302: A zero base was raised to a negative power in a numeric\n      *       literal exponentiation. The result was set to 0.\n      * 7304: An exception \"&1\" occured while processing numeric\n      *       literals. The result of the operation was set to zero.\n      * 7307: This statement may cause a program exception at execution\n      *       time.\n      * 7309: There may be a loop from the \"PERFORM\" statement at \"\n      *       \"PERFORM (line &1)\" to itself.\n      * 7312: Procedure starting at 'proc-name' (line 'num') was \n      *       copied one or more times to be inlined for PERFORM \n      *       statements. xxx total bytes were generated from \n      *       copying that procedure.  \n      *****************************************************************\n             When(7300) When(7301) When(7302) When(7304)\n             When(7307) When(7309) When(7312)  \n               Compute EXIT-USER-SEV = -1    *> Suppress the messages\n \n      *****************************************************************\n      *  Change severity of message 7311(W) to 12 ('S'). This is the  *\n      *  case of INITCHECK messages about uninitialized data items.   *\n      *****************************************************************\n             When(7311)                                                \n               Compute EXIT-USER-SEV = 12\n      *****************************************************************\n      *  Message severity Not customized\n      *****************************************************************\n             When Other\n               Compute EXIT-RETURNCODE = 0\n \n           End-Evaluate\n           .\n      *****************************************************************\n      *  FIPS MESSAGE   PROCESSOR                                     *\n      *****************************************************************\n       Fips-Messages-Severity.\n \n      *    Assume message severity will be customized...\n           Compute EXIT-RETURNCODE = 4\n \n      *    Convert numeric FIPS(FLAGSTD) 'category' to character\n      *    See the Programming Guide for description of FIPS category\n \n           EVALUATE EXIT-DEFAULT-SEV\n             When 81\n               MOVE 'D' To EXIT-DEFAULT-SEV-FIPS\n             When 82\n               MOVE 'E' To EXIT-DEFAULT-SEV-FIPS\n             When 83"}
{"instruction": "What is that the container is owned by the activity that the program has acquired by in COBOL?", "input": "", "output": "that the container is owned by the activity that the program has acquired by is of an\nACQUIRE ACTIVITYID command"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "– Alphabetic\n– Alphanumeric\n– Alphanumeric-edited\n– Numeric\n– Numeric-edited\n• For signed numeric it", "output": "– Alphabetic\n– Alphanumeric\n– Alphanumeric-edited\n– Numeric\n– Numeric-edited\n• For signed numeric items, the SIGN clause with the SEPARATE CHARACTER phrase must be specified.\n• For the USAGE clause, only the DISPLAY phrase is valid.\nPROCEDURE DIVISION\nAn ASCII-collated sort or merge operation can be specified in two ways as described in the topic.\n• Through the PROGRAM COLLATING SEQUENCE clause in the OBJECT-COMPUTER paragraph. In this\ncase, the ASCII collating sequence is used for alphanumeric comparisons explicitly specified in relation\nconditions and condition-name conditions.\n• Through the COLLATING SEQUENCE phrase of the SORT or MERGE statement. In this case, only this\nsort or merge operation uses the ASCII collating sequence.\nIn either case, alphabet-name must be associated with STANDARD-1 (for ASCII collating sequence) in the\nSPECIAL-NAMES paragraph.\nFor this sort or merge operation, the COLLATING SEQUENCE phrase of the SORT or MERGE statement\ntakes precedence over the PROGRAM COLLATING SEQUENCE clause in the OBJECT-COMPUTER\nparagraph.\nIf both the PROGRAM COLLATING SEQUENCE clause and the COLLATING SEQUENCE phrase are omitted\n(or if the one in effect specifies an EBCDIC collating sequence), the sort or merge is performed using the\nEBCDIC collating sequence.\nAppendix G. ASCII considerations  793"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "DFHMSD Standard BMS\n,\nPARTN\n=\n(\nname\n)\n,\nACTIVATE\nLDC\n=\nmnemonic\nOBFMT\n=\nNO\nYES\nHTAB\n=\n,\ntab\nVTAB\n=\n", "output": "DFHMSD Standard BMS\n,\nPARTN\n=\n(\nname\n)\n,\nACTIVATE\nLDC\n=\nmnemonic\nOBFMT\n=\nNO\nYES\nHTAB\n=\n,\ntab\nVTAB\n=\n,\ntab\nDATA\n=\nFIELD\nBLOCK\nFLDSEP\n=\nchar\nX\n'\nhex-char\n'\nA DFHMSD macro defines a mapset. It begins with the following code:\nDFHMSD TYPE=MAP    (or TYPE=DSECT)\nIt ends with the following code:\nDFHMSD TYPE=FINAL\nmapset is the name of the mapset. Normally, the name is up to 7 characters in length. However, if the\nmapset is used to generate HTML templates, and contains more than 36 maps, the name must not exceed\n6 characters in length.\nA DFHMSD macro contains one or more map definition macros, each of which contains one or more field\ndefinition macros.\nEnsure that the names of maps, and names of fields in a mapset (or in multiple mapsets that are copied\ninto one application program) are unique. However, a map can have the same name as a mapset.\nBefore CICS can load a physical map, you must define a physical map using an RDO DEFINE MAPSET\ncommand.\nYou assemble a BMS mapset definition to generate either a symbolic description map or a physical map.\nFor information about assembling and cataloging the maps, see .\nOperands\nBASE\nSpecifies that the same storage base is used for the symbolic description maps from more than one\nmapset. The same name is specified for each mapset that is to share the same storage base. Because\n810  CICS TS for z/OS: API Reference"}
{"instruction": "Explain this COBOL concept", "input": "General rules\nclass-name-1 and class-name-2 must conform to the normal rules of formation for a COBOL user-defined\nword, using single-byte characters.\nSee “REPOSITORY paragraph” on page 134 for details on specifying a class-name that is part of a Java\npackage or for using non-COBOL naming conventions for class-names.\nYou cannot include a class definition in a sequence of programs or other class definitions in a single\ncompilation group. Each class must be specified as a separate source file; that is, a class definition cannot\nbe included in a batch compile.\nInheritance\nEvery method available on instances of a class is also available on instances of any subclass directly or\nindirectly derived from that class.\nA subclass can introduce new methods that do not exist in the parent or ancestor class and can override a\nmethod from the parent or ancestor class. When a subclass overrides an existing method, it defines a new\nimplementation for that method, which replaces the inherited implementation.\nThe instance data of class-name-1 is the instance data declared in class-name-2 together with the data\ndeclared in the WORKING-STORAGE SECTION of class-name-1. Note, however, that instance data is\nalways private to the class that introduces it.\nThe semantics of inheritance are as defined by Java. All classes must be derived directly or directly from\nthe java.lang.Object class.\nJava supports single inheritance; that is, no class can inherit directly from more than one parent. Only one\nclass-name can be specified in the INHERITS phrase of a class definition.\n108  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "General rules\nclass-name-1 and class-name-2 must conform to the normal rules of formation for a COBOL user-defined\nword, using single-byte characters.\nSee “REPOSITORY paragraph” on page 134 for details on specifying a class-name that is part of a Java\npackage or for using non-COBOL naming conventions for class-names.\nYou cannot include a class definition in a sequence of programs or other class definitions in a single\ncompilation group. Each class must be specified as a separate source file; that is, a class definition cannot\nbe included in a batch compile.\nInheritance\nEvery method available on instances of a class is also available on instances of any subclass directly or\nindirectly derived from that class.\nA subclass can introduce new methods that do not exist in the parent or ancestor class and can override a\nmethod from the parent or ancestor class. When a subclass overrides an existing method, it defines a new\nimplementation for that method, which replaces the inherited implementation.\nThe instance data of class-name-1 is the instance data declared in class-name-2 together with the data\ndeclared in the WORKING-STORAGE SECTION of class-name-1. Note, however, that instance data is\nalways private to the class that introduces it.\nThe semantics of inheritance are as defined by Java. All classes must be derived directly or directly from\nthe java.lang.Object class.\nJava supports single inheritance; that is, no class can inherit directly from more than one parent. Only one\nclass-name can be specified in the INHERITS phrase of a class definition.\n108  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "Explain this COBOL concept", "input": "Chapter 99. TEST-NUMVAL-C\nThe TEST-NUMVAL-C function verifies that the contents of argument-1 conform to the specification for\nargument-1 of the NUMVAL-C function.\nThe function type is integer.\nFormat\nFUNCTION TEST-NUMVAL-C\n(\nargument-1\nargument-2\n)\nargument-1\nMust be an alphanumeric literal, a national literal, or a data item of class alphanumeric or class\nnational that contains a character string in either of the following formats:\nFormat 1: argument-1\nspace\n + \n - \nspace\ncs\nspace\ndigit\n,\ndigit\n.\ndigit\n.\ndigit\nspace\nFormat 2: argument-1, monetary format\nspace\ncs\nspace\ndigit\n,\ndigit\n.\ndigit\n.\ndigit\nspace\n + \n - \nCR\nDB\nspace\nspace\nA string of one or more spaces.\ncs\nThe string of one or more characters that form the currency sign. At most one copy of the\ncharacters specified by cs can occur in argument-1.\n© Copyright IBM Corp. 1991, 2025\n663", "output": "Chapter 99. TEST-NUMVAL-C\nThe TEST-NUMVAL-C function verifies that the contents of argument-1 conform to the specification for\nargument-1 of the NUMVAL-C function.\nThe function type is integer.\nFormat\nFUNCTION TEST-NUMVAL-C\n(\nargument-1\nargument-2\n)\nargument-1\nMust be an alphanumeric literal, a national literal, or a data item of class alphanumeric or class\nnational that contains a character string in either of the following formats:\nFormat 1: argument-1\nspace\n + \n - \nspace\ncs\nspace\ndigit\n,\ndigit\n.\ndigit\n.\ndigit\nspace\nFormat 2: argument-1, monetary format\nspace\ncs\nspace\ndigit\n,\ndigit\n.\ndigit\n.\ndigit\nspace\n + \n - \nCR\nDB\nspace\nspace\nA string of one or more spaces.\ncs\nThe string of one or more characters that form the currency sign. At most one copy of the\ncharacters specified by cs can occur in argument-1.\n© Copyright IBM Corp. 1991, 2025\n663"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Options\nCHANNEL(data-value)\nSpecifies the 1–16 character name of the channel.\nCONTAINERCNT(data-area", "output": "Options\nCHANNEL(data-value)\nSpecifies the 1–16 character name of the channel.\nCONTAINERCNT(data-area)\nReturns, as a fullword binary value, a count of the number of containers that are in the specified\nchannel.\nConditions\n122 CHANNELERR\nRESP2 values:\n2\nThe channel specified on the CHANNEL option could not be found.\nQUERY COUNTER and QUERY DCOUNTER\nQuery a named counter. Use COUNTER for fullword signed counters and DCOUNTER for doubleword\nunsigned counters.\nQUERY COUNTER\nQUERY\nCOUNTER(  name )\nPOOL( name )\nVALUE(  data-area )\nMINIMUM(  data-area )\nMAXIMUM(  data-area )\nNOSUSPEND\nConditions: BUSY, INVREQ, LENGERR\nThis command is threadsafe.\nQUERY DCOUNTER\nQUERY\nDCOUNTER(  name )\nPOOL( name )\nVALUE(  data-area )\nMINIMUM(  data-area )\nMAXIMUM(  data-area )\nNOSUSPEND\nConditions: BUSY, INVREQ\nThis command is threadsafe.\nDescription\nThese counter commands return the current, maximum, and minimum values for the named counter.\nFor information about specifying fullword and doubleword variables on these named counter commands,\nsee “CICS command argument values” on page 2.\nOptions\nCOUNTER(name)\nSpecifies the 16-byte name of the fullword counter name field. The name can contain upper case\nletters, digits or underscore characters including the symbols $, #, and @, padded to 16 bytes with\ntrailing spaces. Note that the name cannot start with a number or an underscore. It is recommended\nthat the name should start with a systematic prefix unique to the application.  Any counters used by\nCICS itself use the prefix DFH. \n340  CICS TS for z/OS: API Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "CVDA\nValue\nCMDSECNO\n205\nCMDSECYES\n207\nCOBOL\n151\nCOBOLII\n375\nCOLD\n788\nCOLDACQ\n72\nCOLDQUERY\n433\nCOLDST", "output": "CVDA\nValue\nCMDSECNO\n205\nCMDSECYES\n207\nCOBOL\n151\nCOBOLII\n375\nCOLD\n788\nCOLDACQ\n72\nCOLDQUERY\n433\nCOLDSTART\n266\nCOLLECTION\n473\nCOLOR\n399\nCOMMAREA\n1048\nCOMMIT\n208\nCOMMITFAIL\n792\nCOMPAT\n107\nCOMPLETE\n1026\nCOMPOSITE\n1003\nCOMPRESS\n1130\nCONFFREE\n82\nCONFRECV\n83\nCONFSEND\n84\nCONNECT\n903\nCONNECTED\n690\nCONNECTING\n904\nCONNECTION\n755\nCONSISTENT\n723\nCONSOLE\n66\nCONTAINER\n869\nCONTENTION\n836\nCONTEXT\n574\nCONTROLSHUT\n623\nCONVERSE\n600\nCONVIDLE\n518\nCOORDINATOR\n770\nCOPID\n908\nCOPY\n401\nChapter 4. CICS-value data areas used by all commands  711"}
{"instruction": "Summarize this COBOL documentation section", "input": "such cases, you need to update the link step of your build JCL to remove the LIB prefix when you refer\nto the associated DLL side deck file.\nSee the following table for the options in cjbuild command reference: \nTable 46. Options and descriptions\nOptions\nDescriptions\n--cleanscript <cleanup-script-name>\n-k <cleanup-script-name>\nCustomize the name of the cleanup script\ngenerated by the compiler. The user-specified\nfilename must end with '.sh'. This script is provided\nto assist the user to clean up the artifacts\ngenerated by cjbuild in the directories indicated\nby the -c, -s, -j and -d directories. Option --all-\nartifacts can be specified when invoking the\ncleanup script to cause the stub files generated\nby the COBOL compiler to be removed as well.\n--force-clean can be specified when invoking\nthe cleanup script to remove all files in the\ncurrent directory and -c/--coboldir generated\nby all previous invocations of cjbuild and COBOL\nCompiler.\nDefault: 'cjbuild_clean.sh'\n--coboldir <cobol-dir>\n-c <cobol-dir>\nPath to COBOL artifact directory. This directory\ncontains files generated by the compiler when\ncompiling COBOL programs that contain the JAVA-\nCALLABLE and/or JAVA-SHAREABLE directives or\nCALL statements with a literal call target of the\nform 'Java.java-class-name.java-static-\nmethod-name'.\".\nDefault: current directory\n--dlloutdir <dll-out-dir>\n-d <dll-out-dir>\nPath where the DLL of stub code is to be placed.\nFor a PDS, use the path of the form:\n//<DATASET-NAME>\nFor example:\n//COBOL.LOAD or //'USER.COBOL.LOAD'\nDefault: current directory\n--help\n-h\nDisplays verbose help.\nDefault: N/A\nChapter 18. Compiling, linking, and running non-OO COBOL applications that interoperate with Java  345", "output": "such cases, you need to update the link step of your build JCL to remove the LIB prefix when you refer\nto the associated DLL side deck file.\nSee the following table for the options in cjbuild command reference: \nTable 46. Options and descriptions\nOptions\nDescriptions\n--cleanscript <cleanup-script-name>\n-k <cleanup-script-name>\nCustomize the name of the cleanup script\ngenerated by the compiler. The user-specified\nfilename must end with '.sh'. This script is provided\nto assist the user to clean up the artifacts\ngenerated by cjbuild in the directories indicated\nby the -c, -s, -j and -d directories. Option --all-\nartifacts can be specified when invoking the\ncleanup script to cause the stub files generated\nby the COBOL compiler to be removed as well.\n--force-clean can be specified when invoking\nthe cleanup script to remove all files in the\ncurrent directory and -c/--coboldir generated\nby all previous invocations of cjbuild and COBOL\nCompiler.\nDefault: 'cjbuild_clean.sh'\n--coboldir <cobol-dir>\n-c <cobol-dir>\nPath to COBOL artifact directory. This directory\ncontains files generated by the compiler when\ncompiling COBOL programs that contain the JAVA-\nCALLABLE and/or JAVA-SHAREABLE directives or\nCALL statements with a literal call target of the\nform 'Java.java-class-name.java-static-\nmethod-name'.\".\nDefault: current directory\n--dlloutdir <dll-out-dir>\n-d <dll-out-dir>\nPath where the DLL of stub code is to be placed.\nFor a PDS, use the path of the form:\n//<DATASET-NAME>\nFor example:\n//COBOL.LOAD or //'USER.COBOL.LOAD'\nDefault: current directory\n--help\n-h\nDisplays verbose help.\nDefault: N/A\nChapter 18. Compiling, linking, and running non-OO COBOL applications that interoperate with Java  345"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Then the resulting output is:\nparm-len=002\nparm-string='95'\ncase ninety-five\n604  Enterprise COBOL f", "output": "Then the resulting output is:\nparm-len=002\nparm-string='95'\ncase ninety-five\n604  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What are the compiler rules or directives for this?", "input": "is currently suspended. If a reattachment event occurs, it is not reactivated.", "output": "is currently suspended. If a reattachment event occurs, it is not reactivated."}
{"instruction": "What is 1 in COBOL?", "input": "", "output": "1 is paragraph name and procedure-name-2 is not specified, the return is\nmade after the execution of the last statement of the procedure-name-1 paragraph.\n• If procedure-name-1 is a section name and procedure-name-2 is not specified, the return is made\nafter the execution of the last statement of the last paragraph in the procedure-name-1 section.\n• If procedure-name-2 is specified and it is a paragraph name, the return is made after the execution\nof the last statement of the procedure-name-2 paragraph.\n• If procedure-name-2 is specified and it is a section name, the return is made after the execution of\nthe last statement of the last paragraph in the procedure-name-2 section"}
{"instruction": "What is The default if this option is not specified in COBOL?", "input": "", "output": "The default if this option is not specified is default code page for the local CICS region, as\nspecified in the LOCALCCSID system initialization parameter"}
{"instruction": "What is which in COBOL?", "input": "", "output": "which is logical expression involving sub-events"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Chapter 54. FORMATTED-DATE\nThe FORMATTED-DATE function converts a date from its integer date form to", "output": "Chapter 54. FORMATTED-DATE\nThe FORMATTED-DATE function converts a date from its integer date form to the requested format.\nThe function type depends on the type of argument-1 as follows:\nTable 65. FORMATTED-DATE function type depending on the argument-1 types\nargument-1 type\nFunction type\nAlphanumeric\nAlphanumeric\nNational\nNational\nUTF-8\nUTF-8\nFormat\nFUNCTION FORMATTED-DATE\n(\nargument-1\nargument-2\n)\nargument-1\nMust be a national, a UTF-8 or an alphanumeric literal.\nThe content of argument-1 must be a date format. For details, see “Date and time formats” on page\n514.\nargument-2\nIt must be in integer date form. For details, see “Integer date form” on page 513.\nA value in integer date form is a positive integer that represents a number of days succeeding 31\nDecember 1600, in the Gregorian calendar. It is based on a starting date of Monday, 1 January 1601\nand integer date 1 represents Monday, 1 January 1601.\nThe INTDATE compiler option affects the starting date for the integer date functions. For details, see\nINTDATE in the Enterprise COBOL Programming Guide.\nThe returned value is a representation of the date contained in argument-2 according to the format in\nargument-1.\nExample\nGiven the date format \"YYYYMMDD\" and the value \"143951\", which represents the date 15 February\n1995, the returned value would be \"19950215\".\n© Copyright IBM Corp. 1991, 2025\n573"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "• An out-of-range value is supplied in the PROCLENGTH option.\n• The value that is specified in the P", "output": "• An out-of-range value is supplied in the PROCLENGTH option.\n• The value that is specified in the PIPLENGTH option is less than 0.\n• The value that is specified in the PIPLENGTH option exceeds the CICS implementation limit of 32\n763.\n• A PIPLIST length element (LL) has a value less than 4.\n• The sum of the length elements (LLs) in the PIPLIST does not equal the value that is specified by\nPIPLENGTH.\nDefault action: terminate the task abnormally.\n61 NOTALLOC\nThis condition occurs if the specified CONVID value does not relate to a conversation owned by the\napplication.\nDefault action: terminate the task abnormally.\n97 PARTNERIDERR\nThis condition occurs if the name specified in the PARTNER option is not recognized by CICS.\nDefault action: terminate the task abnormally.\n81 TERMERR\nThis condition occurs for a session-related error. Any action on that conversation other than a FREE\ncauses an ATCV abend.\nA CANCEL TASK request by a user node error program (NEP) can cause this condition if the task has\nan outstanding terminal control request active when the node abnormal condition program handles\nthe session error.\nDefault action: terminate the task abnormally with abend code ATNI.\nCONVERSE (default)\nCommunicate on standard CICS terminal support.\nCONVERSE (default)\nCONVERSE\nFROM( data-area )\nFROMLENGTH(  data-value )\nFROMFLENGTH(  data-value )\nINTO( data-area )\nSET( ptr-ref )\nTOLENGTH(  data-area )\nTOFLENGTH(  data-area )\nMAXLENGTH(  data-value )\nMAXFLENGTH(  data-value )\nNOTRUNCATE\nConditions: LENGERR\n   \nDescription\nThis form of the CONVERSE command is used by all CICS-supported z/OS Communications Server\nterminals for which the other CONVERSE descriptions are not appropriate.\nChapter 2. CICS command summary  79"}
{"instruction": "Summarize this COBOL documentation section", "input": "CALL statement\nThe CALL statement transfers control from one program to another within a run unit.\nThe program containing the CALL statement is the calling program; the program identified in the CALL\nstatement is the called subprogram. Called programs can contain CALL statements; however, only a\nprogram defined with the RECURSIVE clause can execute a CALL statement that directly or indirectly calls\nitself.\nFormat\nCALL\nidentifier-1\nliteral-1\nprocedure-pointer-1\nfunction-pointer-1\nUSING\nBY\nREFERENCE\nADDRESS OF\nidentifier-2\nfixed-phrase\nfile-name-1\nOMITTED\nBY\nCONTENT\nADDRESS OF\nLENGTH OF\nidentifier-3\nfixed-phrase\nliteral-2\nOMITTED\nBY\nVALUE\nADDRESS OF\nLENGTH OF\nidentifier-4\nliteral-3\nRETURNING\nidentifier-5\nexception-phrases\nEND-CALL\nfixed-phrase\nAS FIXED LENGTH\ninteger-4\nexception-phrases\nON\nEXCEPTION\nimperative-statement-1\nnot-exception-phrase\nON\nOVERFLOW\nimperative-statement-3\nnot-exception-phrase\nNOT\nON\nEXCEPTION\nimperative-statement-2\nChapter 28. PROCEDURE DIVISION statements  325", "output": "CALL statement\nThe CALL statement transfers control from one program to another within a run unit.\nThe program containing the CALL statement is the calling program; the program identified in the CALL\nstatement is the called subprogram. Called programs can contain CALL statements; however, only a\nprogram defined with the RECURSIVE clause can execute a CALL statement that directly or indirectly calls\nitself.\nFormat\nCALL\nidentifier-1\nliteral-1\nprocedure-pointer-1\nfunction-pointer-1\nUSING\nBY\nREFERENCE\nADDRESS OF\nidentifier-2\nfixed-phrase\nfile-name-1\nOMITTED\nBY\nCONTENT\nADDRESS OF\nLENGTH OF\nidentifier-3\nfixed-phrase\nliteral-2\nOMITTED\nBY\nVALUE\nADDRESS OF\nLENGTH OF\nidentifier-4\nliteral-3\nRETURNING\nidentifier-5\nexception-phrases\nEND-CALL\nfixed-phrase\nAS FIXED LENGTH\ninteger-4\nexception-phrases\nON\nEXCEPTION\nimperative-statement-1\nnot-exception-phrase\nON\nOVERFLOW\nimperative-statement-3\nnot-exception-phrase\nNOT\nON\nEXCEPTION\nimperative-statement-2\nChapter 28. PROCEDURE DIVISION statements  325"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 48. Mutually exclusive compiler options (continued)\nSpecified\nIgnored1\nForced on1\nNORENT\nRMODE", "output": "Table 48. Mutually exclusive compiler options (continued)\nSpecified\nIgnored1\nForced on1\nNORENT\nRMODE(ANY)\nRMODE(24)\nLP(64)\nLP(32)\nNSYMBOL(NATIONAL)\nNODBCS\nDBCS\nNUMCHECK(ZON(LAX))\nNUMPROC(PFD)\nNUMPROC(NOPFD)\nNUMPROC(PFD)\nNUMCHECK(ZON(LAX))\nNUMCHECK(ZON(STRICT))\nOBJECT\nDECK\nNODECK\nOFFSET\nLIST\nNOLIST\nPGMNAME(LM | LU)\nNAME\nNONAME\nRMODE(24)\nLP(64)\nLP(32)\nSMARTBIN\nLP(64)\nLP(32)\nSOURCE(HEX)\nNUMBER\nNONUMBER\nSEQUENCE\nNOSEQUENCE\nSQLIMS\nLP(64)\nLP(32)\nTEST\nNOOBJECT and NODECK\nOBJECT and NODECK\nTHREAD\nINITIAL\nNOINITIAL\nNORENT\nRENT\nLP(64)\nLP(32)\nWORD\nFLAGSTD\nNOFLAGSTD\n1. Unless in conflict with a fixed installation default option.\nRelated tasks   \n“Specifying compiler options under z/OS” on page 287  \n“Specifying compiler options in a batch compilation” on page 292  \n“Specifying compiler options under z/OS UNIX” on page 298 \nRelated references   \n“OPTFILE” on page 410 \nADATA\nUse ADATA when you want the compiler to create a SYSADATA file that contains records of additional\ncompilation information.\nADATA option syntax\nNOADATA\nADATA\nDefault is: NOADATA\nAbbreviations are: None\nOn z/OS, the SYSADATA file is written to ddname SYSADATA.\nChapter 20. COBOL compiler and runtime options  359"}
{"instruction": "What is length data item with a length that in COBOL?", "input": "", "output": "length data item with a length that is same as the current length of the\ndynamic-length elementary item"}
{"instruction": "Summarize this COBOL documentation section", "input": "CVDA\nValue\nNOMTOM\n461\nNOMTOMNOXOP\n470\nNONAUTOCONN\n171\nNONCICS\n661\nNONCRITICAL\n1090\nNONE\n496\nNONLE370\n1084\nNONRESIDENT\n1202\nNONTRANS\n572\nNOOBFORMAT\n422\nNOOBOPERID\n388\nNOOUTCONVERT\n746\nNOOUTLINE\n424\nNOPARTITIONS\n426\nNOPERF\n331\nNOPHASEOUT\n1110\nNOPRESETSEC\n243\nNOPRINTADAPT\n428\nNOPROGSYMBOL\n430\nNOPRTCOPY\n449\nNOPS\n997\nNOQUERY\n432\nNORECOVDATA\n700\nNOREENTPROT\n681\nNORELEASE\n918\nNORELREQ\n443\nNOREPLICATOR\n1212\nNORESRCE\n337\nNORESYNC\n934\nNORETAINED\n711\nNOREUSE\n294\nNORMAL\n1016\nNORMALBKOUT\n356\nNORMALRESP\n522\nNORMI\n775\n722  CICS TS for z/OS: API Reference", "output": "CVDA\nValue\nNOMTOM\n461\nNOMTOMNOXOP\n470\nNONAUTOCONN\n171\nNONCICS\n661\nNONCRITICAL\n1090\nNONE\n496\nNONLE370\n1084\nNONRESIDENT\n1202\nNONTRANS\n572\nNOOBFORMAT\n422\nNOOBOPERID\n388\nNOOUTCONVERT\n746\nNOOUTLINE\n424\nNOPARTITIONS\n426\nNOPERF\n331\nNOPHASEOUT\n1110\nNOPRESETSEC\n243\nNOPRINTADAPT\n428\nNOPROGSYMBOL\n430\nNOPRTCOPY\n449\nNOPS\n997\nNOQUERY\n432\nNORECOVDATA\n700\nNOREENTPROT\n681\nNORELEASE\n918\nNORELREQ\n443\nNOREPLICATOR\n1212\nNORESRCE\n337\nNORESYNC\n934\nNORETAINED\n711\nNOREUSE\n294\nNORMAL\n1016\nNORMALBKOUT\n356\nNORMALRESP\n522\nNORMI\n775\n722  CICS TS for z/OS: API Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Chapter 69. MEAN\nThe MEAN function returns a numeric value that approximates the arithmetic average ", "output": "Chapter 69. MEAN\nThe MEAN function returns a numeric value that approximates the arithmetic average of its arguments.\nThe function type is numeric.\nFormat\nFUNCTION MEAN\n(\nargument-1\n)\nargument-1\nMust be class numeric.\nThe returned value is the arithmetic mean of the argument-1 series. The returned value is defined as the\nsum of the argument-1 series divided by the number of occurrences referenced by argument-1.\n© Copyright IBM Corp. 1991, 2025\n603"}
{"instruction": "Explain this COBOL concept", "input": "FILE-CONTROL.\n    SELECT Sort-Work-1 ASSIGN TO SortFile.\nSort-Work-1 is the name of the file in your program. Use this name to refer to the file.\n2. Describe the sort file in an SD entry in the FILE SECTION of the DATA DIVISION. Every SD entry\nmust contain a record description. For example:\nDATA DIVISION.\nFILE SECTION.\nSD  Sort-Work-1\n    RECORD CONTAINS 100 CHARACTERS.\n01  SORT-WORK-1-AREA.\n    05  SORT-KEY-1   PIC  X(10).\n    05  SORT-KEY-2   PIC  X(10).\n    05  FILLER       PIC  X(80).\nThe file described in an SD entry is the working file used for a sort or merge operation. You cannot perform\nany input or output operations on this file and you do not need to provide a ddname definition for it.\nRelated references   \n“FILE SECTION entries” on page 12 \nDescribing the input to sorting or merging\nDescribe the input file or files for sorting or merging by following the procedure below.\n1. Write one or more SELECT clauses in the FILE-CONTROL paragraph of the ENVIRONMENT DIVISION\nto name the input files. For example:\nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.\nFILE-CONTROL.\n    SELECT Input-File ASSIGN TO InFile.\nInput-File is the name of the file in your program. Use this name to refer to the file.\n2. Describe the input file (or files when merging) in an FD entry in the FILE SECTION of the DATA\nDIVISION. For example:\nDATA DIVISION.\nFILE SECTION.\nFD  Input-File \n    LABEL RECORDS ARE STANDARD\n    BLOCK CONTAINS 0 CHARACTERS \n    RECORDING MODE IS F \n    RECORD CONTAINS 100 CHARACTERS.\n01  Input-Record   PIC X(100).\nRelated tasks   \n“Coding the input procedure” on page 238  \n“Requesting the sort or merge” on page 242 \nRelated references   \n“FILE SECTION entries” on page 12 \nExample: describing sort and input files for SORT\nThe following example shows the ENVIRONMENT DIVISION and DATA DIVISION entries needed to\ndescribe sort work files and an input file.\n ID Division.\n Program-ID. SmplSort.\n Environment Division.\nChapter 13. Sorting and merging files  237", "output": "FILE-CONTROL.\n    SELECT Sort-Work-1 ASSIGN TO SortFile.\nSort-Work-1 is the name of the file in your program. Use this name to refer to the file.\n2. Describe the sort file in an SD entry in the FILE SECTION of the DATA DIVISION. Every SD entry\nmust contain a record description. For example:\nDATA DIVISION.\nFILE SECTION.\nSD  Sort-Work-1\n    RECORD CONTAINS 100 CHARACTERS.\n01  SORT-WORK-1-AREA.\n    05  SORT-KEY-1   PIC  X(10).\n    05  SORT-KEY-2   PIC  X(10).\n    05  FILLER       PIC  X(80).\nThe file described in an SD entry is the working file used for a sort or merge operation. You cannot perform\nany input or output operations on this file and you do not need to provide a ddname definition for it.\nRelated references   \n“FILE SECTION entries” on page 12 \nDescribing the input to sorting or merging\nDescribe the input file or files for sorting or merging by following the procedure below.\n1. Write one or more SELECT clauses in the FILE-CONTROL paragraph of the ENVIRONMENT DIVISION\nto name the input files. For example:\nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.\nFILE-CONTROL.\n    SELECT Input-File ASSIGN TO InFile.\nInput-File is the name of the file in your program. Use this name to refer to the file.\n2. Describe the input file (or files when merging) in an FD entry in the FILE SECTION of the DATA\nDIVISION. For example:\nDATA DIVISION.\nFILE SECTION.\nFD  Input-File \n    LABEL RECORDS ARE STANDARD\n    BLOCK CONTAINS 0 CHARACTERS \n    RECORDING MODE IS F \n    RECORD CONTAINS 100 CHARACTERS.\n01  Input-Record   PIC X(100).\nRelated tasks   \n“Coding the input procedure” on page 238  \n“Requesting the sort or merge” on page 242 \nRelated references   \n“FILE SECTION entries” on page 12 \nExample: describing sort and input files for SORT\nThe following example shows the ENVIRONMENT DIVISION and DATA DIVISION entries needed to\ndescribe sort work files and an input file.\n ID Division.\n Program-ID. SmplSort.\n Environment Division.\nChapter 13. Sorting and merging files  237"}
{"instruction": "What is Elementary moves\nAn elementary move is one in which the receiving item is an elementary data item and the sending item in COBOL?", "input": "", "output": "Elementary moves\nAn elementary move is one in which the receiving item is an elementary data item and the sending item is elementary data item or a literal"}
{"instruction": "What is The collating\nsequence in COBOL?", "input": "", "output": "The collating\nsequence is order in which characters are defined in ANSI INCITS 4, the 7-Bit American National\nStandard Code for Information Interchange (7-Bit ASCII), and in the International Reference Version of\nISO/IEC 646, 7-Bit Coded Character Set for Information Interchange.\n764  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference\n\n\nEllipsis (. . .) indicates omission of a range of ordinal numbers between predecessor and successor ordinal\nnumbers"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 136. SYSADATA parse tree record (continued)\nField\nSize\nDescription\n0056\nUSUPPLEMENTARY\n0057\nHE", "output": "Table 136. SYSADATA parse tree record (continued)\nField\nSize\nDescription\n0056\nUSUPPLEMENTARY\n0057\nHEX-OF\n0058\nBIT-OF\n0059\nE\n0060\nTRIM\n0061\nPI\n0062\nABS\n0063\nBYTE-LENGTH\n0064\nEXP\n0065\nEXP10\n0066\nBIT-TO-CHAR\n0067\nNUMVAL-F\n0068\nHEX-TO-CHAR\n0069\nSIGN\n0070\nTEST-NUMVAL\n0071\nTEST-NUMVAL-C\n0072\nTEST-NUMVAL-F\nAppendix G. COBOL SYSADATA file contents  919"}
{"instruction": "What is 35 TSIOERR\noccurs if there in COBOL?", "input": "", "output": "35 TSIOERR\noccurs if there is irrecoverable temporary storage input/output error"}
{"instruction": "What is the COMMAREA that is passed to the abend exit in COBOL?", "input": "", "output": "the COMMAREA that is passed to the abend exit is COMMAREA of the program that issued the HANDLE ABEND command"}
{"instruction": "Summarize this COBOL documentation section", "input": "“Reading LIST output” on page 488  \nLanguage Environment Debugging Guide (Debugging COBOL programs)\nRelated references   \n“Messages and listings\nfor compiler-detected errors” on page 295\nExample: short listing\nThe parenthetical numbers shown in the listing below correspond to numbered explanations that follow\nthe listing. For illustrative purposes, some errors that cause diagnostic messages were deliberately\nintroduced.\nInvocation parameters:      (1)\n OPTFILE\nPROCESS(CBL) statements:    (2)\n CBL NODECK\n CBL NOADV,NODYN,NONAME,NONUMBER,QUOTE,SEQ,DUMP\n CBL NOSOURCE, NOXREF, NOVBREF, NOMAP, NOOFFSET, NOLIST\nOptions from SYSOPTF:       (3)\n C,NODU,FLAG(I),X,MAP,NOLIST,RENT,OPT(1),SSR\n TEST TRUNC(OPT)\nOptions in effect:          (4)\n NOADATA\n NOADV\n   AFP(VOLATILE)\n   QUOTE\n   ARCH(8)\n   ARITH(COMPAT)\n NOAWO\n NOBLOCK0\n   BUFSIZE(4096)\n NOCICS\n   CODEPAGE(1140)\n   COMPILE\n NOCOPYRIGHT\n NOCURRENCY\n   DATA(31)\n   DBCS\n NODECK\n NODIAGTRUNC\n   DISPSIGN(COMPAT)\n NODLL\n   DUMP\n NODYNAM\n NOEXIT\n NOEXPORTALL\n NOFASTSRT\n   FLAG(I)\n NOFLAGSTD\n   HGPR(PRESERVE)\n   INTDATE(ANSI)\n   LANGUAGE(EN)\n   LINECOUNT(60)\n NOLIST\n NOMAP\n   MAXPCF(100000)\n NOMDECK\n NONAME\n   NSYMBOL(NATIONAL)\n NONUMBER\n   NUMPROC(NOPFD)\n   OBJECT\n NOOFFSET\n   OPTIMIZE(1)\n   OUTDD(SYSOUT)\n   PGMNAME(COMPAT)\n   QUALIFY(COMPAT)\n   RENT\n   RMODE(AUTO)\n NORULES\n NOSERVICE\n   SEQUENCE\n NOSOURCE\n   SPACE(1)\n NOSQL\n   SQLCCSID\nChapter 22. Debugging  479", "output": "“Reading LIST output” on page 488  \nLanguage Environment Debugging Guide (Debugging COBOL programs)\nRelated references   \n“Messages and listings\nfor compiler-detected errors” on page 295\nExample: short listing\nThe parenthetical numbers shown in the listing below correspond to numbered explanations that follow\nthe listing. For illustrative purposes, some errors that cause diagnostic messages were deliberately\nintroduced.\nInvocation parameters:      (1)\n OPTFILE\nPROCESS(CBL) statements:    (2)\n CBL NODECK\n CBL NOADV,NODYN,NONAME,NONUMBER,QUOTE,SEQ,DUMP\n CBL NOSOURCE, NOXREF, NOVBREF, NOMAP, NOOFFSET, NOLIST\nOptions from SYSOPTF:       (3)\n C,NODU,FLAG(I),X,MAP,NOLIST,RENT,OPT(1),SSR\n TEST TRUNC(OPT)\nOptions in effect:          (4)\n NOADATA\n NOADV\n   AFP(VOLATILE)\n   QUOTE\n   ARCH(8)\n   ARITH(COMPAT)\n NOAWO\n NOBLOCK0\n   BUFSIZE(4096)\n NOCICS\n   CODEPAGE(1140)\n   COMPILE\n NOCOPYRIGHT\n NOCURRENCY\n   DATA(31)\n   DBCS\n NODECK\n NODIAGTRUNC\n   DISPSIGN(COMPAT)\n NODLL\n   DUMP\n NODYNAM\n NOEXIT\n NOEXPORTALL\n NOFASTSRT\n   FLAG(I)\n NOFLAGSTD\n   HGPR(PRESERVE)\n   INTDATE(ANSI)\n   LANGUAGE(EN)\n   LINECOUNT(60)\n NOLIST\n NOMAP\n   MAXPCF(100000)\n NOMDECK\n NONAME\n   NSYMBOL(NATIONAL)\n NONUMBER\n   NUMPROC(NOPFD)\n   OBJECT\n NOOFFSET\n   OPTIMIZE(1)\n   OUTDD(SYSOUT)\n   PGMNAME(COMPAT)\n   QUALIFY(COMPAT)\n   RENT\n   RMODE(AUTO)\n NORULES\n NOSERVICE\n   SEQUENCE\n NOSOURCE\n   SPACE(1)\n NOSQL\n   SQLCCSID\nChapter 22. Debugging  479"}
{"instruction": "Explain this COBOL concept", "input": "Conventions for program-names\nThe program-name of a program is specified in the PROGRAM-ID paragraph of the program's\nIDENTIFICATION DIVISION. A program-name can be referenced only by the CALL statement, the CANCEL\nstatement, the SET statement, or the END PROGRAM marker.\nNames of programs that constitute a run unit are not necessarily unique, but when two programs in a run\nunit are identically named, at least one of the programs must be directly or indirectly contained within\nanother separately compiled program that does not contain the other of those two programs.\nA separately compiled program and all of its directly and indirectly contained programs must have unique\nprogram-names within that separately compiled program.\nRules for program-names\nThe following rules define the scope of a program-name:\n• If the program-name is that of a program that does not possess the COMMON attribute and that\nprogram is directly contained within another program, that program-name can be referenced only by\nstatements included in that containing program.\n• If the program-name is that of a program that does possess the COMMON attribute and that\nprogram is directly contained within another program, that program-name can be referenced only by\nstatements included in the containing program and any programs directly or indirectly contained within\nthat containing program, except that program possessing the COMMON attribute and any programs\ncontained within it.\n• If the program-name is that of a program that is separately compiled, that program-name can be\nreferenced by statements included in any other program in the run unit, except programs it directly or\nindirectly contains.\n88  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "Conventions for program-names\nThe program-name of a program is specified in the PROGRAM-ID paragraph of the program's\nIDENTIFICATION DIVISION. A program-name can be referenced only by the CALL statement, the CANCEL\nstatement, the SET statement, or the END PROGRAM marker.\nNames of programs that constitute a run unit are not necessarily unique, but when two programs in a run\nunit are identically named, at least one of the programs must be directly or indirectly contained within\nanother separately compiled program that does not contain the other of those two programs.\nA separately compiled program and all of its directly and indirectly contained programs must have unique\nprogram-names within that separately compiled program.\nRules for program-names\nThe following rules define the scope of a program-name:\n• If the program-name is that of a program that does not possess the COMMON attribute and that\nprogram is directly contained within another program, that program-name can be referenced only by\nstatements included in that containing program.\n• If the program-name is that of a program that does possess the COMMON attribute and that\nprogram is directly contained within another program, that program-name can be referenced only by\nstatements included in the containing program and any programs directly or indirectly contained within\nthat containing program, except that program possessing the COMMON attribute and any programs\ncontained within it.\n• If the program-name is that of a program that is separately compiled, that program-name can be\nreferenced by statements included in any other program in the run unit, except programs it directly or\nindirectly contains.\n88  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "Summarize this COBOL documentation section", "input": "Chapter 46. Handling errors in Java-interoperable\nCOBOL applications\nThis topic provides suggestions on COBOL/Java interoperability error handing.\nFor cases where COBOL calls out to a static Java method using the CALL statement, exceptions can occur\non the Java side of the application or in the Java call stub program. All exceptions occurring during the call\ncan be handled using the ON EXCEPTION phrase of the CALL statement. If an exception occurs and the\nON EXCEPTION phrase is specified, the exception will be cleared before the code in the ON EXCEPTION\nphrase is executed. If desired, user exception handling code can access the Java exception object that\ncaused the exception through the IGY-JAVAIOP-CALL-EXCEPTION special register. To propagate the\nexception up the chain of calling programs, the JNI function Throw() can be used to re-throw the\nexception object. If an exception occurs and the ON EXCEPTION phrase is not specified, the COBOL\nrun unit will be stopped due to the unhandled exception. An alternative method of handling exceptions\nthat occur on the Java side of the application when COBOL calls a static Java method is for the static Java\nmethod to catch any exceptions and convert them to a return code that is returned to the COBOL caller.\nOn the COBOL side, the COBOL application can decide what to do based on the return code.\nFor cases where Java calls COBOL, if a Java exception occurs in the native method call stub program\nwhen executing JNI functions, the stub program will not clear the exception and will immediately return\nto the Java side of the application where the exception can be caught and handled appropriately. If the\nexception is not handled, the Java application will be terminated due to the unhandled exception.\n© Copyright IBM Corp. 1991, 2025\n777", "output": "Chapter 46. Handling errors in Java-interoperable\nCOBOL applications\nThis topic provides suggestions on COBOL/Java interoperability error handing.\nFor cases where COBOL calls out to a static Java method using the CALL statement, exceptions can occur\non the Java side of the application or in the Java call stub program. All exceptions occurring during the call\ncan be handled using the ON EXCEPTION phrase of the CALL statement. If an exception occurs and the\nON EXCEPTION phrase is specified, the exception will be cleared before the code in the ON EXCEPTION\nphrase is executed. If desired, user exception handling code can access the Java exception object that\ncaused the exception through the IGY-JAVAIOP-CALL-EXCEPTION special register. To propagate the\nexception up the chain of calling programs, the JNI function Throw() can be used to re-throw the\nexception object. If an exception occurs and the ON EXCEPTION phrase is not specified, the COBOL\nrun unit will be stopped due to the unhandled exception. An alternative method of handling exceptions\nthat occur on the Java side of the application when COBOL calls a static Java method is for the static Java\nmethod to catch any exceptions and convert them to a return code that is returned to the COBOL caller.\nOn the COBOL side, the COBOL application can decide what to do based on the return code.\nFor cases where Java calls COBOL, if a Java exception occurs in the native method call stub program\nwhen executing JNI functions, the stub program will not clear the exception and will immediately return\nto the Java side of the application where the exception can be caught and handled appropriately. If the\nexception is not handled, the Java application will be terminated due to the unhandled exception.\n© Copyright IBM Corp. 1991, 2025\n777"}
{"instruction": "Explain this COBOL concept", "input": "Format 1: WRITE statement for sequential files\nWRITE\nrecord-name-1\nFROM\nidentifier-1\nBEFORE\nAFTER\nADVANCING\nidentifier-2\ninteger-1\nLINE\nLINES\nmnemonic-name-1\nPAGE\nphrase 1\ninvalid_key\nnot_invalid_key\nEND-WRITE\nphrase 1\nAT\nEND-OF-PAGE\nEOP\nimperative-statement-3\nNOT\nAT\nEND-OF-PAGE\nEOP\nimperative-statement-4\ninvalid_key\nINVALID\nKEY\nimperative-statement-1\nnot_invalid_key\nNOT INVALID\nKEY\nimperative-statement-2\nFormat 2: WRITE statement for indexed and relative files\nWRITE\nrecord-name-1\nFROM\nidentifier-1\nINVALID\nKEY\nimperative-statement-1\nNOT INVALID\nKEY\nimperative-statement-2\nEND-WRITE\n482  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "Format 1: WRITE statement for sequential files\nWRITE\nrecord-name-1\nFROM\nidentifier-1\nBEFORE\nAFTER\nADVANCING\nidentifier-2\ninteger-1\nLINE\nLINES\nmnemonic-name-1\nPAGE\nphrase 1\ninvalid_key\nnot_invalid_key\nEND-WRITE\nphrase 1\nAT\nEND-OF-PAGE\nEOP\nimperative-statement-3\nNOT\nAT\nEND-OF-PAGE\nEOP\nimperative-statement-4\ninvalid_key\nINVALID\nKEY\nimperative-statement-1\nnot_invalid_key\nNOT INVALID\nKEY\nimperative-statement-2\nFormat 2: WRITE statement for indexed and relative files\nWRITE\nrecord-name-1\nFROM\nidentifier-1\nINVALID\nKEY\nimperative-statement-1\nNOT INVALID\nKEY\nimperative-statement-2\nEND-WRITE\n482  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What is SIZE special register in COBOL?", "input": "", "output": "SIZE special register is name of a binary data item that you can use to specify the\nlength of variable-length records that occur most frequently"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Subscripting\nSubscripting is a method of providing table references through the use of subscripts. A", "output": "Subscripting\nSubscripting is a method of providing table references through the use of subscripts. A subscript is a\npositive integer whose value specifies the occurrence number of a table element.\nFormat 1a (Low-High qualification)\ncondition-name-1\ndata-name-1\nindex-name-1\nIN\nOF\ndata-name-2\nIN\nOF\nfile-name-1\n(\ninteger-1\nALL\ndata-name-3\n + \n - \ninteger-2\nindex-name-1\n + \n - \ninteger-3\n)\nFormat 1b (High-Low qualification)\nfile-name-1\n::\ndata-name-2\n::\ncondition-name-1\ndata-name-1\nindex-name-1\n(\ninteger-1\nALL\ndata-name-3\n + \n - \ninteger-2\nindex-name-1\n + \n - \ninteger-3\n)\ncondition-name-1\nThe conditional variable for condition-name-1 must contain an OCCURS clause or must be\nsubordinate to a data description entry that contains an OCCURS clause.\ndata-name-1\nMust contain an OCCURS clause or must be subordinate to a data description entry that contains an\nOCCURS clause.\n74  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "Summarize this COBOL documentation section", "input": "• The CONVID value specified in the command relates to a basic (unmapped) APPC conversation.\n• The CONVID value specified in the command relates to a CPI-Communications conversation.\nDefault action: terminate the task abnormally.\n61 NOTALLOC\noccurs if the specified CONVID value does not relate to a conversation owned by the application.\nDefault action: terminate the task abnormally.\nFREE (LUTYPE6.1)\nReturn LUTYPE6.1 sessions to CICS.\nFREE (LUTYPE6.1)\nFREE\nCONVID(  name )\nSESSION(  name )\nConditions: INVREQ, NOTALLOC\nDescription\nFREE returns an LUTYPE6.1 session to CICS when a transaction that owns it no longer requires it. The\nsession can then be allocated for use by other transactions.\nIf you omit both CONVID and SESSION, the principal facility is freed. Facilities not freed explicitly are\nfreed by CICS when the task terminates.\nIf you are running EDF, and the transaction frees the principal facility, EDF is terminated.\nOptions\nCONVID(name)\nIdentifies the LUTYPE6.1 session to be freed. The 4-character name identifies either the token\nreturned by a previously executed ALLOCATE command in EIBRSRCE in the EIB, or the token\nrepresenting the principal session (returned by a previously executed ASSIGN command).\nSESSION(name)\nSpecifies the symbolic identifier (1–4 characters) of a session TCTTE. This option specifies the\nalternate facility to be used.\nConditions\n16 INVREQ\nOccurs if the session specified in the command was allocated for a basic (unmapped) APPC\nconversation.\nSee also EIBRCODE in EIB fields.\nDefault action: terminate the task abnormally.\n61 NOTALLOC\nOccurs if the session specified in the command is not owned by the application.\nDefault action: terminate the task abnormally.\nFREE (MRO)\nReturn MRO sessions to CICS.\nChapter 2. CICS command summary  191", "output": "• The CONVID value specified in the command relates to a basic (unmapped) APPC conversation.\n• The CONVID value specified in the command relates to a CPI-Communications conversation.\nDefault action: terminate the task abnormally.\n61 NOTALLOC\noccurs if the specified CONVID value does not relate to a conversation owned by the application.\nDefault action: terminate the task abnormally.\nFREE (LUTYPE6.1)\nReturn LUTYPE6.1 sessions to CICS.\nFREE (LUTYPE6.1)\nFREE\nCONVID(  name )\nSESSION(  name )\nConditions: INVREQ, NOTALLOC\nDescription\nFREE returns an LUTYPE6.1 session to CICS when a transaction that owns it no longer requires it. The\nsession can then be allocated for use by other transactions.\nIf you omit both CONVID and SESSION, the principal facility is freed. Facilities not freed explicitly are\nfreed by CICS when the task terminates.\nIf you are running EDF, and the transaction frees the principal facility, EDF is terminated.\nOptions\nCONVID(name)\nIdentifies the LUTYPE6.1 session to be freed. The 4-character name identifies either the token\nreturned by a previously executed ALLOCATE command in EIBRSRCE in the EIB, or the token\nrepresenting the principal session (returned by a previously executed ASSIGN command).\nSESSION(name)\nSpecifies the symbolic identifier (1–4 characters) of a session TCTTE. This option specifies the\nalternate facility to be used.\nConditions\n16 INVREQ\nOccurs if the session specified in the command was allocated for a basic (unmapped) APPC\nconversation.\nSee also EIBRCODE in EIB fields.\nDefault action: terminate the task abnormally.\n61 NOTALLOC\nOccurs if the session specified in the command is not owned by the application.\nDefault action: terminate the task abnormally.\nFREE (MRO)\nReturn MRO sessions to CICS.\nChapter 2. CICS command summary  191"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "• The Java Native Interface, download.oracle.com/javase/1.5.0/docs/guide/jni/\n• JDK 5.0 Documentatio", "output": "• The Java Native Interface, download.oracle.com/javase/1.5.0/docs/guide/jni/\n• JDK 5.0 Documentation, download.oracle.com/javase/1.5.0/docs/\nJSON\n• JavaScript Object Notation (JSON), www.json.org\nUnicode and character representation\n• Unicode, www.unicode.org/\n• Character Data Representation Architecture Reference and Registry, SC09-2190\nXML\n• Extensible Markup Language (XML), www.w3.org/XML/\n• Namespaces in XML 1.0, www.w3.org/TR/xml-names/\n• Namespaces in XML 1.1, www.w3.org/TR/xml-names11/\n• XML specification, www.w3.org/TR/xml/\n1048  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What are the compiler rules or directives for this?", "input": "is ignored. The parser signals an XML exception event if the actual document encoding", "output": "is ignored. The parser signals an XML exception event if the actual document encoding"}
{"instruction": "Explain this COBOL concept", "input": "Chapter 33. ANNUITY\nThe ANNUITY function returns a numeric value that approximates the ratio of an annuity paid at the end\nof each period, for a given number of periods, at a given interest rate, to an initial value of one.\nThe number of periods is specified by argument-2; the rate of interest is specified by argument-1. For\nexample, if argument-1 is zero and argument-2 is four, the value returned is the approximation of the ratio\n1 / 4.\nThe function type is numeric.\nFormat\nFUNCTION ANNUITY\n(\nargument-1\nargument-2\n)\nargument-1\nMust be class numeric. The value of argument-1 must be greater than or equal to zero.\nargument-2\nMust be a positive integer.\nWhen the value of argument-1 is zero, the value returned by the function is the approximation of:\n1 / argument-2\nWhen the value of argument-1 is not zero, the value of the function is the approximation of:\nargument-1 / (1 - (1 + argument-1) ** (- argument-2))\n© Copyright IBM Corp. 1991, 2025\n531", "output": "Chapter 33. ANNUITY\nThe ANNUITY function returns a numeric value that approximates the ratio of an annuity paid at the end\nof each period, for a given number of periods, at a given interest rate, to an initial value of one.\nThe number of periods is specified by argument-2; the rate of interest is specified by argument-1. For\nexample, if argument-1 is zero and argument-2 is four, the value returned is the approximation of the ratio\n1 / 4.\nThe function type is numeric.\nFormat\nFUNCTION ANNUITY\n(\nargument-1\nargument-2\n)\nargument-1\nMust be class numeric. The value of argument-1 must be greater than or equal to zero.\nargument-2\nMust be a positive integer.\nWhen the value of argument-1 is zero, the value returned by the function is the approximation of:\n1 / argument-2\nWhen the value of argument-1 is not zero, the value of the function is the approximation of:\nargument-1 / (1 - (1 + argument-1) ** (- argument-2))\n© Copyright IBM Corp. 1991, 2025\n531"}
{"instruction": "Summarize this COBOL documentation section", "input": "WEB EXTRACT\nObtain information about an HTTP request that has been made to CICS as an HTTP server or about\na connection between an Internet server and CICS as an HTTP client. This command is a synonym of\nEXTRACT WEB.\nWEB EXTRACT (CICS as an HTTP server)\nWEB\nEXTRACT\nSCHEME(  cvda)\nHOST( data-area )\nHOSTLENGTH(  data-value )\nHOSTTYPE(  cvda)\nHTTPMETHOD(  data-area )\nMETHODLENGTH(  data-area )\nHTTPVERSION(  data-area )\nVERSIONLEN(  data-area )\nPATH(  data-area )\nPATHLENGTH(  data-area )\nPORTNUMBER(  data-area )\nQUERYSTRING(  data-area )\nQUERYSTRLEN(  data-area )\nREQUESTTYPE(  cvda)\nURIMAP( data-area )\nConditions: INVREQ, IOERR, LENGERR, NOTFND, NOTOPEN, TIMEDOUT\nThis command is threadsafe.\nWEB EXTRACT (CICS as an HTTP client)\nWEB\nEXTRACT\nSESSTOKEN(  data-area )\nSCHEME(  cvda)\nHOST( data-area )\nHOSTLENGTH(  data-value )\nHOSTTYPE(  cvda)\nHTTPVERSION(  data-area )\nVERSIONLEN(  data-area )\nPATH(  data-area )\nPATHLENGTH(  data-area )\nPORTNUMBER(  data-area )\nURIMAP( data-area )\nREALM( data-area )\nREALMLEN(  data-area )\nConditions: INVREQ, IOERR, LENGERR, NOTFND, NOTOPEN, TIMEDOUT\nThis command is threadsafe.\nChapter 2. CICS command summary  609", "output": "WEB EXTRACT\nObtain information about an HTTP request that has been made to CICS as an HTTP server or about\na connection between an Internet server and CICS as an HTTP client. This command is a synonym of\nEXTRACT WEB.\nWEB EXTRACT (CICS as an HTTP server)\nWEB\nEXTRACT\nSCHEME(  cvda)\nHOST( data-area )\nHOSTLENGTH(  data-value )\nHOSTTYPE(  cvda)\nHTTPMETHOD(  data-area )\nMETHODLENGTH(  data-area )\nHTTPVERSION(  data-area )\nVERSIONLEN(  data-area )\nPATH(  data-area )\nPATHLENGTH(  data-area )\nPORTNUMBER(  data-area )\nQUERYSTRING(  data-area )\nQUERYSTRLEN(  data-area )\nREQUESTTYPE(  cvda)\nURIMAP( data-area )\nConditions: INVREQ, IOERR, LENGERR, NOTFND, NOTOPEN, TIMEDOUT\nThis command is threadsafe.\nWEB EXTRACT (CICS as an HTTP client)\nWEB\nEXTRACT\nSESSTOKEN(  data-area )\nSCHEME(  cvda)\nHOST( data-area )\nHOSTLENGTH(  data-value )\nHOSTTYPE(  cvda)\nHTTPVERSION(  data-area )\nVERSIONLEN(  data-area )\nPATH(  data-area )\nPATHLENGTH(  data-area )\nPORTNUMBER(  data-area )\nURIMAP( data-area )\nREALM( data-area )\nREALMLEN(  data-area )\nConditions: INVREQ, IOERR, LENGERR, NOTFND, NOTOPEN, TIMEDOUT\nThis command is threadsafe.\nChapter 2. CICS command summary  609"}
{"instruction": "What is A pointer data item in COBOL?", "input": "", "output": "A pointer data item is 4-byte elementary item or an 8-byte elementary item depending on whether the LP(32) or LP(64) is\n248  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference\n\n\nin effect"}
{"instruction": "Explain this COBOL concept", "input": "Value CVDA\n398 NOBACKTRANS\n399 COLOR\n400 NOCOLOR\n401 COPY\n402 NOCOPY\n403 MIXED\n404 NODUALCASE\n405 EXTENDEDDS\n406 NOEXTENDEDDS\n407 FORMFEED\n408 NOFORMFEED\n409 HFORM\n410 NOHFORM\n411 VFORM\n412 NOVFORM\n413 HILIGHT\n414 NOHILIGHT\n415 KATAKANA\n416 NOKATAKANA\n417 LIGHTPEN\n418 NOLIGHTPEN\n419 MSRCONTROL\n420 NOMSRCONTROL\n421 OBFORMAT\n422 NOOBFORMAT\n423 OUTLINE\n424 NOOUTLINE\n425 PARTITIONS\n426 NOPARTITIONS\n427 PRINTADAPT\n428 NOPRINTADAPT\n429 PROGSYMBOL\n430 NOPROGSYMBOL\n431 ALLQUERY\n432 NOQUERY\nChapter 4. CICS-value data areas used by all commands  749", "output": "Value CVDA\n398 NOBACKTRANS\n399 COLOR\n400 NOCOLOR\n401 COPY\n402 NOCOPY\n403 MIXED\n404 NODUALCASE\n405 EXTENDEDDS\n406 NOEXTENDEDDS\n407 FORMFEED\n408 NOFORMFEED\n409 HFORM\n410 NOHFORM\n411 VFORM\n412 NOVFORM\n413 HILIGHT\n414 NOHILIGHT\n415 KATAKANA\n416 NOKATAKANA\n417 LIGHTPEN\n418 NOLIGHTPEN\n419 MSRCONTROL\n420 NOMSRCONTROL\n421 OBFORMAT\n422 NOOBFORMAT\n423 OUTLINE\n424 NOOUTLINE\n425 PARTITIONS\n426 NOPARTITIONS\n427 PRINTADAPT\n428 NOPRINTADAPT\n429 PROGSYMBOL\n430 NOPROGSYMBOL\n431 ALLQUERY\n432 NOQUERY\nChapter 4. CICS-value data areas used by all commands  749"}
{"instruction": "What are the compiler rules or directives for this?", "input": "if you have line numbers in your source code and want those numbers to", "output": "if you have line numbers in your source code and want those numbers to"}
{"instruction": "What is This option in COBOL?", "input": "", "output": "This option is fullword alternative to MAXLENGTH"}
{"instruction": "Explain this COBOL concept", "input": "• API (EXEC CICS) Reference\n• Developing CICS System Programs\n• Global User Exit Reference\n• XPI Reference\n• Using EXCI with CICS\nCOBOL Report Writer Precompiler\n• Programmer's Manual, SC26-4301\n• Installation and Operation, SC26-4302\nDb2 for z/OS\nYou can find the following publications in the Db2 library:\n• Application Programming and SQL Guide\n• Command Reference\n• SQL Reference\nIBM z/OS Debugger (formerly IBM Debug for z Systems and Debug Tool)\nYou can find information about IBM z/OS Debugger in the IBM z/OS Debugger library.\nIBM Developer for z/OS (formerly IBM Developer for z Systems)\nYou can find information about IBM Developer for z/OS in the IBM Developer for z/OS library.\nNote: IBM Developer for z/OS supersedes IBM Developer for z Systems and Rational Developer for z\nSystems.\nYou can find the following publications by searching their publication numbers in the IBM Publications\nCenter.\nIMS\n• Application Programming API Reference, SC18-9699\n• Application Programming Guide, SC18-9698\nWebSphere Application Server for z/OS\n• Applications, SA22-7959\nSoftcopy publications for z/OS\nThe following collection kit contains z/OS and related product publications:\n• z/OS CD Collection Kit, SK3T-4269\nJava\n• IBM SDK for Java - Tools Documentation, publib.boulder.ibm.com/infocenter/javasdk/tools/index.jsp\n• The Java 2 Enterprise Edition Developer's Guide, download.oracle.com/javaee/1.2.1/devguide/html/\nDevGuideTOC.html\n• Java 2 on z/OS, www.ibm.com/servers/eserver/zseries/software/java/\n• The Java EE 5 Tutorial, download.oracle.com/javaee/5/tutorial/doc/\n• The Java Language Specification, Third Edition, by Gosling et al., java.sun.com/docs/books/jls/\nList of resources  1047", "output": "• API (EXEC CICS) Reference\n• Developing CICS System Programs\n• Global User Exit Reference\n• XPI Reference\n• Using EXCI with CICS\nCOBOL Report Writer Precompiler\n• Programmer's Manual, SC26-4301\n• Installation and Operation, SC26-4302\nDb2 for z/OS\nYou can find the following publications in the Db2 library:\n• Application Programming and SQL Guide\n• Command Reference\n• SQL Reference\nIBM z/OS Debugger (formerly IBM Debug for z Systems and Debug Tool)\nYou can find information about IBM z/OS Debugger in the IBM z/OS Debugger library.\nIBM Developer for z/OS (formerly IBM Developer for z Systems)\nYou can find information about IBM Developer for z/OS in the IBM Developer for z/OS library.\nNote: IBM Developer for z/OS supersedes IBM Developer for z Systems and Rational Developer for z\nSystems.\nYou can find the following publications by searching their publication numbers in the IBM Publications\nCenter.\nIMS\n• Application Programming API Reference, SC18-9699\n• Application Programming Guide, SC18-9698\nWebSphere Application Server for z/OS\n• Applications, SA22-7959\nSoftcopy publications for z/OS\nThe following collection kit contains z/OS and related product publications:\n• z/OS CD Collection Kit, SK3T-4269\nJava\n• IBM SDK for Java - Tools Documentation, publib.boulder.ibm.com/infocenter/javasdk/tools/index.jsp\n• The Java 2 Enterprise Edition Developer's Guide, download.oracle.com/javaee/1.2.1/devguide/html/\nDevGuideTOC.html\n• Java 2 on z/OS, www.ibm.com/servers/eserver/zseries/software/java/\n• The Java EE 5 Tutorial, download.oracle.com/javaee/5/tutorial/doc/\n• The Java Language Specification, Third Edition, by Gosling et al., java.sun.com/docs/books/jls/\nList of resources  1047"}
{"instruction": "Summarize this COBOL documentation section", "input": "DIAGTRUNC\nDIAGTRUNC causes the compiler to issue a severity-4 (Warning) diagnostic message for MOVE statements\nthat have numeric receivers when the receiving data item has fewer integer positions than the sending\ndata item or literal. In statements that have multiple receivers, the message is issued separately for each\nreceiver that could be truncated.\nDIAGTRUNC option syntax\nNODIAGTRUNC\nDIAGTRUNC\nDefault is: NODIAGTRUNC\nAbbreviations are: DTR | NODTR\nThe diagnostic message is also issued for implicit moves associated with statements such as these:\n• INITIALIZE\n• READ . . . INTO\n• RELEASE . . . FROM\n• RETURN . . . INTO\n• REWRITE . . . FROM\n• WRITE . . . FROM\nThe diagnostic message is also issued for moves to numeric receivers from alphanumeric data-names or\nliteral senders, except when the sending field is reference modified.\nThere is no diagnostic message for COMP-5 receivers, nor for binary receivers when you specify the\nTRUNC(BIN) option.\nRelated concepts   \n“Formats for numeric data” on page 53  \n“Reference modifiers” on page 116 \nRelated references   \n“TRUNC” on page 435 \nDISPSIGN\nThe DISPSIGN option controls output formatting for DISPLAY of signed numeric items.\nDISPSIGN option syntax\nDISPSIGN(\nCOMPAT\nSEP\n)\nDefault is: DISPSIGN(COMPAT)\nAbbreviations are: DS(C | S)\nDISPSIGN(COMPAT)\nIf you specify DISPSIGN(COMPAT), formatting for displayed values of signed numeric items is\ncompatible with prior versions of Enterprise COBOL. Overpunch signs are generated in some cases.\nDISPSIGN(SEP)\nIf you specify DISPSIGN(SEP), the displayed values for signed binary, signed packed-decimal, or\noverpunch signed zoned-decimal items are always formatted with a leading separate sign.\n376  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "DIAGTRUNC\nDIAGTRUNC causes the compiler to issue a severity-4 (Warning) diagnostic message for MOVE statements\nthat have numeric receivers when the receiving data item has fewer integer positions than the sending\ndata item or literal. In statements that have multiple receivers, the message is issued separately for each\nreceiver that could be truncated.\nDIAGTRUNC option syntax\nNODIAGTRUNC\nDIAGTRUNC\nDefault is: NODIAGTRUNC\nAbbreviations are: DTR | NODTR\nThe diagnostic message is also issued for implicit moves associated with statements such as these:\n• INITIALIZE\n• READ . . . INTO\n• RELEASE . . . FROM\n• RETURN . . . INTO\n• REWRITE . . . FROM\n• WRITE . . . FROM\nThe diagnostic message is also issued for moves to numeric receivers from alphanumeric data-names or\nliteral senders, except when the sending field is reference modified.\nThere is no diagnostic message for COMP-5 receivers, nor for binary receivers when you specify the\nTRUNC(BIN) option.\nRelated concepts   \n“Formats for numeric data” on page 53  \n“Reference modifiers” on page 116 \nRelated references   \n“TRUNC” on page 435 \nDISPSIGN\nThe DISPSIGN option controls output formatting for DISPLAY of signed numeric items.\nDISPSIGN option syntax\nDISPSIGN(\nCOMPAT\nSEP\n)\nDefault is: DISPSIGN(COMPAT)\nAbbreviations are: DS(C | S)\nDISPSIGN(COMPAT)\nIf you specify DISPSIGN(COMPAT), formatting for displayed values of signed numeric items is\ncompatible with prior versions of Enterprise COBOL. Overpunch signs are generated in some cases.\nDISPSIGN(SEP)\nIf you specify DISPSIGN(SEP), the displayed values for signed binary, signed packed-decimal, or\noverpunch signed zoned-decimal items are always formatted with a leading separate sign.\n376  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "Summarize this COBOL documentation section", "input": "The external security manager does not always return response and reason codes to CICS. Make sure\nthat you check the EIBRESP and EIBRESP2 values that are returned by this command in addition to\nchecking the ESMRESP and ESMREASON values.\nISUSERID(data-area)\nReturns an 8-byte user ID of a Kerberos principal that is associated with the token.\nOUTTOKEN(ptr-ref)\nReturns the address in 31-bit user-key storage of the output token that is obtained from an external\nsecurity manager.\nOUTTOKENLEN(data-area)\nReturns the length of an output token, in a fullword binary field with a maximum value of 1024.\nTOKEN(data-area)\nA token that is obtained from a Security Token Service (STS).\nTOKENLEN(data-value)\nThe length of the token as a fullword binary value.\nTOKENTYPE(cvda)\nIndicates the type of token.\nKERBEROS\nThe token is a Kerberos token.\nConditions\n16 INVREQ\nRESP2 values are as follows:\n13\nThe external security manager issues an unknown return code in ESMRESP.\n18\nThe CICS external security manager interface is not initialized.\n29\nThe external security manager is not responding.\n31\nA CVDA value other than KERBEROS was specified for TOKENTYPE.\n32\nA CVDA value other than BASE64 or BIT was specified for DATATYPE.\n36\nA data-type of BASE64 was specified, but TOKEN does not contain BASE64 data.\n40\nThe key distribution center is not started or is terminating.\n41\nThe key distribution center is not responding.\n47\nThe external security manager does not have a user ID defined for the Kerberos principal that is\nassociated with the token.\n50\nThe data that is specified in TOKEN is not a Kerberos token.\n51\nThe Kerberos token does not support message confidentiality.\n52\nThe Kerberos token indicates mutual authentication is in use, but OUTTOKEN and OUTTOKENLEN\nhave not been specified on the command.\nChapter 2. CICS command summary  579", "output": "The external security manager does not always return response and reason codes to CICS. Make sure\nthat you check the EIBRESP and EIBRESP2 values that are returned by this command in addition to\nchecking the ESMRESP and ESMREASON values.\nISUSERID(data-area)\nReturns an 8-byte user ID of a Kerberos principal that is associated with the token.\nOUTTOKEN(ptr-ref)\nReturns the address in 31-bit user-key storage of the output token that is obtained from an external\nsecurity manager.\nOUTTOKENLEN(data-area)\nReturns the length of an output token, in a fullword binary field with a maximum value of 1024.\nTOKEN(data-area)\nA token that is obtained from a Security Token Service (STS).\nTOKENLEN(data-value)\nThe length of the token as a fullword binary value.\nTOKENTYPE(cvda)\nIndicates the type of token.\nKERBEROS\nThe token is a Kerberos token.\nConditions\n16 INVREQ\nRESP2 values are as follows:\n13\nThe external security manager issues an unknown return code in ESMRESP.\n18\nThe CICS external security manager interface is not initialized.\n29\nThe external security manager is not responding.\n31\nA CVDA value other than KERBEROS was specified for TOKENTYPE.\n32\nA CVDA value other than BASE64 or BIT was specified for DATATYPE.\n36\nA data-type of BASE64 was specified, but TOKEN does not contain BASE64 data.\n40\nThe key distribution center is not started or is terminating.\n41\nThe key distribution center is not responding.\n47\nThe external security manager does not have a user ID defined for the Kerberos principal that is\nassociated with the token.\n50\nThe data that is specified in TOKEN is not a Kerberos token.\n51\nThe Kerberos token does not support message confidentiality.\n52\nThe Kerberos token indicates mutual authentication is in use, but OUTTOKEN and OUTTOKENLEN\nhave not been specified on the command.\nChapter 2. CICS command summary  579"}
{"instruction": "Explain this COBOL concept", "input": "In assembler language, if the SET option is being used, the specified register has not been set, but\ncan be loaded from DFHEITP1.\nDefault action: terminate the task abnormally.\n20 ENDFILE\nRESP2 values:\n90\nAn end-of-file condition is detected during a browse.\nDefault action: terminate the task abnormally.\n12 FILENOTFOUND\nRESP2 values:\n1\nA file name referred to in the FILE option is not defined to CICS.\nDefault action: terminate the task abnormally.\n21 ILLOGIC\nThe browse that is currently in progress is terminated when this condition is raised.\nRESP2 values (VSAM):\n110\nA VSAM error occurs that is not in one of the other CICS response categories.\nSee EIBRCODE in the EXEC interface block; for details, see EIB fields.\nDefault action: terminate the task abnormally.\n16 INVREQ\nRESP2 values:\n20\nThe FILE definition does not allow updates.\n24\nA READPREV command is issued for a file for which the previous STARTBR or RESETBR command\nhas the GENERIC option.\n26\nThe KEYLENGTH option is specified and the specified length does not equal the length defined for\nthe data set for this file refers to.\n37\nThe type of record identification (for example, key or relative byte address) used to access a data\nset during the browse has been changed. You cannot specify one type of addressing on STARTBR\nand another on READPREV.\n39\nA READPREV is issued for a BDAM file.\n41\nThe REQID, SYSID, or file name does not match that of any successful STARTBR command.\n52\nCONSISTENT is not allowed because the file is not a VSAM file that is accessed in RLS mode.\n53\nREPEATABLE is not allowed because the file is not a VSAM file that is accessed in RLS mode.\n54\nUPDATE is not allowed because the file is not a VSAM file that is accessed in RLS mode.\n55\nNOSUSPEND is not allowed because the file is not a VSAM file that is accessed in RLS mode.\n374  CICS TS for z/OS: API Reference", "output": "In assembler language, if the SET option is being used, the specified register has not been set, but\ncan be loaded from DFHEITP1.\nDefault action: terminate the task abnormally.\n20 ENDFILE\nRESP2 values:\n90\nAn end-of-file condition is detected during a browse.\nDefault action: terminate the task abnormally.\n12 FILENOTFOUND\nRESP2 values:\n1\nA file name referred to in the FILE option is not defined to CICS.\nDefault action: terminate the task abnormally.\n21 ILLOGIC\nThe browse that is currently in progress is terminated when this condition is raised.\nRESP2 values (VSAM):\n110\nA VSAM error occurs that is not in one of the other CICS response categories.\nSee EIBRCODE in the EXEC interface block; for details, see EIB fields.\nDefault action: terminate the task abnormally.\n16 INVREQ\nRESP2 values:\n20\nThe FILE definition does not allow updates.\n24\nA READPREV command is issued for a file for which the previous STARTBR or RESETBR command\nhas the GENERIC option.\n26\nThe KEYLENGTH option is specified and the specified length does not equal the length defined for\nthe data set for this file refers to.\n37\nThe type of record identification (for example, key or relative byte address) used to access a data\nset during the browse has been changed. You cannot specify one type of addressing on STARTBR\nand another on READPREV.\n39\nA READPREV is issued for a BDAM file.\n41\nThe REQID, SYSID, or file name does not match that of any successful STARTBR command.\n52\nCONSISTENT is not allowed because the file is not a VSAM file that is accessed in RLS mode.\n53\nREPEATABLE is not allowed because the file is not a VSAM file that is accessed in RLS mode.\n54\nUPDATE is not allowed because the file is not a VSAM file that is accessed in RLS mode.\n55\nNOSUSPEND is not allowed because the file is not a VSAM file that is accessed in RLS mode.\n374  CICS TS for z/OS: API Reference"}
{"instruction": "What are the compiler rules or directives for this?", "input": "must not be placed in the middle of a group data item. The directive also applies", "output": "must not be placed in the middle of a group data item. The directive also applies"}
{"instruction": "Summarize this COBOL documentation section", "input": "30\nAn input/output error has occurred on the repository file.\n70 NOTAUTH\nRESP2 values:\n101\nThe user associated with the issuing task is not authorized to access this resource in the way\nrequested.\n108 PROCESSERR\nRESP2 values:\n1\nNo processes of this process-type could be found.\n4\nThe process-type specified on the PROCESSTYPE option could not be found.\n13\nThe request timed out. It may be that another task using this process-record has been prevented\nfrom ending.\nSTARTBROWSE TIMER\nStart a browse of a BTS timer.\nSTARTBROWSE TIMER\nSTARTBROWSE\nTIMER(  data-value )\nACTIVITYID(  data-value )\nBROWSETOKEN(  data-area )\nConditions: ACTIVITYERR, INVREQ, IOERR, NOTAUTH, TIMERERR\nDescription\nSTARTBROWSE TIMER initializes a browse token that can be used to identify a BTS timer.\nOptions\nACTIVITYID(data-value)\nSpecifies the identifier (1–52 characters) of the activity with which the timer is associated.\nIf this option is omitted, the current activity is assumed.\nBROWSETOKEN(data-area)\nSpecifies a fullword binary data area, into which CICS will place the browse token.\nTIMER(data-value)\nSpecifies the name (1–16 characters) of the timer.\nConditions\n109 ACTIVITYERR\nRESP2 values:\n3\nThe activity indicated by the ACTIVITYID option could not be found.\n29\nThe repository file is unavailable.\n30\nAn input/output error has occurred on the repository file.\n550  CICS TS for z/OS: API Reference", "output": "30\nAn input/output error has occurred on the repository file.\n70 NOTAUTH\nRESP2 values:\n101\nThe user associated with the issuing task is not authorized to access this resource in the way\nrequested.\n108 PROCESSERR\nRESP2 values:\n1\nNo processes of this process-type could be found.\n4\nThe process-type specified on the PROCESSTYPE option could not be found.\n13\nThe request timed out. It may be that another task using this process-record has been prevented\nfrom ending.\nSTARTBROWSE TIMER\nStart a browse of a BTS timer.\nSTARTBROWSE TIMER\nSTARTBROWSE\nTIMER(  data-value )\nACTIVITYID(  data-value )\nBROWSETOKEN(  data-area )\nConditions: ACTIVITYERR, INVREQ, IOERR, NOTAUTH, TIMERERR\nDescription\nSTARTBROWSE TIMER initializes a browse token that can be used to identify a BTS timer.\nOptions\nACTIVITYID(data-value)\nSpecifies the identifier (1–52 characters) of the activity with which the timer is associated.\nIf this option is omitted, the current activity is assumed.\nBROWSETOKEN(data-area)\nSpecifies a fullword binary data area, into which CICS will place the browse token.\nTIMER(data-value)\nSpecifies the name (1–16 characters) of the timer.\nConditions\n109 ACTIVITYERR\nRESP2 values:\n3\nThe activity indicated by the ACTIVITYID option could not be found.\n29\nThe repository file is unavailable.\n30\nAn input/output error has occurred on the repository file.\n550  CICS TS for z/OS: API Reference"}
{"instruction": "What is This in COBOL?", "input": "", "output": "This is default if the CHUNKING option\nis not specified"}
{"instruction": "Explain this COBOL concept", "input": "Varying three identifiers\nThe topic lists steps of varying three identifiers.\nPERFORM PROCEDURE-NAME-1 THROUGH PROCEDURE-NAME-2\n      VARYING IDENTIFIER-2 FROM IDENTIFIER-3\n            BY IDENTIFIER-4 UNTIL CONDITION-1\n          AFTER IDENTIFIER-5 FROM IDENTIFIER-6\n            BY IDENTIFIER-7 UNTIL CONDITION-2\n          AFTER IDENTIFIER-8 FROM IDENTIFIER-9\n            BY IDENTIFIER-10 UNTIL CONDITION-3\nThe actions are the same as those for two identifiers, except that identifier-8 goes through the complete\ncycle each time that identifier-5 is augmented by identifier-7, which, in turn, goes through a complete\ncycle each time that identifier-2 is varied.\nAt the end of PERFORM statement execution:\n• identifier-5 and identifier-8 contain the current values of identifier-6 and identifier-9, respectively.\n• identifier-2 has a value exceeding its last-used setting by one increment/decrement value (unless\ncondition-1 was true at the beginning of PERFORM statement execution, in which case identifier-2\ncontains the current value of identifier-3).\nVarying more than three identifiers\nYou can produce analogous PERFORM statement actions to the previous example with the addition of up\nto four AFTER phrases.\nVarying phrase rules\nThere are certain rules that apply to this phrase, no matter how many variables are specified.\nThe rules are:\n• In the VARYING or AFTER phrases, when an index-name is specified:\nChapter 28. PROCEDURE DIVISION statements  433", "output": "Varying three identifiers\nThe topic lists steps of varying three identifiers.\nPERFORM PROCEDURE-NAME-1 THROUGH PROCEDURE-NAME-2\n      VARYING IDENTIFIER-2 FROM IDENTIFIER-3\n            BY IDENTIFIER-4 UNTIL CONDITION-1\n          AFTER IDENTIFIER-5 FROM IDENTIFIER-6\n            BY IDENTIFIER-7 UNTIL CONDITION-2\n          AFTER IDENTIFIER-8 FROM IDENTIFIER-9\n            BY IDENTIFIER-10 UNTIL CONDITION-3\nThe actions are the same as those for two identifiers, except that identifier-8 goes through the complete\ncycle each time that identifier-5 is augmented by identifier-7, which, in turn, goes through a complete\ncycle each time that identifier-2 is varied.\nAt the end of PERFORM statement execution:\n• identifier-5 and identifier-8 contain the current values of identifier-6 and identifier-9, respectively.\n• identifier-2 has a value exceeding its last-used setting by one increment/decrement value (unless\ncondition-1 was true at the beginning of PERFORM statement execution, in which case identifier-2\ncontains the current value of identifier-3).\nVarying more than three identifiers\nYou can produce analogous PERFORM statement actions to the previous example with the addition of up\nto four AFTER phrases.\nVarying phrase rules\nThere are certain rules that apply to this phrase, no matter how many variables are specified.\nThe rules are:\n• In the VARYING or AFTER phrases, when an index-name is specified:\nChapter 28. PROCEDURE DIVISION statements  433"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "SECERROR\nThe child task failed to attach due to a security error. ABCODE is blank.\nNOSUSPEND\nSpecifi", "output": "SECERROR\nThe child task failed to attach due to a security error. ABCODE is blank.\nNOSUSPEND\nSpecifies that the command will return immediately without waiting for any remaining child tasks to\ncomplete. If at least one of the unfetched children is completed, the command will return with a\nnormal response.\nTIMEOUT(data-value)\nSpecifies a fullword binary data-value which is the maximum time in milliseconds that the command\nwill wait for any remaining child tasks to complete before the command returns. The maximum value\nis 40800000 milliseconds. If TIMEOUT is not specified, or the specified value is zero, the command is\nnot timed out.\nConditions\n113 NOTFINISHED\nRESP2 values:\n52\nNOSUSPEND was specified, but there were no completed children to fetch when the command was\nrun.\n53\nNo children have completed within the interval specified by the TIMEOUT option.\n13 NOTFND\nRESP2 values:\n1\nNo unfetched children were found.\n16 INVREQ\nRESP2 values:\n52\nThe parent has no children.\n241\nTIMEOUT value is not valid.\nFETCH CHILD\nThe EXEC CICS FETCH CHILD command is used by a parent task to inquire on the status of a specific\nchild task, and returns the status of the specified child task.\nFETCH CHILD\nFETCH\nCHILD( data-value )\nCHANNEL(  data-area )\nCOMPSTATUS(  cvda)\nABCODE(  data-area )\nNOSUSPEND\nTIMEOUT(  data-value )\nConditions: INVREQ, NOTFINISHED\nThis command is threadsafe.\nDescription\nEXEC CICS FETCH CHILD is used by a parent task to inquire on the status of a specific child task, which\nis identified by the child token. FETCH CHILD will return when the child task is completed.\n182  CICS TS for z/OS: API Reference"}
{"instruction": "Explain this COBOL concept", "input": "FREE CHILD\nThe EXEC CICS FREE CHILD command frees a specified child token which has been previously\nallocated by an EXEC CICS RUN TRANSID command. If a parent task no longer requires the response of\na child task, then using the FREE CHILD command will free the resources associated with that child task\nwhen it completes, rather than waiting for them to be fetched.\nFREE CHILD\nFREE\nCHILD( data-value )\nConditions: INVREQ\nThis command is threadsafe.\nDescription\nFREE CHILD is used by a parent task to free a child token allocated by a previous RUN TRANSID\ncommand. If the associated child task has already completed, then the memory object associated with\nthe token is freed immediately, and CICS will also free any child channel (providing it has not been fetched\nusing an EXEC CICS FETCH command).\nIf the child task has not completed, the memory object will be freed when the child completes, along with\nany child channel. After this command is issued, any subsequent attempt to reference the token with the\nFETCH CHILD command will fail with INVREQ, nor will the token be returned by any subsequent FETCH\nANY commands.\nCICS implicitly frees all child tokens created by RUN TRANSID when the parent task terminates.\nOptions\nCHILD(data-value)\nSpecifies the child token to be freed. The child token will have been returned from the RUN TRANSID\ncommand.\nConditions\n16 INVREQ\nRESP2 values:\n50\nThe data that is specified in CHILD is not a valid child token, or the child task has already been\nfreed by a FREE CHILD command.\nFREEMAIN\nRelease main storage that was acquired by using a GETMAIN request.\nFREEMAIN\nFREEMAIN\nDATA(  data-area )\nDATAPOINTER(  ptr-value )\nCondition:\nThis command is threadsafe.\nDescription\nFREEMAIN releases the following storage:\n• Main storage that was acquired by a GETMAIN command issued by the application.\nChapter 2. CICS command summary  193", "output": "FREE CHILD\nThe EXEC CICS FREE CHILD command frees a specified child token which has been previously\nallocated by an EXEC CICS RUN TRANSID command. If a parent task no longer requires the response of\na child task, then using the FREE CHILD command will free the resources associated with that child task\nwhen it completes, rather than waiting for them to be fetched.\nFREE CHILD\nFREE\nCHILD( data-value )\nConditions: INVREQ\nThis command is threadsafe.\nDescription\nFREE CHILD is used by a parent task to free a child token allocated by a previous RUN TRANSID\ncommand. If the associated child task has already completed, then the memory object associated with\nthe token is freed immediately, and CICS will also free any child channel (providing it has not been fetched\nusing an EXEC CICS FETCH command).\nIf the child task has not completed, the memory object will be freed when the child completes, along with\nany child channel. After this command is issued, any subsequent attempt to reference the token with the\nFETCH CHILD command will fail with INVREQ, nor will the token be returned by any subsequent FETCH\nANY commands.\nCICS implicitly frees all child tokens created by RUN TRANSID when the parent task terminates.\nOptions\nCHILD(data-value)\nSpecifies the child token to be freed. The child token will have been returned from the RUN TRANSID\ncommand.\nConditions\n16 INVREQ\nRESP2 values:\n50\nThe data that is specified in CHILD is not a valid child token, or the child task has already been\nfreed by a FREE CHILD command.\nFREEMAIN\nRelease main storage that was acquired by using a GETMAIN request.\nFREEMAIN\nFREEMAIN\nDATA(  data-area )\nDATAPOINTER(  ptr-value )\nCondition:\nThis command is threadsafe.\nDescription\nFREEMAIN releases the following storage:\n• Main storage that was acquired by a GETMAIN command issued by the application.\nChapter 2. CICS command summary  193"}
{"instruction": "Summarize this COBOL documentation section", "input": "EBCDIC DBCS\nSee double-byte EBCDIC.\nedited data item\nA data item that has been modified by suppressing zeros or inserting editing characters or both.\n* editing character\nA single character or a fixed two-character combination belonging to the following set:\nCharacter\nMeaning\nSpace\n0\nZero\n+\nPlus\n-\nMinus\nCR\nCredit\nDB\nDebit\nZ\nZero suppress\n*\nCheck protect\n$\nCurrency sign\n,\nComma (decimal point)\n.\nPeriod (decimal point)\n/\nSlant (forward slash)\nEGCS\nSee extended graphic character set (EGCS).\nEJB\nSee Enterprise JavaBeans.\nEJB container\nA container that implements the EJB component contract of the J2EE architecture. This contract\nspecifies a runtime environment for enterprise beans that includes security, concurrency, life cycle\nmanagement, transaction, deployment, and other services. An EJB container is provided by an EJB or\nJ2EE server. (Oracle)\nEJB server\nSoftware that provides services to an EJB container. An EJB server can host one or more EJB\ncontainers. (Oracle)\nelement (text element)\nOne logical unit of a string of text, such as the description of a single data item or verb, preceded by a\nunique code identifying the element type.\n* elementary item\nA data item that is described as not being further logically subdivided.\nencapsulation\nIn object-oriented programming, the technique that is used to hide the inherent details of an\nobject. The object provides an interface that queries and manipulates the data without exposing\nits underlying structure. Synonymous with information hiding.\nenclave\nWhen running under Language Environment, an enclave is analogous to a run unit. An enclave can\ncreate other enclaves by using LINK and by using the system() function in C.\nencoding unit\nSee character encoding unit.\n1014  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "EBCDIC DBCS\nSee double-byte EBCDIC.\nedited data item\nA data item that has been modified by suppressing zeros or inserting editing characters or both.\n* editing character\nA single character or a fixed two-character combination belonging to the following set:\nCharacter\nMeaning\nSpace\n0\nZero\n+\nPlus\n-\nMinus\nCR\nCredit\nDB\nDebit\nZ\nZero suppress\n*\nCheck protect\n$\nCurrency sign\n,\nComma (decimal point)\n.\nPeriod (decimal point)\n/\nSlant (forward slash)\nEGCS\nSee extended graphic character set (EGCS).\nEJB\nSee Enterprise JavaBeans.\nEJB container\nA container that implements the EJB component contract of the J2EE architecture. This contract\nspecifies a runtime environment for enterprise beans that includes security, concurrency, life cycle\nmanagement, transaction, deployment, and other services. An EJB container is provided by an EJB or\nJ2EE server. (Oracle)\nEJB server\nSoftware that provides services to an EJB container. An EJB server can host one or more EJB\ncontainers. (Oracle)\nelement (text element)\nOne logical unit of a string of text, such as the description of a single data item or verb, preceded by a\nunique code identifying the element type.\n* elementary item\nA data item that is described as not being further logically subdivided.\nencapsulation\nIn object-oriented programming, the technique that is used to hide the inherent details of an\nobject. The object provides an interface that queries and manipulates the data without exposing\nits underlying structure. Synonymous with information hiding.\nenclave\nWhen running under Language Environment, an enclave is analogous to a run unit. An enclave can\ncreate other enclaves by using LINK and by using the system() function in C.\nencoding unit\nSee character encoding unit.\n1014  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "Explain this COBOL concept", "input": "TERMINAL\nspecifies that storage areas associated with the terminal are to be dumped, as follows:\n• Task control area (TCA) and, if applicable, the transaction work area (TWA)\n• Common system area (CSA), including the user's portion of the CSA (CWA)\n• Trace entries relating to the task written to the internal trace table (only when the CICS trace facility\nis active)\n• All terminal input/output areas (TIOAs) chained off the terminal control table terminal entry (TCTTE)\nfor the terminal associated with the requesting task as long as the request is not a write, or storage\nfreezing is on for the task or the terminal\n• Either the terminal control table terminal entry (TCTTE) or the transient data queue definition\nassociated with the requesting task.\nWhenever the TCTTE is dumped, the terminal control table user area (if any) and the message control\nblocks (if any) associated with the TCTTE are dumped. The latter are used by basic mapping support.\nTRT\ndumps the trace entries relating to the task written to the internal trace table.\nConditions\n16 INVREQ\nRESP2 values:\n13\nAn incorrect DUMPCODE is specified. DUMPCODE contains unprintable characters, or leading or\nimbedded blanks.\nThe dump is produced but no entry is added to the system dump table.\nDefault action: terminate the task abnormally.\n17 IOERR\nRESP2 values:\n9\nThe SDUMP process is not authorized.\n10\nAn error occurred during system dumping.\n13\nThe CICS routine issuing the SDUMP is unable to establish a recovery routine (FESTAE).\nDefault action: terminate the task abnormally.\n18 NOSPACE\nRESP2 values:\n4\nThe transaction dump is incomplete due to lack of space.\nDefault action: terminate the task abnormally.\n42 NOSTG\nRESP2 values:\n5\nCICS has run out of working storage.\nDefault action: terminate the task abnormally.\n19 NOTOPEN\nRESP2 values:\n148  CICS TS for z/OS: API Reference", "output": "TERMINAL\nspecifies that storage areas associated with the terminal are to be dumped, as follows:\n• Task control area (TCA) and, if applicable, the transaction work area (TWA)\n• Common system area (CSA), including the user's portion of the CSA (CWA)\n• Trace entries relating to the task written to the internal trace table (only when the CICS trace facility\nis active)\n• All terminal input/output areas (TIOAs) chained off the terminal control table terminal entry (TCTTE)\nfor the terminal associated with the requesting task as long as the request is not a write, or storage\nfreezing is on for the task or the terminal\n• Either the terminal control table terminal entry (TCTTE) or the transient data queue definition\nassociated with the requesting task.\nWhenever the TCTTE is dumped, the terminal control table user area (if any) and the message control\nblocks (if any) associated with the TCTTE are dumped. The latter are used by basic mapping support.\nTRT\ndumps the trace entries relating to the task written to the internal trace table.\nConditions\n16 INVREQ\nRESP2 values:\n13\nAn incorrect DUMPCODE is specified. DUMPCODE contains unprintable characters, or leading or\nimbedded blanks.\nThe dump is produced but no entry is added to the system dump table.\nDefault action: terminate the task abnormally.\n17 IOERR\nRESP2 values:\n9\nThe SDUMP process is not authorized.\n10\nAn error occurred during system dumping.\n13\nThe CICS routine issuing the SDUMP is unable to establish a recovery routine (FESTAE).\nDefault action: terminate the task abnormally.\n18 NOSPACE\nRESP2 values:\n4\nThe transaction dump is incomplete due to lack of space.\nDefault action: terminate the task abnormally.\n42 NOSTG\nRESP2 values:\n5\nCICS has run out of working storage.\nDefault action: terminate the task abnormally.\n19 NOTOPEN\nRESP2 values:\n148  CICS TS for z/OS: API Reference"}
{"instruction": "Summarize this COBOL documentation section", "input": "Procedure division returning retval.\n       End function GetRecord.\nThis copybook is included along with the user-defined function definition in another compilation group.\n       Copy GETREC.\n       Identification division.\n         Function-id. GetRecord.\n       Data division.\n        Linkage section.\n         1 retval pic x(100).\n       Procedure division returning retval.\n           move \"data\" to retval\n           goback.\n       End function GetRecord.\nThe copybook is also included in any compilation group where \"GetRecord\" is invoked.\n       Copy GETREC.\n       Identification division.\n         Program-id. myprog.\n       Data division.\n        Working-storage section.\n         1 a pic x(100).\n       Procedure division.\n           move function GetRecord to a\n           goback.\n       End program myprog.\nLanguage standard considerations\nThe function prototypes feature in Enterprise COBOL is based on the ISO/IEC 2014 COBOL standard.\nSome parts of this feature in Enterprise COBOL, however, have been modified and are specific to\nEnterprise COBOL.\nThe modified parts are as follows:\n• The optional ENTRY-INTERFACE paragraph: this is based loosely upon the ENTRY-CONVENTION clause\nof the OPTIONAL paragraph of the IDENTIFICATION DIVISION in the standard. The implementation\nof the IDENTIFICATION DIVISION syntax is different than the COBOL standard, so to follow the\nconventions, ENTRY-INTERFACE was made a paragraph rather than a clause.\n• The optional ENTRY-NAME paragraph: the reason is the same as above.\nChapter 34. Using function prototypes  629", "output": "Procedure division returning retval.\n       End function GetRecord.\nThis copybook is included along with the user-defined function definition in another compilation group.\n       Copy GETREC.\n       Identification division.\n         Function-id. GetRecord.\n       Data division.\n        Linkage section.\n         1 retval pic x(100).\n       Procedure division returning retval.\n           move \"data\" to retval\n           goback.\n       End function GetRecord.\nThe copybook is also included in any compilation group where \"GetRecord\" is invoked.\n       Copy GETREC.\n       Identification division.\n         Program-id. myprog.\n       Data division.\n        Working-storage section.\n         1 a pic x(100).\n       Procedure division.\n           move function GetRecord to a\n           goback.\n       End program myprog.\nLanguage standard considerations\nThe function prototypes feature in Enterprise COBOL is based on the ISO/IEC 2014 COBOL standard.\nSome parts of this feature in Enterprise COBOL, however, have been modified and are specific to\nEnterprise COBOL.\nThe modified parts are as follows:\n• The optional ENTRY-INTERFACE paragraph: this is based loosely upon the ENTRY-CONVENTION clause\nof the OPTIONAL paragraph of the IDENTIFICATION DIVISION in the standard. The implementation\nof the IDENTIFICATION DIVISION syntax is different than the COBOL standard, so to follow the\nconventions, ENTRY-INTERFACE was made a paragraph rather than a clause.\n• The optional ENTRY-NAME paragraph: the reason is the same as above.\nChapter 34. Using function prototypes  629"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "5\nA browse of keyword parameters is already in progress.\n16 INVREQ\nRESP2 values are:\n1\nThe command i", "output": "5\nA browse of keyword parameters is already in progress.\n16 INVREQ\nRESP2 values are:\n1\nThe command is being issued in a non-CICS Web support application.\n3\nThe command is being issued for a non-HTTP request.\n12\nThe host code page cannot be found.\n13\nNo keyword parameters found.\n14\nThe code page combination for client and server is invalid.\n17\nInvalid keyword parameters found in the HTTP request.\n22 LENGERR\nRESP2 value is:\n1\nAn invalid value for the NAMELEN parameter has been provided.\n13 NOTFND\nRESP2 value is:\n1\nKeyword parameter not found.\nWEB WRITE HTTPHEADER\nBuild HTTP header information.\nWEB WRITE HTTPHEADER\nWEB\nWRITE\nHTTPHEADER(  data-area )\nNAMELENGTH(  data-value )\nSESSTOKEN(  data-value )\nVALUE(  data-area )\nVALUELENGTH(  data-value )\nConditions: INVREQ, LENGERR, NOTOPEN\nThis command is threadsafe.\nDescription\nWEB WRITE HTTPHEADER enables an application to add HTTP header information to a message. When\nCICS is an HTTP server, the message is a response to a Web client. When CICS is an HTTP client, the\nmessage is a request to a server, and the SESSTOKEN option is specified.\nSome HTTP headers are created automatically by CICS if the message requires them, and the application\ndoes not need to write these headers. These are:\n• ARM correlator\n• Connection\n• Content-Type (written by CICS, but can be supplied by a client application if a complex header is\nrequired)\n666  CICS TS for z/OS: API Reference"}
{"instruction": "What are the compiler rules or directives for this?", "input": "and RUN commands to create and run a server process, which carries", "output": "and RUN commands to create and run a server process, which carries"}
{"instruction": "What is where n in COBOL?", "input": "", "output": "where n is number of characters in the literal"}
{"instruction": "What is which in COBOL?", "input": "", "output": "which is default when the LP option\nis not specified, and specify the -m MIX_31_64 option when running the cjbuild utility"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 141. SYSADATA symbol record (continued)\nField\nSize\nDescription\nClauses\nXL1\nClauses specified i", "output": "Table 141. SYSADATA symbol record (continued)\nField\nSize\nDescription\nClauses\nXL1\nClauses specified in symbol definition.\nFor symbols that have a symbol attribute of Numeric (X'01'),\nElementary character (X'02'), Group (X'03'), Pointer (X'04'),\nIndex data item (X'05'), or Object reference (X'18'):\n1... ....\nValue\n.1.. ....\nIndexed\n..1. ....\nRedefines\n...1 ....\nRenames\n.... 1...\nOccurs\n.... .1..\nHas Occurs keys\n.... ..1.\nOccurs Depending On\n.... ...1\nOccurs in parent\nFor file types:\n1... ....\nSelect\n.1.. ....\nAssign\n..1. ....\nRerun\n...1 ....\nSame area\n.... 1...\nSame record area\n.... .1..\nRecording mode\n.... ..1.\nReserved\n.... ...1\nRecord\nAppendix G. COBOL SYSADATA file contents  955"}
{"instruction": "What is 47 SELNERR\noccurs if there in COBOL?", "input": "", "output": "47 SELNERR\noccurs if there is error during destination selection"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "8\nThe activity named on the ACTIVITY option could not be found.\n14\nThe target activity is not in the", "output": "8\nThe activity named on the ACTIVITY option could not be found.\n14\nThe target activity is not in the correct mode to process the specified event option. If the\nINPUTEVENT option was not specified, the activity must be in INITIAL mode. If the INPUTEVENT\noption was specified, the activity must be in DORMANT mode.\n111 EVENTERR\nRESP2 values:\n7\nThe event named on the INPUTEVENT option has not been defined by the activity to be run as an\ninput event; or its fire status is FIRED.\n16 INVREQ\nRESP2 values:\n4\nThe ACTIVITY option was used to name a child activity, but the command was issued outside the\nscope of a currently-active activity.\n21\nThe activity is suspended, and therefore cannot be run synchronously.\n24\nThe ACQACTIVITY option was used, but the issuing task has not acquired an activity.\n40\nThe program that implements the activity is remote.\n44\nA LINK has been attempted to a Java program, but the JVM pool is disabled.\n45\nA LINK has been attempted to a Java program, but the JVM profile cannot be found.\n46\nA LINK has been attempted to a Java program, but the JVM profile is not valid.\n47\nA LINK has been attempted to a Java program, but the system properties file cannot be found.\n48\nA LINK has been attempted to a Java program, but the user class cannot be found.\n49\nThe shared class cache is STOPPED and autostart is disabled, so a Java program requesting use of\nthe shared class cache cannot be executed.\n17 IOERR\nRESP2 values:\n29\nThe repository file is unavailable.\n30\nAn input/output error has occurred on the repository file.\n100 LOCKED\nThe request cannot be performed because a retained lock exists against the relevant record on the\nrepository file.\n70 NOTAUTH\nRESP2 values:\n101\nThe user associated with the issuing task is not authorized to run the activity.\n27 PGMIDERR\nRESP2 values:\n314  CICS TS for z/OS: API Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 137. SYSADATA token record (continued)\nField\nSize\nDescription\n \n \n1211\nFACTORY\n1212\nOBJECT\n121", "output": "Table 137. SYSADATA token record (continued)\nField\nSize\nDescription\n \n \n1211\nFACTORY\n1212\nOBJECT\n1213\nFUNCTION-ID\n2020\nTRACE\n2046\nSUPPRESS\n3000\nDATADEF\n3001\nF-NAME\n3002\nUPSI-SWITCH\n3003\nCONDNAME\n3004\nCONDVAR\n3005\nBLOB\n3006\nCLOB\n3007\nDBCLOB\n3008\nBLOB-LOCATOR\n3009\nCLOB-LOCATOR\n3010\nDBCLOB-LOCATOR\n3011\nBLOB-FILE\n3012\nCLOB-FILE\n3013\nDBCLOB-FILE\n3014\nDFHRESP\n948  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What is base_address\nHere comp_s1 in COBOL?", "input": "", "output": "base_address\nHere comp_s1 is value of S1 after conversion to binary, comp-s2 is the value of S2 after conversion\nto binary, and so on"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "INVOKE statement\nThe INVOKE statement can create object instances of a COBOL or Java class and can i", "output": "INVOKE statement\nThe INVOKE statement can create object instances of a COBOL or Java class and can invoke a method\ndefined in a COBOL or Java class.\nFormat\nINVOKE\nidentifier-1\nclass-name-1\nSELF\nSUPER\nliteral-1\nidentifier-2\nNEW\nUSING\nBY\nVALUE\nLENGTH OF\nidentifier-3\nliteral-2\nRETURNING\nidentifier-4\nON\nEXCEPTION\nimperative-statement-1\nNOT\nON\nEXCEPTION\nimperative-statement-2\nEND-INVOKE\nidentifier-1\nMust be defined as USAGE OBJECT REFERENCE. The contents of identifier-1 specify the object on\nwhich a method is invoked.\nWhen identifier-1 is specified, either literal-1 or identifier-2 must be specified, identifying the name of\nthe method to be invoked.\nIt must not be a dynamic-length elementary item or a dynamic-length group item.\nThe results of the INVOKE statement are undefined if either:\n• identifier-1 does not contain a valid reference to an object.\n• identifier-1 contains NULL.\nclass-name-1\nWhen class-name-1 is specified together with literal-1 or identifier-2, the INVOKE statement invokes a\nstatic or factory method of the class referenced by class-name-1. literal-1 or identifier-2 specifies the\nname of the method that is to be invoked. The method must be a static method if class-name-1 is a\nJava class; the method must be a factory method if class-name-1 is a COBOL class.\nWhen class-name-1 is specified together with NEW, the INVOKE statement creates a new object that\nis an instance of class class-name-1.\nYou must specify class-name-1 in the REPOSITORY paragraph of the configuration section of the class\nor program that contains the INVOKE statement.\nChapter 28. PROCEDURE DIVISION statements  369"}
{"instruction": "What are the compiler rules or directives for this?", "input": "is in effect, the unsigned value of the integer operand is moved to the", "output": "is in effect, the unsigned value of the integer operand is moved to the"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "SEND (z/OS Communications Server default)\nWrite data to a standard CICS supported terminal.\nSEND (z/", "output": "SEND (z/OS Communications Server default)\nWrite data to a standard CICS supported terminal.\nSEND (z/OS Communications Server default)\nSEND\nFROM( data-area )\nLENGTH( data-value )\nFLENGTH(  data-value )\nWAIT\nConditions: INVREQ, LENGERR, NOTALLOC\n \nDescription\nSEND writes data to a terminal. This form of the send command can be used by all CICS-supported\nterminals for which the other SEND descriptions are not appropriate.\nSEND (APPC)\nSend data on an APPC mapped conversation.\nSEND (APPC)\nSEND\nCONVID(  name )\nFROM( data-area )\nLENGTH( data-value )\nFLENGTH(  data-value )\nINVITE\nLAST\nCONFIRM\nWAIT\nSTATE(  cvda)\nConditions: INVREQ, LENGERR, NOTALLOC, SIGNAL, TERMERR\nDescription\nSEND sends data to a conversation partner on an APPC mapped conversation.\n446  CICS TS for z/OS: API Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "59.12  IGYPS8169  \"USE FOR DEBUGGING statement\":  obsolete element\n                       in ANS/ISO", "output": "59.12  IGYPS8169  \"USE FOR DEBUGGING statement\":  obsolete element\n                       in ANS/ISO 1985.\n FIPS MESSAGES TOTAL             STANDARD      NONSTANDARD      OBSOLETE\n                 3                   1               1              1\nYou can convert FIPS informational messages into diagnostic messages, and can suppress FIPS\nmessages, by using the MSGEXIT suboption of the EXIT compiler option. For details, see the related\nreference about the processing of MSGEXIT, and see the related task.\nRelated tasks   \n“Customizing compiler-message severities” on page 861  \nRelated references  \n“Conflicting compiler options” on page 358  \n“Processing of MSGEXIT” on page 859  \nHGPR\nThe HGPR option controls the compiler usage of the 64-bit registers provided by IBM z/Architecture\nprocessors.\nHGPR option syntax\nHGPR(\nPRESERVE\nNOPRESERVE\n)\nDefault is: HGPR(PRESERVE)\nAbbreviations are: None\nThe Enterprise COBOL compiler uses the 64-bit width of the IBM z/Architecture General Purpose\nRegisters (GPRs). HGPR stands for \"High-halves of 64-bit GPRs\", which means the use of native 64-bit\ninstructions.\nHGPR(PRESERVE)\nIf you specify HGPR(PRESERVE), the compiler preserves the high halves of the 64-bit GPRs that a\nprogram is using, by saving them in the prolog for the function and restoring them in the epilog. The\nPRESERVE suboption is necessary only if the caller of the program is not Enterprise COBOL, Enterprise\nPL/I, or z/OS XL C/C++ compiler-generated code.\nHGPR(NOPRESERVE)\nIf you specify HGPR(NOPRESERVE), the compiler omits preserving the high-halves of the 64-bit GPRs\nthat a program is using, which improves performance.\nRelated tasks   \n“Using COBOL user exit routines with DFSORT” on page 251\n386  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "Explain this COBOL concept", "input": "Table 63. Terms used in MAP output (continued)\nTerm\nDefinition\nDescription\nPOINTER\nDS nC\nPointer data item (USAGE POINTER)\nPROCEDURE-PTR\nDS nC\nProcedure pointer (USAGE PROCEDURE-POINTER)\nSD\n \nSort file definition\nVSAM, QSAM,\nLINESEQ\n \nFile processing method\n1-49, 77\n \nLevel-numbers for data descriptions\n66\n \nLevel-number for RENAMES\n88\n \nLevel-number for condition-names\n1. n is the size in bytes for fixed-length groups and the maximum size in bytes for variable-length groups.\n2. If the SYNCHRONIZED clause appears, these fields are used.\nSymbols used in LIST and MAP output\nThe following table describes the symbols used in the listings produced by the LIST or MAP option.\nTable 64. Symbols used in LIST and MAP output\nSymbol\nDefinition\nBLF_n1\nBase locator for files\nBLL_n1\nBase locator for LINKAGE SECTION\nBLO_n1\nBase locator for object instance data\nBLT_n1\nBase locator for XML-TEXT and XML-NTEXT\nBLV_n1\nBase locator for variably located data\nBLX_n1\nBase locator for external data\nODOsv_cell\nODO save cell number\nPfm_cell\nPERFORM cell number\nPfmsv_cell\nPerform save cell number\nTSN=N\nTemporary created by the compiler\nVLC_cell\nVariable-length cell (ODO)\nVN_cell\nVariable name cell for PERFORM statement\nVNGO_cell\nVariable name cell for ALTER statement\nVNI_cell\nVariable name initialization\n#Calc00000000n\nCode to compute addresses of data that is present after an OCCURS\nDEPENDING ON clause\n#WSVal0000000n\nCode to initialize the WORKING-STORAGE area for a procedure\n_ArgumentList\nOutgoing arguments to a procedure\n_ACON\nAddress of a symbol\n_BEtempNNN\nTemporary created by the optimizer\nChapter 22. Debugging  487", "output": "Table 63. Terms used in MAP output (continued)\nTerm\nDefinition\nDescription\nPOINTER\nDS nC\nPointer data item (USAGE POINTER)\nPROCEDURE-PTR\nDS nC\nProcedure pointer (USAGE PROCEDURE-POINTER)\nSD\n \nSort file definition\nVSAM, QSAM,\nLINESEQ\n \nFile processing method\n1-49, 77\n \nLevel-numbers for data descriptions\n66\n \nLevel-number for RENAMES\n88\n \nLevel-number for condition-names\n1. n is the size in bytes for fixed-length groups and the maximum size in bytes for variable-length groups.\n2. If the SYNCHRONIZED clause appears, these fields are used.\nSymbols used in LIST and MAP output\nThe following table describes the symbols used in the listings produced by the LIST or MAP option.\nTable 64. Symbols used in LIST and MAP output\nSymbol\nDefinition\nBLF_n1\nBase locator for files\nBLL_n1\nBase locator for LINKAGE SECTION\nBLO_n1\nBase locator for object instance data\nBLT_n1\nBase locator for XML-TEXT and XML-NTEXT\nBLV_n1\nBase locator for variably located data\nBLX_n1\nBase locator for external data\nODOsv_cell\nODO save cell number\nPfm_cell\nPERFORM cell number\nPfmsv_cell\nPerform save cell number\nTSN=N\nTemporary created by the compiler\nVLC_cell\nVariable-length cell (ODO)\nVN_cell\nVariable name cell for PERFORM statement\nVNGO_cell\nVariable name cell for ALTER statement\nVNI_cell\nVariable name initialization\n#Calc00000000n\nCode to compute addresses of data that is present after an OCCURS\nDEPENDING ON clause\n#WSVal0000000n\nCode to initialize the WORKING-STORAGE area for a procedure\n_ArgumentList\nOutgoing arguments to a procedure\n_ACON\nAddress of a symbol\n_BEtempNNN\nTemporary created by the optimizer\nChapter 22. Debugging  487"}
{"instruction": "Explain this COBOL concept", "input": "USAGE clause\nThe USAGE clause specifies the format in which data is represented in storage.\nFormat 1\nUSAGE\nIS\nBINARY\nNATIVE\nCOMP\nNATIVE\nCOMP-1\nNATIVE\nCOMP-2\nNATIVE\nCOMP-3\nNATIVE\nCOMP-4\nNATIVE\nCOMP-5\nNATIVE\nCOMPUTATIONAL\nNATIVE\nCOMPUTATIONAL-1\nNATIVE\nCOMPUTATIONAL-2\nNATIVE\nCOMPUTATIONAL-3\nNATIVE\nCOMPUTATIONAL-4\nNATIVE\nCOMPUTATIONAL-5\nNATIVE\nDISPLAY\nNATIVE\nDISPLAY-1\nNATIVE\nINDEX\nNATIONAL\nNATIVE\nUTF-8\nNATIVE\nobjref phrase\nPACKED-DECIMAL\nNATIVE\nPOINTER\nPOINTER-32\nPROCEDURE-POINTER\nFUNCTION-POINTER\nobjref phrase\nOBJECT REFERENCE\nclass-name-1\nNote: NATIVE is treated as a comment in all phrases for which NATIVE is shown in the USAGE clause.\nThe USAGE clause can be specified for a data description entry with any level-number other than 66 or\n88.\nChapter 26. DATA DIVISION--data description entry  243", "output": "USAGE clause\nThe USAGE clause specifies the format in which data is represented in storage.\nFormat 1\nUSAGE\nIS\nBINARY\nNATIVE\nCOMP\nNATIVE\nCOMP-1\nNATIVE\nCOMP-2\nNATIVE\nCOMP-3\nNATIVE\nCOMP-4\nNATIVE\nCOMP-5\nNATIVE\nCOMPUTATIONAL\nNATIVE\nCOMPUTATIONAL-1\nNATIVE\nCOMPUTATIONAL-2\nNATIVE\nCOMPUTATIONAL-3\nNATIVE\nCOMPUTATIONAL-4\nNATIVE\nCOMPUTATIONAL-5\nNATIVE\nDISPLAY\nNATIVE\nDISPLAY-1\nNATIVE\nINDEX\nNATIONAL\nNATIVE\nUTF-8\nNATIVE\nobjref phrase\nPACKED-DECIMAL\nNATIVE\nPOINTER\nPOINTER-32\nPROCEDURE-POINTER\nFUNCTION-POINTER\nobjref phrase\nOBJECT REFERENCE\nclass-name-1\nNote: NATIVE is treated as a comment in all phrases for which NATIVE is shown in the USAGE clause.\nThe USAGE clause can be specified for a data description entry with any level-number other than 66 or\n88.\nChapter 26. DATA DIVISION--data description entry  243"}
{"instruction": "Explain this COBOL concept", "input": "Table 30. Abbreviated combined conditions: permissible element sequences (continued)\nCombined\ncondition\nelement\nLeft- most\nWhen not leftmost, can be\nimmediately preceded by:\nRight-\nmost\nWhen not rightmost, can be\nimmediately followed by:\n(\nYes\nRelational operator\nAND\nOR\nNOT\n(\nNo\nSubject\nObject\nNOT\n(\n)\nNo\nObject\n)\nYes\nAND\nOR\n)\nThe following table shows examples of abbreviated combined relation conditions, with and without\nparentheses, and their unabbreviated equivalents.\nTable 31. Abbreviated combined conditions: unabbreviated equivalents\nAbbreviated combined relation condition\nEquivalent\nA = B AND NOT < C OR D\n((A = B) AND (A NOT < C))  OR (A NOT < D)\nA NOT > B OR C\n(A NOT > B)  OR (A NOT > C)\nNOT A = B OR C\n(NOT (A = B)) OR (A = C)\nNOT (A = B OR < C)\nNOT ((A = B) OR (A < C))\nNOT (A NOT = B AND C AND NOT D)\nNOT ((((A NOT = B) AND (A NOT = C))  AND (NOT (A\nNOT = D))))\nStatement categories\nThere are four categories of COBOL statements: imperative statements, conditional statements, delimited\nscope statements, and compiler-directing statements. See the following topics for more details.\nImperative statements\nAn imperative statement either specifies an unconditional action to be taken by the program, or is a\nconditional statement terminated by its explicit scope terminator.\nA series of imperative statements can be specified wherever an imperative statement is allowed. A\nconditional statement that is terminated by its explicit scope terminator is also classified as an imperative\nstatement.\nFor more information about explicit scope terminator, see “Delimited scope statements” on page 300.\nThe following lists contain the COBOL imperative statements.\nArithmetic\n• ADD1\n• COMPUTE1\n• DIVIDE1\n• MULTIPLY1\n296  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "Table 30. Abbreviated combined conditions: permissible element sequences (continued)\nCombined\ncondition\nelement\nLeft- most\nWhen not leftmost, can be\nimmediately preceded by:\nRight-\nmost\nWhen not rightmost, can be\nimmediately followed by:\n(\nYes\nRelational operator\nAND\nOR\nNOT\n(\nNo\nSubject\nObject\nNOT\n(\n)\nNo\nObject\n)\nYes\nAND\nOR\n)\nThe following table shows examples of abbreviated combined relation conditions, with and without\nparentheses, and their unabbreviated equivalents.\nTable 31. Abbreviated combined conditions: unabbreviated equivalents\nAbbreviated combined relation condition\nEquivalent\nA = B AND NOT < C OR D\n((A = B) AND (A NOT < C))  OR (A NOT < D)\nA NOT > B OR C\n(A NOT > B)  OR (A NOT > C)\nNOT A = B OR C\n(NOT (A = B)) OR (A = C)\nNOT (A = B OR < C)\nNOT ((A = B) OR (A < C))\nNOT (A NOT = B AND C AND NOT D)\nNOT ((((A NOT = B) AND (A NOT = C))  AND (NOT (A\nNOT = D))))\nStatement categories\nThere are four categories of COBOL statements: imperative statements, conditional statements, delimited\nscope statements, and compiler-directing statements. See the following topics for more details.\nImperative statements\nAn imperative statement either specifies an unconditional action to be taken by the program, or is a\nconditional statement terminated by its explicit scope terminator.\nA series of imperative statements can be specified wherever an imperative statement is allowed. A\nconditional statement that is terminated by its explicit scope terminator is also classified as an imperative\nstatement.\nFor more information about explicit scope terminator, see “Delimited scope statements” on page 300.\nThe following lists contain the COBOL imperative statements.\nArithmetic\n• ADD1\n• COMPUTE1\n• DIVIDE1\n• MULTIPLY1\n296  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "DFHMDF (part 2)\nfld\nDFHMDF\n,\nCOLOR\n=\nDEFAULT\ncolor\nPS\n=\nBASE\npsid\nGRPNAME\n=\ngroup-name\nOCCURS\n=\nnumb", "output": "DFHMDF (part 2)\nfld\nDFHMDF\n,\nCOLOR\n=\nDEFAULT\ncolor\nPS\n=\nBASE\npsid\nGRPNAME\n=\ngroup-name\nOCCURS\n=\nnumber\nPICIN\n=\n'\nvalue\n'\nPICOUT\n=\n'\nvalue\n'\nSOSI\n=\nNO\nYES\nCASE\n=\nMIXED\nDescription\nA map contains zero or more fields.\nfld is the name (1–30 characters) of the field. Refer to your compiler manual to ensure that there are no\nother restrictions on the length.\nFor more information about defining field names, see Creating the map. If fld is omitted, application\nprograms cannot access the field to change its attributes or alter its contents. For an output map, omitting\nthe field name might be appropriate when the INITIAL operand is used to specify the contents of a field.\nIf a field name is specified and the map that includes the field is used in a mapping operation, data\nsupplied by the user overlays data supplied by initialization (unless default data only is being written).\nThe performance of input mapping operations is optimized if DFHMDF macros are arranged in numeric\norder of the POS operand.\nYou cannot define more than 1023 named fields for a COBOL, C, or PL/I input/output map.\nYou must ensure that the names of maps, and names of fields within a mapset (or within multiple\nmapsets that are copied into one application program) are unique. However, a map can have the same\nname as a mapset.\nBefore CICS can load a physical map, you must define a physical map using an RDO transaction with the\nMAPSET attribute.\nOperands\nATTRB\nThis operand applies only to 3270 data stream devices; it is ignored for other devices, except that\nATTRB=DRK is honored for the SCS Printer Logical Unit. It is also ignored (except for ATTRB=DRK)\nif the NLEOM option is specified on the SEND MAP command for transmission to a 3270 printer.\nIn particular, ATTRB=DRK must not be used as a method of protecting secure data on output on\nnon-3270, non-SCS printer terminals.\nChapter 9. BMS macros  791"}
{"instruction": "What are the compiler rules or directives for this?", "input": "the XML\n• Incremental expansion:\n1. Set an initial size in the OCCURS DEPENDING ON object for the unbounded table\n2. Parse the document normally. For each element", "output": "the XML\n• Incremental expansion:\n1. Set an initial size in the OCCURS DEPENDING ON object for the unbounded table\n2. Parse the document normally. For each element"}
{"instruction": "What are the compiler rules or directives for this?", "input": "The CALLINTERFACE directive specifies the interface convention for CALL and SET statements. The", "output": "The CALLINTERFACE directive specifies the interface convention for CALL and SET statements. The"}
{"instruction": "What is This in COBOL?", "input": "", "output": "This is that your error handler will get control"}
{"instruction": "Explain this COBOL concept", "input": "Table 110. XML GENERATE exceptions (continued)\nException code\n(decimal)\nDescription\n410\nThe CCSID page specified by the CODEPAGE compiler option is not supported for\nconversion to Unicode.\n411\nThe CCSID specified by the CODEPAGE compiler option is not a supported single-byte\nEBCDIC CCSID.\n414\nThe CCSID specified for the XML document was invalid or was not supported.\n415\nThe receiver was national, but the encoding specified for the document was not\nUTF-16.\n416\nThe XML namespace identifier contained invalid XML characters.\n417\nElement character content or an attribute value contained characters that are illegal\nin XML content. XML generation has continued, with the element tag name or the\nattribute name prefixed with 'hex.' and the original data value represented in the\ndocument in hexadecimal.\nAny TYPE IS CONTENT specification is ignored, and the item is treated as an element.\n418\nSubstitution characters were generated by encoding conversion.\n419\nThe XML namespace prefix was invalid.\n420\nThe receiver was alphanumeric and the input included national or DBCS data or\nnames, but the encoding specified for the document was not 1208.\n600-699\nInternal error. Report the error to your service representative.\nRelated tasks   \n“Handling XML GENERATE exceptions” on page 694 \n844  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "Table 110. XML GENERATE exceptions (continued)\nException code\n(decimal)\nDescription\n410\nThe CCSID page specified by the CODEPAGE compiler option is not supported for\nconversion to Unicode.\n411\nThe CCSID specified by the CODEPAGE compiler option is not a supported single-byte\nEBCDIC CCSID.\n414\nThe CCSID specified for the XML document was invalid or was not supported.\n415\nThe receiver was national, but the encoding specified for the document was not\nUTF-16.\n416\nThe XML namespace identifier contained invalid XML characters.\n417\nElement character content or an attribute value contained characters that are illegal\nin XML content. XML generation has continued, with the element tag name or the\nattribute name prefixed with 'hex.' and the original data value represented in the\ndocument in hexadecimal.\nAny TYPE IS CONTENT specification is ignored, and the item is treated as an element.\n418\nSubstitution characters were generated by encoding conversion.\n419\nThe XML namespace prefix was invalid.\n420\nThe receiver was alphanumeric and the input included national or DBCS data or\nnames, but the encoding specified for the document was not 1208.\n600-699\nInternal error. Report the error to your service representative.\nRelated tasks   \n“Handling XML GENERATE exceptions” on page 694 \n844  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Appendix E. EXIT compiler option\nYou can use the EXIT compiler option to provide user-supplied modul", "output": "Appendix E. EXIT compiler option\nYou can use the EXIT compiler option to provide user-supplied modules in place of various compiler\nfunctions. For details about processing of each exit module, error handling for exit modules, or using the\nEXIT option with CICS, SQL and SQLIMS statements, see the following topics.\nNote: All user exit routines must be AMODE 31 or AMODE ANY. You should not compile exit routines with\nLP(64).\nRelated tasks   \n“Using the user-exit work\narea” on page 851  \n“Calling from exit modules” on page 852   \nUsing the EXIT compiler option with CICS, SQL and\nSQLIMS statements  \nRelated references   \n“EXIT” on page 381  \n“Processing of INEXIT” on page 852  \n“Processing of LIBEXIT” on page 853  \n“Processing of PRTEXIT” on page 856  \n“Processing of ADEXIT” on page 858  \n“Processing of MSGEXIT” on page 859 \n“Error handling for exit modules” on page 868 \nUsing the user-exit work area\nWhen you use one of the user exits, the compiler provides a work area in which you can save the address\nof GETMAIN storage obtained by the exit module. Having such a work area lets the module be reentrant.\nThe user-exit work area consists of 6 fullwords that reside on a fullword boundary. These fullwords are\ninitialized to binary zeros before the first exit routine is invoked. The address of the work area is passed\nto the exit module in a parameter list. After initialization, the compiler makes no further reference to the\nwork area.\nThe words in the user-exit work area are used by the individual exit modules as shown in the following\ntable.\nTable 114. Layout of the user-exit work area\nWord number\nUsed by module:\n1\nINEXIT\n2\nLIBEXIT\n3\nPRTEXIT\n4\nADEXIT\n5\n(Reserved)\n6\nMSGEXIT\nRelated references   \n“Processing of INEXIT” on page 852  \n“Processing of LIBEXIT” on page 853  \n“Processing of PRTEXIT” on page 856  \n“Processing of ADEXIT” on page 858 \n“Processing of MSGEXIT” on page 859 \n© Copyright IBM Corp. 1991, 2025\n851"}
{"instruction": "Explain this COBOL concept", "input": "Value CVDA\n605 LOCAL\n606 FORMATEDF\n607 NOFORMATEDF\n608 NOTASKSTART\n609 STARTED\n610 STOPPED\n611 TASKSTART\n612 BUSY\n613 NOTBUSY\n614 SCS\n615 DS3270\n616 ASCII7\n617 ASCII8\n618 AUTOSTART\n619 DRAINING\n620 INDOUBT\n621 INFLIGHT\n622 WAITFORGET\n623 CONTROLSHUT\n624 CANCELLED\n625 FIRSTINIT\n626 SECONDINIT\n627 THIRDINIT\n628 INITCOMPLETE\n629 STANDBY\n630 AUTOACTIVE\n631 AUTOINACTIVE\n632 CTLGALL\n633 CTLGMODIFY\n634 CTLGNONE\n635 START\n636 POST\n637 DELAY\n638 ROUTE\n640 CLEAR\n754  CICS TS for z/OS: API Reference", "output": "Value CVDA\n605 LOCAL\n606 FORMATEDF\n607 NOFORMATEDF\n608 NOTASKSTART\n609 STARTED\n610 STOPPED\n611 TASKSTART\n612 BUSY\n613 NOTBUSY\n614 SCS\n615 DS3270\n616 ASCII7\n617 ASCII8\n618 AUTOSTART\n619 DRAINING\n620 INDOUBT\n621 INFLIGHT\n622 WAITFORGET\n623 CONTROLSHUT\n624 CANCELLED\n625 FIRSTINIT\n626 SECONDINIT\n627 THIRDINIT\n628 INITCOMPLETE\n629 STANDBY\n630 AUTOACTIVE\n631 AUTOINACTIVE\n632 CTLGALL\n633 CTLGMODIFY\n634 CTLGNONE\n635 START\n636 POST\n637 DELAY\n638 ROUTE\n640 CLEAR\n754  CICS TS for z/OS: API Reference"}
{"instruction": "Summarize this COBOL documentation section", "input": "Conditions\n31 EXPIRED\nRESP2 values:\n7\nTIMEOUT has occurred before the operator's reply was received.\nDefault action: return the exception condition to the application.\n16 INVREQ\nRESP2 values:\n1\nThe TEXTLENGTH value is not valid.\n2\nThe NUMROUTES value is not valid.\n3\nThe ROUTECODES value is not valid.\n4\nThe MAXLENGTH value is not valid.\n5\nThe TIMEOUT value is not valid.\n6\nThe ACTION value is not valid.\nDefault action: terminate the task abnormally.\n22 LENGERR\nRESP2 values:\n8\nThe reply was longer than MAXLENGTH, and has been truncated.\nDefault action: terminate the task abnormally.\nWRITEQ TD\nWrite data to transient data queue.\nWRITEQ TD\nWRITEQ TD\nQUEUE( name )\nFROM( data-area )\nLENGTH( data-value )\nSYSID(  systemname )\nConditions: DISABLED, ERROR, INVREQ, IOERR, ISCINVREQ, LENGERR, LOCKED, NOSPACE, NOTAUTH,\nNOTOPEN, QIDERR, SYSIDERR\nThis command is threadsafe when it is used with a queue in a local CICS region, or function shipped to a\nremote CICS region over an IPIC connection. It is non-threadsafe when it is function shipped to a remote\nCICS region over another type of connection.\nDescription\nWRITEQ TD writes transient data to a predefined symbolic destination.\nChapter 2. CICS command summary  681", "output": "Conditions\n31 EXPIRED\nRESP2 values:\n7\nTIMEOUT has occurred before the operator's reply was received.\nDefault action: return the exception condition to the application.\n16 INVREQ\nRESP2 values:\n1\nThe TEXTLENGTH value is not valid.\n2\nThe NUMROUTES value is not valid.\n3\nThe ROUTECODES value is not valid.\n4\nThe MAXLENGTH value is not valid.\n5\nThe TIMEOUT value is not valid.\n6\nThe ACTION value is not valid.\nDefault action: terminate the task abnormally.\n22 LENGERR\nRESP2 values:\n8\nThe reply was longer than MAXLENGTH, and has been truncated.\nDefault action: terminate the task abnormally.\nWRITEQ TD\nWrite data to transient data queue.\nWRITEQ TD\nWRITEQ TD\nQUEUE( name )\nFROM( data-area )\nLENGTH( data-value )\nSYSID(  systemname )\nConditions: DISABLED, ERROR, INVREQ, IOERR, ISCINVREQ, LENGERR, LOCKED, NOSPACE, NOTAUTH,\nNOTOPEN, QIDERR, SYSIDERR\nThis command is threadsafe when it is used with a queue in a local CICS region, or function shipped to a\nremote CICS region over an IPIC connection. It is non-threadsafe when it is function shipped to a remote\nCICS region over another type of connection.\nDescription\nWRITEQ TD writes transient data to a predefined symbolic destination.\nChapter 2. CICS command summary  681"}
{"instruction": "What are the compiler rules or directives for this?", "input": "• INQUIRE TIMER\n• LINK ACQPROCESS\n• LINK ACTIVITY\n• MOVE CONTAINER(BTS)\n• PUT CONTAINER (BTS)\n• REMOVE SUBEVENT\n• RESET ACQPROCESS\n• RESET ACTIVITY\n• RESUME\n• RETRIEVE REATTACH EVENT\n• RETRIEVE SUBEVE", "output": "• INQUIRE TIMER\n• LINK ACQPROCESS\n• LINK ACTIVITY\n• MOVE CONTAINER(BTS)\n• PUT CONTAINER (BTS)\n• REMOVE SUBEVENT\n• RESET ACQPROCESS\n• RESET ACTIVITY\n• RESUME\n• RETRIEVE REATTACH EVENT\n• RETRIEVE SUBEVENT\n• RUN\n• STARTBROWSE ACTIVITY\n• “STARTBROWSE CONTAINER (BTS)” on page 546\n• STARTBROWSE EVENT\n• STARTBROWSE PROCESS\n• SUSPEND (BTS)\n• TEST EVENT"}
{"instruction": "Explain this COBOL concept", "input": "Chapter 91. SQRT\nThe SQRT function returns a numeric value that approximates the square root of the argument specified.\nThe function type is numeric.\nFormat\nFUNCTION SQRT\n(\nargument-1\n)\nargument-1\nMust be class numeric. The value of argument-1 must be zero or positive.\nThe returned value is the absolute value of the approximation of the square root of argument-1.\n© Copyright IBM Corp. 1991, 2025\n647", "output": "Chapter 91. SQRT\nThe SQRT function returns a numeric value that approximates the square root of the argument specified.\nThe function type is numeric.\nFormat\nFUNCTION SQRT\n(\nargument-1\n)\nargument-1\nMust be class numeric. The value of argument-1 must be zero or positive.\nThe returned value is the absolute value of the approximation of the square root of argument-1.\n© Copyright IBM Corp. 1991, 2025\n647"}
{"instruction": "What is the default output location in COBOL?", "input": "", "output": "the default output location is current directory if the compiler is being run from the cob2 utility; otherwise, the output location is the\nhome directory of the userid under which the compiler is running"}
{"instruction": "Summarize this COBOL documentation section", "input": "Table 136. SYSADATA parse tree record (continued)\nField\nSize\nDescription\n \n \nFor Reserved word at identifier level type:\n0001\nROUNDED\n0002\nTRUE\n0003\nON\n0004\nOFF\n0005\nSIZE\n0006\nDATE\n0007\nDAY\n0008\nDAY-OF-WEEK\n0009\nTIME\n0010\nWHEN-COMPILED\n0011\nPAGE\n0012\nDATE YYYYMMDD\n0013\nDAY YYYYDDD\n0014\nAttribute\n0015\nElement\n0016\nContent\n0017\nNumeric\n0018\nNonnumeric\n0019\nEvery\n0020\nWhen\nAppendix G. COBOL SYSADATA file contents  923", "output": "Table 136. SYSADATA parse tree record (continued)\nField\nSize\nDescription\n \n \nFor Reserved word at identifier level type:\n0001\nROUNDED\n0002\nTRUE\n0003\nON\n0004\nOFF\n0005\nSIZE\n0006\nDATE\n0007\nDAY\n0008\nDAY-OF-WEEK\n0009\nTIME\n0010\nWHEN-COMPILED\n0011\nPAGE\n0012\nDATE YYYYMMDD\n0013\nDAY YYYYDDD\n0014\nAttribute\n0015\nElement\n0016\nContent\n0017\nNumeric\n0018\nNonnumeric\n0019\nEvery\n0020\nWhen\nAppendix G. COBOL SYSADATA file contents  923"}
{"instruction": "What is SMARTBIN in COBOL?", "input": "", "output": "SMARTBIN is default when LP(32) is in effect"}
{"instruction": "What is If TOKEN in COBOL?", "input": "", "output": "If TOKEN is Kerberos token that indicates mutual authentication is in use, OUTTOKEN and OUTTOKENLEN\noptions must be specified"}
{"instruction": "What are the compiler rules or directives for this?", "input": "in your COBOL program, you need to define the files to the operating system", "output": "in your COBOL program, you need to define the files to the operating system"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Note\nBefore using this information and the product it supports, be sure to read the general informat", "output": "Note\nBefore using this information and the product it supports, be sure to read the general information under\n“Notices” on page 997."}
{"instruction": "What is occurrence data item in COBOL?", "input": "", "output": "occurrence data item is table element that is repeated a variable number of times"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 82. Compiler limits (continued)\nLanguage element\nCompiler limit\nNotes:\n1. Items included in 4,", "output": "Table 82. Compiler limits (continued)\nLanguage element\nCompiler limit\nNotes:\n1. Items included in 4,194,303 byte limit for procedure plus constant area.\n2. Syntax checked, but has no effect on the execution of the program; there is no limit.\n3. No compiler limit, but VSAM limits it to 255 bytes.\n4. QSAM.\n5. Compiler limit shown, but QSAM limits it to 32,760 bytes.\n6. For QSAM and VSAM, the limit is 4088 bytes if EQUALS is coded on the OPTION control statement.\n7. SORT limit for QSAM and VSAM.\n8. Requires large block interface (LBI) support provided by OS/390 DFSMS 2.10.0 or later. On OS/390 systems\nwith earlier releases of DFSMS, the limit is 32,760 bytes. For more information about using large block\nsizes, see Setting block sizes in the Enterprise COBOL Programming Guide.\n744  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What is If\nname in COBOL?", "input": "", "output": "If\nname is variable that contains a name that is less than 8 characters, the name must be padded with\ntrailing blanks"}
{"instruction": "What is 1 in COBOL?", "input": "", "output": "1 is receiving\nfield; procedure-pointer-data-item-2 is a sending field"}
{"instruction": "Summarize this COBOL documentation section", "input": "Table 134. SYSADATA options record (continued)\nField\nSize\nDescription\nCALLINTERFACE\nsuboptions\nXL1\n1... ....\nBit 1 = CALLINTERFACE(DLL)\n.1.. ....\nBit 1 = CALLINTERFACE(DYNAMIC)\n..11 1111\nReserved for future use\nARITH suboption\nXL1\n1... ....\nBit 1 = ARITH(COMPAT)\n.1.. ....\nBit 1 = ARITH(EXTEND)\n..11 1111\nReserved for future use\nDBCS Req\nFL4\nDBCS XREF storage requirement\nDBCS ORDPGM length\nHL2\nLength of name of DBCS Ordering Program\nDBCS ENCTBL length\nHL2\nLength of name of DBCS Encode Table\nDBCS ORD TYPE\nCL2\nDBCS Ordering type\nReserved\nCL5\nReserved for future use\nOptimize level\nXL1\nOptimization level 0 <= n <= 2\nConverted SO\nCL1\nConverted SO hexadecimal value\nConverted SI\nCL1\nConverted SI hexadecimal value\nLanguage ID\nCL2\nThis field holds the two-character abbreviation (one of EN, UE, JA,\nor JP) from the LANGUAGE option.\nINEXIT name length\nHL2\nLength of SYSIN user-exit name\nPRTEXIT name length\nHL2\nLength of SYSPRINT user-exit name\nLIBEXIT name length\nHL2\nLength of Libraryuser-exit name\nADEXIT name length\nHL2\nLength of ADATA user-exit name\nCURROPT\nCL5\nCURRENCY option value\nARCH\nXL1\nARCH level number\nTUNE\nXL1\nTUNE level number\nReserved\nCL1\nReserved for future use\nCODEPAGE\nHL2\nCODEPAGE CCSID option value\nReserved\nCL50\nReserved for future use\nLINECNT\nHL2\nLINECOUNT value\nReserved\nCL2\nReserved for future use\nBUFSIZE\nFL4\nBUFSIZE option value\nReserved\nFL4\nReserved for future use\nAppendix G. COBOL SYSADATA file contents  895", "output": "Table 134. SYSADATA options record (continued)\nField\nSize\nDescription\nCALLINTERFACE\nsuboptions\nXL1\n1... ....\nBit 1 = CALLINTERFACE(DLL)\n.1.. ....\nBit 1 = CALLINTERFACE(DYNAMIC)\n..11 1111\nReserved for future use\nARITH suboption\nXL1\n1... ....\nBit 1 = ARITH(COMPAT)\n.1.. ....\nBit 1 = ARITH(EXTEND)\n..11 1111\nReserved for future use\nDBCS Req\nFL4\nDBCS XREF storage requirement\nDBCS ORDPGM length\nHL2\nLength of name of DBCS Ordering Program\nDBCS ENCTBL length\nHL2\nLength of name of DBCS Encode Table\nDBCS ORD TYPE\nCL2\nDBCS Ordering type\nReserved\nCL5\nReserved for future use\nOptimize level\nXL1\nOptimization level 0 <= n <= 2\nConverted SO\nCL1\nConverted SO hexadecimal value\nConverted SI\nCL1\nConverted SI hexadecimal value\nLanguage ID\nCL2\nThis field holds the two-character abbreviation (one of EN, UE, JA,\nor JP) from the LANGUAGE option.\nINEXIT name length\nHL2\nLength of SYSIN user-exit name\nPRTEXIT name length\nHL2\nLength of SYSPRINT user-exit name\nLIBEXIT name length\nHL2\nLength of Libraryuser-exit name\nADEXIT name length\nHL2\nLength of ADATA user-exit name\nCURROPT\nCL5\nCURRENCY option value\nARCH\nXL1\nARCH level number\nTUNE\nXL1\nTUNE level number\nReserved\nCL1\nReserved for future use\nCODEPAGE\nHL2\nCODEPAGE CCSID option value\nReserved\nCL50\nReserved for future use\nLINECNT\nHL2\nLINECOUNT value\nReserved\nCL2\nReserved for future use\nBUFSIZE\nFL4\nBUFSIZE option value\nReserved\nFL4\nReserved for future use\nAppendix G. COBOL SYSADATA file contents  895"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Chapter 14. COBOL function prototype definition\nstructure\nA COBOL function prototype definition desc", "output": "Chapter 14. COBOL function prototype definition\nstructure\nA COBOL function prototype definition describes a function prototype.\nFormat: COBOL function prototype definition\nIDENTIFICATION\nID\nDIVISION.\nFUNCTION-ID\n.\nfunction-prototype-name-1\nAS\n'literal-1'\nIS\nPROTOTYPE\nENTRY-NAME\nIS\nCOMPAT\nLONGUPPER\nLONGMIXED\nENTRY-INTERFACE\nIS\nSTATIC\nDYNAMIC\nDLL\n.\nother identification-division-content\nENVIRONMENT DIVISION.\nenvironment-division-content\nDATA DIVISION.\ndata-division-content\nPROCEDURE DIVISION.\nprocedure-division-content\n1\nEND FUNCTION\nfunction-prototype-name-1.\n2\nNotes:\n1 The RETURNING phrase of the PROCEDURE DIVISION header is required.\n2 Function prototype definitions cannot be nested within any programs, user-defined function definitions,\nmethods, classes, or function prototype definitions.\n© Copyright IBM Corp. 1991, 2025\n99"}
{"instruction": "What is format QSAM data set in COBOL?", "input": "", "output": "format QSAM data set is extended-format QSAM data set that is spread over\nmultiple volumes, thus allowing parallel data access"}
{"instruction": "Explain this COBOL concept", "input": "• Calculations of subscripts, reference modifications, variable-lengths, variable locations\n• Evaluations of functions\nTherefore, if identifier-4, identifier-5, identifier-6, identifier-7, or identifier-8 is used as a subscript,\nreference-modifier, or function argument in the UNSTRING statement, or affects the length or location\nof any of the identifiers in the UNSTRING statement, these values are determined at the beginning of the\nUNSTRING statement, and are not affected by any results of the UNSTRING statement.\nExample of the UNSTRING statement\nThis topic lists an example for the UNSTRING statement.\nThe following figure shows the execution results for an example of the UNSTRING statement.\nWRITE statement\nThe WRITE statement releases a logical record to an output or input/output file.\nWhen the WRITE statement is executed:\n• The associated sequential file must be open in OUTPUT or EXTEND mode.\n• The associated indexed or relative file must be open in OUTPUT, I-O, or EXTEND mode.\nChapter 28. PROCEDURE DIVISION statements  481", "output": "• Calculations of subscripts, reference modifications, variable-lengths, variable locations\n• Evaluations of functions\nTherefore, if identifier-4, identifier-5, identifier-6, identifier-7, or identifier-8 is used as a subscript,\nreference-modifier, or function argument in the UNSTRING statement, or affects the length or location\nof any of the identifiers in the UNSTRING statement, these values are determined at the beginning of the\nUNSTRING statement, and are not affected by any results of the UNSTRING statement.\nExample of the UNSTRING statement\nThis topic lists an example for the UNSTRING statement.\nThe following figure shows the execution results for an example of the UNSTRING statement.\nWRITE statement\nThe WRITE statement releases a logical record to an output or input/output file.\nWhen the WRITE statement is executed:\n• The associated sequential file must be open in OUTPUT or EXTEND mode.\n• The associated indexed or relative file must be open in OUTPUT, I-O, or EXTEND mode.\nChapter 28. PROCEDURE DIVISION statements  481"}
{"instruction": "Summarize this COBOL documentation section", "input": "Table 66. Signature information bytes (continued)\nOffset\nin\ndecim\nal\nSignatur\ne byte\nBit\nItem\nOn\nOff\n10\n3\n0\nNUMPROC(PFD)\nNUMPROC(NOPFD)\n1\nRENT\nNORENT\n2\nRESIDENT (always on)\n3\nSEQUENCE\nNOSEQUENCE\n4\nReserved\n5\nSOURCE\nNOSOURCE\n6\nNot NOSSRANGE\nNOSSRANGE\n7\nTERM\nNOTERM\n11\n4\n0\nTEST\nNOTEST\n1\nTRUNC(STD)\nNot TRUNC(STD)\n2\nWORD\nNOWORD\n3\nVBREF\nNOVBREF\n4\nXREF\nNOXREF\n5\nZWB\nNOZWB\n6\nNAME\nNONAME\n7\nNOCMPR2 (always off)\n12\n5\n0\nReserved\n1\nNUMCLS=ALT\nNUMCLS=PRIM\n2\nDBCS\nNODBCS\n3\nAWO\nNOAWO\n4\nTRUNC(BIN)\nNot TRUNC(BIN)\n5\nADATA\nNOADATA\n6\nCURRENCY\nNOCURRENCY\n7\nCompilation unit is a class\nCompilation unit is a program\n13\n6\n0\nQSAM file descriptor\n1\nVSAM sequential file descriptor\n2\nVSAM indexed file descriptor\n3\nVSAM relative file descriptor\n4\nCODE-SET clause (ASCII files) in file descriptor\n5\nSpanned records\n6\nPIC G or PIC N (DBCS data item)\n7\nOCCURS DEPENDING ON clause in data description entry\nChapter 22. Debugging  493", "output": "Table 66. Signature information bytes (continued)\nOffset\nin\ndecim\nal\nSignatur\ne byte\nBit\nItem\nOn\nOff\n10\n3\n0\nNUMPROC(PFD)\nNUMPROC(NOPFD)\n1\nRENT\nNORENT\n2\nRESIDENT (always on)\n3\nSEQUENCE\nNOSEQUENCE\n4\nReserved\n5\nSOURCE\nNOSOURCE\n6\nNot NOSSRANGE\nNOSSRANGE\n7\nTERM\nNOTERM\n11\n4\n0\nTEST\nNOTEST\n1\nTRUNC(STD)\nNot TRUNC(STD)\n2\nWORD\nNOWORD\n3\nVBREF\nNOVBREF\n4\nXREF\nNOXREF\n5\nZWB\nNOZWB\n6\nNAME\nNONAME\n7\nNOCMPR2 (always off)\n12\n5\n0\nReserved\n1\nNUMCLS=ALT\nNUMCLS=PRIM\n2\nDBCS\nNODBCS\n3\nAWO\nNOAWO\n4\nTRUNC(BIN)\nNot TRUNC(BIN)\n5\nADATA\nNOADATA\n6\nCURRENCY\nNOCURRENCY\n7\nCompilation unit is a class\nCompilation unit is a program\n13\n6\n0\nQSAM file descriptor\n1\nVSAM sequential file descriptor\n2\nVSAM indexed file descriptor\n3\nVSAM relative file descriptor\n4\nCODE-SET clause (ASCII files) in file descriptor\n5\nSpanned records\n6\nPIC G or PIC N (DBCS data item)\n7\nOCCURS DEPENDING ON clause in data description entry\nChapter 22. Debugging  493"}
{"instruction": "What is When a program gains access to a root activity by in COBOL?", "input": "", "output": "When a program gains access to a root activity by is of either a DEFINE\nPROCESS or an ACQUIRE PROCESS command, the process is known as the acquired process"}
{"instruction": "Explain this COBOL concept", "input": "1. COBOLX is AMODE 31. It uses the SET statement to set a procedure pointer to COBOLZ. COBOLZ is a\nreentrant program object and is AMODE 31 and RMODE 24. COBOLX calls COBOLZ using the procedure\npointer. COBOLZ is entered in AMODE 31.\n2. COBOLZ returns to COBOLX.\n3. COBOLX dynamically calls COBOLY, passing the procedure pointer for COBOLZ. COBOLY is a reentrant\nprogram object, and is AMODE 24 and RMODE 24. COBOLY is entered in AMODE 24.\n4. COBOLY calls COBOLZ using the procedure pointer. This call causes COBOLZ to be entered in AMODE\n24, which is not the same AMODE in which COBOLZ was entered when it was called the first time.\nThe following scenario uses a mix of COBOL and assembler language. This scenario is not supported\nbecause the COBOL program COBOLB is not entered in the same AMODE each time that it is called.\n1. COBOLA is AMODE 31. COBOLA dynamically calls COBOLB. COBOLB is a reentrant program object and\nis AMODE 31 and RMODE 24. COBOLB is entered in AMODE 31.\n2. COBOLB returns to COBOLA.\n3. COBOLA dynamically calls ASSEM10, which is in assembler language. ASSEM10 is a reentrant program\nobject, and is AMODE 24 and RMODE 24. ASSEM10 is entered in AMODE 24.\n4. ASSEM10 loads COBOLB. ASSEM10 does a BALR instruction to COBOLB. COBOLB is entered in AMODE\n24, which is not the same AMODE in which COBOLB was entered when it was called the first time.\nChapter 29. Using subprograms  577", "output": "1. COBOLX is AMODE 31. It uses the SET statement to set a procedure pointer to COBOLZ. COBOLZ is a\nreentrant program object and is AMODE 31 and RMODE 24. COBOLX calls COBOLZ using the procedure\npointer. COBOLZ is entered in AMODE 31.\n2. COBOLZ returns to COBOLX.\n3. COBOLX dynamically calls COBOLY, passing the procedure pointer for COBOLZ. COBOLY is a reentrant\nprogram object, and is AMODE 24 and RMODE 24. COBOLY is entered in AMODE 24.\n4. COBOLY calls COBOLZ using the procedure pointer. This call causes COBOLZ to be entered in AMODE\n24, which is not the same AMODE in which COBOLZ was entered when it was called the first time.\nThe following scenario uses a mix of COBOL and assembler language. This scenario is not supported\nbecause the COBOL program COBOLB is not entered in the same AMODE each time that it is called.\n1. COBOLA is AMODE 31. COBOLA dynamically calls COBOLB. COBOLB is a reentrant program object and\nis AMODE 31 and RMODE 24. COBOLB is entered in AMODE 31.\n2. COBOLB returns to COBOLA.\n3. COBOLA dynamically calls ASSEM10, which is in assembler language. ASSEM10 is a reentrant program\nobject, and is AMODE 24 and RMODE 24. ASSEM10 is entered in AMODE 24.\n4. ASSEM10 loads COBOLB. ASSEM10 does a BALR instruction to COBOLB. COBOLB is entered in AMODE\n24, which is not the same AMODE in which COBOLB was entered when it was called the first time.\nChapter 29. Using subprograms  577"}
{"instruction": "What is 1 in COBOL?", "input": "", "output": "1 is national literal or an elementary data item described with usage NATIONAL, the value\nreturned is equal to the length of argument-1 in national character positions"}
{"instruction": "What are the compiler rules or directives for this?", "input": "must be specified all in the same library text or all in source text.", "output": "must be specified all in the same library text or all in source text."}
{"instruction": "Explain this COBOL concept", "input": "RMODE\nThe RMODE setting influences the RMODE (residency mode) of your generated object program.\nRMODE option syntax\nRMODE(\nAUTO\n24\nANY\n)\nDefault is: AUTO\nAbbreviations are: None\nA program compiled with the RMODE(AUTO) option will have RMODE 24 if NORENT is specified, or RMODE\nANY if RENT is specified. RMODE AUTO is compatible with older compilers such as VS COBOL II, which\nproduced RMODE 24 for programs compiled with NORENT, and RMODE ANY for programs compiled with\nRENT.\nA program compiled with the RMODE(24) option will have RMODE 24 whether NORENT or RENT is\nspecified.\nA program compiled with the RMODE(ANY) option must also be compiled with the RENT option. The\nprogram will have the RMODE ANY attribute.\nIf the NORENT option is specified, the RMODE(24) or RMODE(AUTO) compiler option must be specified.\nOverriding the module RMODE with a binder option or control statement is not supported.\nDATA and RENT: The RMODE option interacts with other compiler options and runtime options that\naffect storage and its addressability. For information about passing data between programs with different\nmodes, see the related concept about storage and its addressability.\nLink-edit considerations: If the object code that COBOL generates has an attribute of RMODE 24, you\nmust link-edit the code into an RMODE 24 module. If the object code that COBOL generates has an\nattribute of RMODE ANY, you can link-edit the code into either an RMODE ANY or RMODE 24 module.\nAMODE 64 considerations: The LP(64) compiler option implies RMODE(ANY). If the user explicitly\nspecifies RMODE(24), an informational message is issued and the setting is ignored.\nRelated concepts   \n“Storage and its addressability” on page 39 \nRelated references   \n“Allocation of buffers for QSAM files” on page 192  \n“Conflicting compiler options” on page 358 \n418  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "RMODE\nThe RMODE setting influences the RMODE (residency mode) of your generated object program.\nRMODE option syntax\nRMODE(\nAUTO\n24\nANY\n)\nDefault is: AUTO\nAbbreviations are: None\nA program compiled with the RMODE(AUTO) option will have RMODE 24 if NORENT is specified, or RMODE\nANY if RENT is specified. RMODE AUTO is compatible with older compilers such as VS COBOL II, which\nproduced RMODE 24 for programs compiled with NORENT, and RMODE ANY for programs compiled with\nRENT.\nA program compiled with the RMODE(24) option will have RMODE 24 whether NORENT or RENT is\nspecified.\nA program compiled with the RMODE(ANY) option must also be compiled with the RENT option. The\nprogram will have the RMODE ANY attribute.\nIf the NORENT option is specified, the RMODE(24) or RMODE(AUTO) compiler option must be specified.\nOverriding the module RMODE with a binder option or control statement is not supported.\nDATA and RENT: The RMODE option interacts with other compiler options and runtime options that\naffect storage and its addressability. For information about passing data between programs with different\nmodes, see the related concept about storage and its addressability.\nLink-edit considerations: If the object code that COBOL generates has an attribute of RMODE 24, you\nmust link-edit the code into an RMODE 24 module. If the object code that COBOL generates has an\nattribute of RMODE ANY, you can link-edit the code into either an RMODE ANY or RMODE 24 module.\nAMODE 64 considerations: The LP(64) compiler option implies RMODE(ANY). If the user explicitly\nspecifies RMODE(24), an informational message is issued and the setting is ignored.\nRelated concepts   \n“Storage and its addressability” on page 39 \nRelated references   \n“Allocation of buffers for QSAM files” on page 192  \n“Conflicting compiler options” on page 358 \n418  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "Table 1. Basic COBOL character set. This table lists basic COBOL character set. (continued)\nCharacte", "output": "Table 1. Basic COBOL character set. This table lists basic COBOL character set. (continued)\nCharacter\nMeaning\nUse\nExample\n$\nCurrency sign1\nEditing character\n01 WS-DATE \nPIC $$99.\n,\nComma\nEditing character\n01 WS-DATE \nPIC 99,999.\nPunctuation character\nMOVE 10 TO \nWS-A, WS-B.\n;\nSemicolon\nPunctuation character\nMOVE 10 TO \nWS-A; WS-B.\n:\nColon\nRelation character\nMOVE WS-\nVAR(1:10) \nTO WS-VAR1\nQualification operator\nMOVE WS-\nVAR::WS-\nVAR2 TO WS-\nVAR1\n.\nDecimal point or period\nEditing character\n01 WS-DATE \nPIC 99.999.\nPunctuation character\nMOVE 10 TO \nWS-A, WS-B.\n\"\nQuotation mark2\nPunctuation character\n01 WS-VAR \nPIC X(5) \nVALUE \n\"HELLO\".\n'\nApostrophe\nPunctuation character\n01 WS-VAR \nPIC X(5) \nVALUE \n'HELLO'.\n(\nLeft parenthesis\nPunctuation character\nIF (WS-A = \n10) AND \n(WS-B = 5)\n)\nRight parenthesis\nPunctuation character\nIF (WS-A = \n10) AND \n(WS-B = 5)\n>\nGreater than\nRelation character\nIF WS-A > \n10\n<\nLess than\nRelation character\nIF WS-A < \n10\nChapter 1. Characters  5"}
{"instruction": "Summarize this COBOL documentation section", "input": "4\nFROMLENGTH is outside the range 0 through 4000.\nDefault action: terminate the task abnormally.\nExamples\nThe following COBOL example shows how to write a user trace entry with a trace identifier of 123, with\ntrace data from a data area called USER-TRACE-ENTRY:\nEXEC CICS ENTER TRACENUM(123)\n     FROM(USER-TRACE-ENTRY)\nEND-EXEC.\nEXTRACT ATTACH (LUTYPE6.1)\nRetrieve values from an LUTYPE6.1 attach header. \nEXTRACT ATTACH (LUTYPE6.1)\nEXTRACT ATTACH\nATTACHID(  name )\nCONVID(  name )\nSESSION(  name )\nPROCESS(  data-area )\nRESOURCE(  data-area )\nRPROCESS(  data-area )\nRRESOURCE(  data-area )\nQUEUE( data-area )\nIUTYPE( data-area )\nDATASTR(  data-area )\nRECFM( data-area )\nConditions: CBIDERR, INVREQ, NOTALLOC\n \nDescription\nEXTRACT ATTACH retrieves a set of values that are held in an attach header control block, or that\nhave been built previously. For the command to retrieve information from a received attach Function\nManagement Header (FMH), EIBATT must have been set during a RECEIVE or CONVERSE command.\nOptions\nATTACHID(name)\nspecifies that values are to be retrieved from an attach header control block. The name (1–8\ncharacters) identifies this control block to the local task.\nCONVID(name)\nidentifies the conversation to which the command relates. The 4-character name identifies either the\ntoken returned by a previously executed ALLOCATE command in EIBRSRCE in the EIB, or the token\nrepresenting the principal session (returned by a previously executed ASSIGN command).\nDATASTR(data-area)\ncorresponds to the data stream profile field, ATTDSP, in an LUTYPE6.1 attach FMH.\nChapter 2. CICS command summary  159", "output": "4\nFROMLENGTH is outside the range 0 through 4000.\nDefault action: terminate the task abnormally.\nExamples\nThe following COBOL example shows how to write a user trace entry with a trace identifier of 123, with\ntrace data from a data area called USER-TRACE-ENTRY:\nEXEC CICS ENTER TRACENUM(123)\n     FROM(USER-TRACE-ENTRY)\nEND-EXEC.\nEXTRACT ATTACH (LUTYPE6.1)\nRetrieve values from an LUTYPE6.1 attach header. \nEXTRACT ATTACH (LUTYPE6.1)\nEXTRACT ATTACH\nATTACHID(  name )\nCONVID(  name )\nSESSION(  name )\nPROCESS(  data-area )\nRESOURCE(  data-area )\nRPROCESS(  data-area )\nRRESOURCE(  data-area )\nQUEUE( data-area )\nIUTYPE( data-area )\nDATASTR(  data-area )\nRECFM( data-area )\nConditions: CBIDERR, INVREQ, NOTALLOC\n \nDescription\nEXTRACT ATTACH retrieves a set of values that are held in an attach header control block, or that\nhave been built previously. For the command to retrieve information from a received attach Function\nManagement Header (FMH), EIBATT must have been set during a RECEIVE or CONVERSE command.\nOptions\nATTACHID(name)\nspecifies that values are to be retrieved from an attach header control block. The name (1–8\ncharacters) identifies this control block to the local task.\nCONVID(name)\nidentifies the conversation to which the command relates. The 4-character name identifies either the\ntoken returned by a previously executed ALLOCATE command in EIBRSRCE in the EIB, or the token\nrepresenting the principal session (returned by a previously executed ASSIGN command).\nDATASTR(data-area)\ncorresponds to the data stream profile field, ATTDSP, in an LUTYPE6.1 attach FMH.\nChapter 2. CICS command summary  159"}
{"instruction": "Summarize this COBOL documentation section", "input": "Table 6. Internal representation of numeric items\nNumeric type\nPICTURE and USAGE and\noptional SIGN clause\nValue\nInternal representation\nExternal\ndecimal\nPIC S9999 DISPLAY\n+ 1234\n   F1 F2 F3 C4\n- 1234\n   F1 F2 F3 D4\n  1234\n   F1 F2 F3 C4\nPIC 9999 DISPLAY\n  1234\n   F1 F2 F3 F4\nPIC 9999 NATIONAL\n  1234\n00 31 00 32 00 33 00 34\nPIC S9999 DISPLAY\n  SIGN LEADING \n+ 1234\n   C1 F2 F3 F4\n- 1234\n   D1 F2 F3 F4\nPIC S9999 DISPLAY\n  SIGN LEADING SEPARATE \n+ 1234\n4E F1 F2 F3 F4\n- 1234\n60 F1 F2 F3 F4\nPIC S9999 DISPLAY\n  SIGN TRAILING \nSEPARATE \n+ 1234\nF1 F2 F3 F4 4E\n- 1234\nF1 F2 F3 F4 60\nPIC S9999 NATIONAL\n   SIGN LEADING \nSEPARATE\n+ 1234\n00 2B 00 31 00 32 00 33 00\n34\n- 1234\n00 2D 00 31 00 32 00 33 00\n34\nPIC S9999 NATIONAL\n   SIGN TRAILING \nSEPARATE\n+ 1234\n00 31 00 32 00 33 00 34 00\n2B\n- 1234\n00 31 00 32 00 33 00 34 00\n2D\nBinary\nPIC S9999 BINARY\nPIC S9999 COMP\nPIC S9999 COMP-4 \n+ 1234\n   04 D2\n- 1234\n   FB 2E\nPIC S9999 COMP-5\n+ 123451\n   30 39\n- 123451\n   CF C7\nPIC 9999  BINARY\nPIC 9999  COMP\nPIC 9999  COMP-4 \n  1234\n   04 D2\nPIC 9999  COMP-5\n  600001\n   EA 60\n56  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide", "output": "Table 6. Internal representation of numeric items\nNumeric type\nPICTURE and USAGE and\noptional SIGN clause\nValue\nInternal representation\nExternal\ndecimal\nPIC S9999 DISPLAY\n+ 1234\n   F1 F2 F3 C4\n- 1234\n   F1 F2 F3 D4\n  1234\n   F1 F2 F3 C4\nPIC 9999 DISPLAY\n  1234\n   F1 F2 F3 F4\nPIC 9999 NATIONAL\n  1234\n00 31 00 32 00 33 00 34\nPIC S9999 DISPLAY\n  SIGN LEADING \n+ 1234\n   C1 F2 F3 F4\n- 1234\n   D1 F2 F3 F4\nPIC S9999 DISPLAY\n  SIGN LEADING SEPARATE \n+ 1234\n4E F1 F2 F3 F4\n- 1234\n60 F1 F2 F3 F4\nPIC S9999 DISPLAY\n  SIGN TRAILING \nSEPARATE \n+ 1234\nF1 F2 F3 F4 4E\n- 1234\nF1 F2 F3 F4 60\nPIC S9999 NATIONAL\n   SIGN LEADING \nSEPARATE\n+ 1234\n00 2B 00 31 00 32 00 33 00\n34\n- 1234\n00 2D 00 31 00 32 00 33 00\n34\nPIC S9999 NATIONAL\n   SIGN TRAILING \nSEPARATE\n+ 1234\n00 31 00 32 00 33 00 34 00\n2B\n- 1234\n00 31 00 32 00 33 00 34 00\n2D\nBinary\nPIC S9999 BINARY\nPIC S9999 COMP\nPIC S9999 COMP-4 \n+ 1234\n   04 D2\n- 1234\n   FB 2E\nPIC S9999 COMP-5\n+ 123451\n   30 39\n- 123451\n   CF C7\nPIC 9999  BINARY\nPIC 9999  COMP\nPIC 9999  COMP-4 \n  1234\n   04 D2\nPIC 9999  COMP-5\n  600001\n   EA 60\n56  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Programming Guide"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "source program. An encoding unit for data items of usage UTF-8 and UTF-8 literals is 1 byte. In data", "output": "source program. An encoding unit for data items of usage UTF-8 and UTF-8 literals is 1 byte. In data items\nof usage UTF-8, each Unicode code point represented in the data item is encoded using between 1 and 4\nencoding units.\nFor most of the characters in UTF-8, a graphic character is 1 to 4 encoding units (i.e., a character\ntypically corresponds to a single Unicode code point). Characters converted to UTF-8 from an EBCDIC,\nASCII, or EUC code page are represented in 1 to 4 UTF-8 encoding units. However, some of the other\ngraphic characters in UTF-8 are represented by a combining character sequence, which corresponds to\na sequence of Unicode code points. In particular, a combining character sequence consists of a base\ncharacter and one or more combining marks or a sequence of one or more combining marks, with each\ncombining mark being represented by 1 to 4 encoding units.\nWhen UTF-8 data contains combining character sequences, programmers are responsible for ensure that\noperations on UTF-8 characters do not unintentionally separate the multiple groupings of encoding units\nthat form graphic characters. You must pay attention to the reference modification and avoid truncations\nduring moves. The COBOL runtime system does not check for a split between the groups of encoding units\nthat form a graphic character.\nChapter 2. Character sets and code pages  9"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "18 NOSPACE\nOccurs when the NOSUSPEND option is specified and there is no space for the data in the f", "output": "18 NOSPACE\nOccurs when the NOSUSPEND option is specified and there is no space for the data in the following:\n• Main storage\n• The auxiliary temporary storage data set\n• The temporary storage pool list structure\nThis condition also occurs if there is no space and there is an active HANDLE CONDITION for\nNOSPACE.\nDefault action: ignore the condition.\n70 NOTAUTH\nRESP2 values:\n101\nA resource security check has failed on QUEUE(name).\nDefault action: terminate the task abnormally.\n44 QIDERR\nOccurs when the queue specified by a WRITEQ TS command with the REWRITE option cannot be\nfound in any of the following:\n• Main storage\n• Auxiliary storage\n• Temporary storage pool\nDefault action: terminate the task abnormally.\n53 SYSIDERR\nRESP2 values:\n4\nOccurs in any of the following situations:\n• The SYSID option specifies a name that is not the local system or a remote system (made known\nto CICS by defining a CONNECTION or an IPCONN).\n• When IPIC connectivity is used, the local system, the remote system, or both, are not CICS TS\n4.2 or later regions.\n• The link to the remote system is closed.\n• The CICS region in which the temporary storage command is executed fails to connect to the\nTS server managing the TS pool that supports the referenced temporary storage queue. For\nexample, this situation can occur if the CICS region is not authorized to access the temporary\nstorage server.\nThis condition can also occur if the temporary storage server is not started, or because the\nserver has failed (or been stopped) while CICS continues to run.\nDefault action: terminate the task abnormally.\nChapter 2. CICS command summary  687"}
{"instruction": "What does this COBOL documentation say about this topic?", "input": "FORMATTIME\nTransform absolute date and time into a specified format.\nFORMATTIME\nFORMATTIME\nABSTIME( ", "output": "FORMATTIME\nTransform absolute date and time into a specified format.\nFORMATTIME\nFORMATTIME\nABSTIME(  data-area )\nDATE( data-area )\nFULLDATE(  data-area )\nDATEFORM(  data-area )\nDATESEP\n( data-value )\nDATESTRING(  data_area )\nSTRINGZONE(  cvda)\nDAYCOUNT(  data-area )\nDAYOFMONTH(  data-area )\nDAYOFWEEK(  data-area )\nDDMMYY( data-area )\nDDMMYYYY(  data-area )\nMILLISECONDS(  data-area )\nMMDDYY(  data-area )\nMMDDYYYY(  data-area )\nMONTHOFYEAR(  data-area )\nSTRINGFORMAT(  cvda)\nTIME( data-area )\nTIMESEP\n( data-value )\nYEAR( data-area )\nYYDDD(  data-area )\nYYDDMM(  data-area )\nYYMMDD(  data-area )\nYYYYDDD(  data-area )\nYYYYDDMM(  data-area )\nYYYYMMDD(  data-area )\nCondition: INVREQ\nThis command is threadsafe.\n \nChapter 2. CICS command summary  185"}
{"instruction": "Summarize this COBOL documentation section", "input": "j                      \nh                      \nm\nEnd   PERFORM example2\nExample 3\nThe output of example 3 looks like this:\nOUTPUT:\nStart PERFORM example3 \na                      \nf                      \nm\nEnd   PERFORM example3 \nExample 4\nThe output for example 4 looks like this:\nOUTPUT:\n426  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "j                      \nh                      \nm\nEnd   PERFORM example2\nExample 3\nThe output of example 3 looks like this:\nOUTPUT:\nStart PERFORM example3 \na                      \nf                      \nm\nEnd   PERFORM example3 \nExample 4\nThe output for example 4 looks like this:\nOUTPUT:\n426  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "Summarize this COBOL documentation section", "input": "Table 86. Reserved words (continued)\nWord\nReserved\nStandard only\nPotential\nreserved words\nRERUN\nX\n \n \nRESERVE\nX\n \n \nRESET\nX\n \n \nRESUME\n \n \nX\nRETRY\n \n \nX\nRETURN\nX\n \n \nRETURN-CODE\nX\n \n \nRETURNING\nX\n \n \nREVERSED\nX\n \n \nREWIND\nX\n \n \nREWRITE\nX\n \n \nRF\n \nX\n \nRH\n \nX\n \nRIGHT\nX\n \n \nROUNDED\nX\n \n \nRUN\nX\n \n \nSAME\nX\n \n \nSCREEN\n \n \nX\nSD\nX\n \n \nSEARCH\nX\n \n \nSECTION\nX\n \n \nSECURITY\nX\n \n \nSEGMENT\n \nX\n \nSEGMENT-LIMIT\nX\n \n \nSELECT\nX\n \n \nSELF\nX\n \n \nSEND\n \nX\n \nSENTENCE\nX\n \n \nSEPARATE\nX\n \n \nSEQUENCE\nX\n \n \nSEQUENTIAL\nX\n \n \nSERVICE\nX\n \n \nSET\nX\n \n \nSHARING\n \n \nX\nAppendix E. Reserved words  783", "output": "Table 86. Reserved words (continued)\nWord\nReserved\nStandard only\nPotential\nreserved words\nRERUN\nX\n \n \nRESERVE\nX\n \n \nRESET\nX\n \n \nRESUME\n \n \nX\nRETRY\n \n \nX\nRETURN\nX\n \n \nRETURN-CODE\nX\n \n \nRETURNING\nX\n \n \nREVERSED\nX\n \n \nREWIND\nX\n \n \nREWRITE\nX\n \n \nRF\n \nX\n \nRH\n \nX\n \nRIGHT\nX\n \n \nROUNDED\nX\n \n \nRUN\nX\n \n \nSAME\nX\n \n \nSCREEN\n \n \nX\nSD\nX\n \n \nSEARCH\nX\n \n \nSECTION\nX\n \n \nSECURITY\nX\n \n \nSEGMENT\n \nX\n \nSEGMENT-LIMIT\nX\n \n \nSELECT\nX\n \n \nSELF\nX\n \n \nSEND\n \nX\n \nSENTENCE\nX\n \n \nSEPARATE\nX\n \n \nSEQUENCE\nX\n \n \nSEQUENTIAL\nX\n \n \nSERVICE\nX\n \n \nSET\nX\n \n \nSHARING\n \n \nX\nAppendix E. Reserved words  783"}
{"instruction": "What is A statement in COBOL?", "input": "", "output": "A statement is valid combination of words, and begins with a COBOL statement"}
{"instruction": "What is the syntax for this COBOL construct?", "input": "diagram in this information, the term identifier refers to a valid combination of", "output": "diagram in this information, the term identifier refers to a valid combination of"}
{"instruction": "Explain this COBOL concept", "input": "RETCODE(data-area)\nspecifies the 6-byte application data area into which return code information (shown in Table 4 on\npage 203) is to be moved.\nSTATE(cvda)\ngets the state of the current conversation. The cvda values returned by CICS are:\n• ALLOCATED \n• CONFFREE \n• CONFRECEIVE \n• CONFSEND \n• FREE \n• PENDFREE \n• PENDRECEIVE \n• RECEIVE \n• ROLLBACK \n• SEND \n• SYNCFREE \n• SYNCRECEIVE \n• SYNCSEND \nTable 4. GDS EXTRACT ATTRIBUTES return codes\nRETCODE\n(hexadecimal)\nDescription\n03 00\nCONVID is for a session that is not APPC.\n03 00\nCONVID is for a session that is in use by CPI Communications.\n03 01\nINVREQ for a DPL server program.\n03 04\nCONVID is for a conversation that is not basic.\n04\nCONVID is for a session that is not allocated to the task, or that is a relay link.\nGDS EXTRACT PROCESS\nRetrieve values from an APPC basic conversation (assembler-language and C programs only).\nGDS EXTRACT PROCESS (APPC basic)\nGDS EXTRACT PROCESS\nCONVID(  name )\nPROCNAME(  data-area )\nPROCLENGTH(  data-area )\nMAXPROCLEN(  data-value )\nSYNCLEVEL(  data-area )\nPIPLIST( pointer-ref )\nPIPLENGTH(  data-area )\nRETCODE(  data-area )\n \nChapter 2. CICS command summary  203", "output": "RETCODE(data-area)\nspecifies the 6-byte application data area into which return code information (shown in Table 4 on\npage 203) is to be moved.\nSTATE(cvda)\ngets the state of the current conversation. The cvda values returned by CICS are:\n• ALLOCATED \n• CONFFREE \n• CONFRECEIVE \n• CONFSEND \n• FREE \n• PENDFREE \n• PENDRECEIVE \n• RECEIVE \n• ROLLBACK \n• SEND \n• SYNCFREE \n• SYNCRECEIVE \n• SYNCSEND \nTable 4. GDS EXTRACT ATTRIBUTES return codes\nRETCODE\n(hexadecimal)\nDescription\n03 00\nCONVID is for a session that is not APPC.\n03 00\nCONVID is for a session that is in use by CPI Communications.\n03 01\nINVREQ for a DPL server program.\n03 04\nCONVID is for a conversation that is not basic.\n04\nCONVID is for a session that is not allocated to the task, or that is a relay link.\nGDS EXTRACT PROCESS\nRetrieve values from an APPC basic conversation (assembler-language and C programs only).\nGDS EXTRACT PROCESS (APPC basic)\nGDS EXTRACT PROCESS\nCONVID(  name )\nPROCNAME(  data-area )\nPROCLENGTH(  data-area )\nMAXPROCLEN(  data-value )\nSYNCLEVEL(  data-area )\nPIPLIST( pointer-ref )\nPIPLENGTH(  data-area )\nRETCODE(  data-area )\n \nChapter 2. CICS command summary  203"}
{"instruction": "Explain this COBOL concept", "input": "Table 84. EBCDIC collating sequence (continued)\nOrdinal\nnumber\nSymbol\nMeaning\nDecimal\nrepresentation\nHex representation\n214\nN\n \n213\nD5\n215\nO\n \n214\nD6\n216\nP\n \n215\nD7\n217\nQ\n \n216\nD8\n218\nR\n \n217\nD9\n. . .\n \n \n \n \n225\n\\\nBackslash\n224\nE0\n. . .\n \n \n \n \n227\nS\n \n226\nE2\n228\nT\n \n227\nE3\n229\nU\n \n228\nE4\n230\nV\n \n229\nE5\n231\nW\n \n230\nE6\n232\nX\n \n231\nE7\n233\nY\n \n232\nE8\n234\nZ\n \n233\nE9\n. . .\n \n \n \n \n241\n0\n \n240\nF0\n242\n1\n \n241\nF1\n243\n2\n \n242\nF2\n244\n3\n \n243\nF3\n245\n4\n \n244\nF4\n246\n5\n \n245\nF5\n247\n6\n \n246\nF6\n248\n7\n \n247\nF7\n249\n8\n \n248\nF8\n250\n9\n \n249\nF9\n. . .\n \n \n \n \nUS English ASCII code page\nThe ASCII collating sequence is the order in which characters are defined in ASCII.\nThe following table presents the collating sequence for the US English ASCII code page. The collating\nsequence is the order in which characters are defined in ANSI INCITS 4, the 7-Bit American National\nStandard Code for Information Interchange (7-Bit ASCII), and in the International Reference Version of\nISO/IEC 646, 7-Bit Coded Character Set for Information Interchange.\n764  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference", "output": "Table 84. EBCDIC collating sequence (continued)\nOrdinal\nnumber\nSymbol\nMeaning\nDecimal\nrepresentation\nHex representation\n214\nN\n \n213\nD5\n215\nO\n \n214\nD6\n216\nP\n \n215\nD7\n217\nQ\n \n216\nD8\n218\nR\n \n217\nD9\n. . .\n \n \n \n \n225\n\\\nBackslash\n224\nE0\n. . .\n \n \n \n \n227\nS\n \n226\nE2\n228\nT\n \n227\nE3\n229\nU\n \n228\nE4\n230\nV\n \n229\nE5\n231\nW\n \n230\nE6\n232\nX\n \n231\nE7\n233\nY\n \n232\nE8\n234\nZ\n \n233\nE9\n. . .\n \n \n \n \n241\n0\n \n240\nF0\n242\n1\n \n241\nF1\n243\n2\n \n242\nF2\n244\n3\n \n243\nF3\n245\n4\n \n244\nF4\n246\n5\n \n245\nF5\n247\n6\n \n246\nF6\n248\n7\n \n247\nF7\n249\n8\n \n248\nF8\n250\n9\n \n249\nF9\n. . .\n \n \n \n \nUS English ASCII code page\nThe ASCII collating sequence is the order in which characters are defined in ASCII.\nThe following table presents the collating sequence for the US English ASCII code page. The collating\nsequence is the order in which characters are defined in ANSI INCITS 4, the 7-Bit American National\nStandard Code for Information Interchange (7-Bit ASCII), and in the International Reference Version of\nISO/IEC 646, 7-Bit Coded Character Set for Information Interchange.\n764  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference"}
{"instruction": "What is If the file in COBOL?", "input": "", "output": "If the file is tape unit, it will be rewound and unloaded.\n336  Enterprise COBOL for z/OS: Enterprise COBOL for z/OS 6.5 Language Reference\n\n\nTable 39"}
{"instruction": "What is 1 in COBOL?", "input": "", "output": "1 is UTF-8 literal or an elementary data item described with usage UTF-8, the value\nreturned is equal to the length of argument-1 in UTF-8 character positions"}
{"instruction": "What is POINTER phrase\nA data item defined with USAGE IS POINTER in COBOL?", "input": "", "output": "POINTER phrase\nA data item defined with USAGE IS POINTER is pointer data item or data-pointer"}
{"instruction": "Explain this COBOL concept", "input": "Ellipsis (. . .) indicates omission of a range of ordinal numbers between predecessor and successor ordinal\nnumbers.\nTable 85. ASCII collating sequence\nOrdinal\nnumber\nSymbol\nMeaning\nDecimal\nrepresentation\nHex representation\n1\n \nNull\n0\n0\n. . .\n \n \n \n \n33\n \nSpace\n32\n20\n34\n!\nExclamation point\n33\n21\n35\n\"\nQuotation mark\n34\n22\n36\n#\nNumber sign\n35\n23\n37\n$\nDollar sign\n36\n24\n38\n%\nPercent sign\n37\n25\n39\n&\nAmpersand\n38\n26\n40\n'\nApostrophe, prime sign\n39\n27\n41\n(\nOpening parenthesis\n40\n28\n42\n)\nClosing parenthesis\n41\n29\n43\n*\nAsterisk\n42\n2A\n44\n+\nPlus sign\n43\n2B\n45\n,\nComma\n44\n2C\n46\n-\nHyphen, minus\n45\n2D\n47\n.\nPeriod, decimal point\n46\n2E\n48\n/\nSlash, solidus\n47\n2F\n49\n0\n \n48\n30\n50\n1\n \n49\n31\n51\n2\n \n50\n32\n52\n3\n \n51\n33\n53\n4\n \n52\n34\n54\n5\n \n53\n35\n55\n6\n \n54\n36\n56\n7\n \n55\n37\n57\n8\n \n56\n38\n58\n9\n \n57\n39\n59\n:\nColon\n58\n3A\n60\n;\nSemicolon\n59\n3B\n61\n<\nLess than sign\n60\n3C\n62\n=\nEqual sign\n61\n3D\nAppendix C. EBCDIC and ASCII collating sequences  765", "output": "Ellipsis (. . .) indicates omission of a range of ordinal numbers between predecessor and successor ordinal\nnumbers.\nTable 85. ASCII collating sequence\nOrdinal\nnumber\nSymbol\nMeaning\nDecimal\nrepresentation\nHex representation\n1\n \nNull\n0\n0\n. . .\n \n \n \n \n33\n \nSpace\n32\n20\n34\n!\nExclamation point\n33\n21\n35\n\"\nQuotation mark\n34\n22\n36\n#\nNumber sign\n35\n23\n37\n$\nDollar sign\n36\n24\n38\n%\nPercent sign\n37\n25\n39\n&\nAmpersand\n38\n26\n40\n'\nApostrophe, prime sign\n39\n27\n41\n(\nOpening parenthesis\n40\n28\n42\n)\nClosing parenthesis\n41\n29\n43\n*\nAsterisk\n42\n2A\n44\n+\nPlus sign\n43\n2B\n45\n,\nComma\n44\n2C\n46\n-\nHyphen, minus\n45\n2D\n47\n.\nPeriod, decimal point\n46\n2E\n48\n/\nSlash, solidus\n47\n2F\n49\n0\n \n48\n30\n50\n1\n \n49\n31\n51\n2\n \n50\n32\n52\n3\n \n51\n33\n53\n4\n \n52\n34\n54\n5\n \n53\n35\n55\n6\n \n54\n36\n56\n7\n \n55\n37\n57\n8\n \n56\n38\n58\n9\n \n57\n39\n59\n:\nColon\n58\n3A\n60\n;\nSemicolon\n59\n3B\n61\n<\nLess than sign\n60\n3C\n62\n=\nEqual sign\n61\n3D\nAppendix C. EBCDIC and ASCII collating sequences  765"}
